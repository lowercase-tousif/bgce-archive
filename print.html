<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BGCE ARCHIVE</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BGCE ARCHIVE</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NesoHQ/bgce-archive.git" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-golang-community-vault"><a class="header" href="#-golang-community-vault">üåê <strong>Golang Community Vault</strong></a></h1>
<p>Welcome to <strong>Golang Community Archive</strong>, a community-driven digital archive designed to collect, organize, and preserve the vast knowledge, resources, and experiences from the Go programming ecosystem and beyond. Whether you're a beginner, job seeker, seasoned contributor, or mentor ‚Äî <strong>this is the place</strong> where we give and receive knowledge.</p>
<hr />
<h2 id="-project-purpose"><a class="header" href="#-project-purpose">üéØ <strong>Project Purpose</strong></a></h2>
<p>The <strong>Golang Community Vault</strong> is not just an archive, it's a vibrant, evolving repository that serves:</p>
<ul>
<li>üìö <strong>Preservation</strong> of valuable community-generated content.</li>
<li>ü§ù <strong>Collaboration</strong> to promote open knowledge sharing and growth.</li>
<li>üîé <strong>Job Seekers &amp; Learners</strong> can gain insights from real-world experiences.</li>
<li>üß† <strong>Centralized Resources</strong> to gather knowledge and tools scattered across the web.</li>
</ul>
<hr />
<h2 id="-stay-connected--grow-with-us"><a class="header" href="#-stay-connected--grow-with-us">üí¨ <strong>Stay Connected &amp; Grow With Us!</strong></a></h2>
<p>We believe in <strong>community-driven learning</strong>. Whether you're here to contribute, collaborate, or just explore ‚Äî your presence makes a difference. üíõ</p>
<p>Join the <strong>Best Golang Community Ever</strong> and become part of something bigger than just code!</p>
<hr />
<h3 id="-connect-with-us"><a class="header" href="#-connect-with-us">üåê <strong>Connect With Us</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>üåü Platform</th><th>üìå Join Link</th></tr></thead><tbody>
<tr><td>üí¨ <strong>Discord</strong></td><td><a href="https://discord.gg/xUVYrGaXS3">Join the Go Community on Discord</a> ‚Äì Real-time discussions, questions, support, and collab rooms.</td></tr>
<tr><td>üìò <strong>Facebook Group</strong></td><td><a href="https://www.facebook.com/groups/1118405403169990">Join the Go Facebook Community</a> ‚Äì Casual Q&amp;As, success stories, community posts, and announcements.</td></tr>
<tr><td>üé• <strong>YouTube Channel</strong></td><td><a href="https://www.youtube.com/@gowithhabib">Subscribe to GoWithHabib</a> ‚Äì Deep dives, tutorials, interviews, and community videos.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="-get-involved"><a class="header" href="#-get-involved">ü§ù <strong>Get Involved</strong></a></h3>
<p>‚úÖ Share your stories, notes, code, or insights<br />
‚úÖ Help with templates, docs, automation, or structure<br />
‚úÖ Collaborate on our <strong>static site</strong> or <strong>web vault</strong><br />
‚úÖ Be part of building something that helps thousands</p>
<hr />
<h3 id="-together-we-learn--grow"><a class="header" href="#-together-we-learn--grow">‚ú® <strong>Together, We Learn &amp; Grow</strong></a></h3>
<blockquote>
<p><em>‚ÄúCode fades. Community lasts.‚Äù</em><br />
Let‚Äôs archive knowledge, share what we‚Äôve learned, and help the next generation of Gophers grow. üêπüöÄ</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="-archive-categories"><a class="header" href="#-archive-categories">üìÇ <strong>Archive Categories</strong></a></h2>
<p>Here's a quick look at the structure of the archive, where each folder represents a key area of Golang knowledge, experience, and resources.</p>
<pre><code class="language-bash">golang-community-vault/
‚îú‚îÄ‚îÄ 1-interview-qa/         # Real interview Q&amp;A and topic-wise challenges
‚îÇ   ‚îú‚îÄ‚îÄ company-wise/       # Interview questions by company (Google, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ topic-wise/         # Go concepts (goroutines, interfaces, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ curated-challenges/ # Problem-solving &amp; deep dives
‚îú‚îÄ‚îÄ 2-class-notes/          # Course notes &amp; summaries
‚îÇ   ‚îú‚îÄ‚îÄ university-notes/   # Academic notes from CS/SE courses
‚îÇ   ‚îú‚îÄ‚îÄ bootcamp-notes/     # Bootcamp summaries
‚îÇ   ‚îî‚îÄ‚îÄ online-course-summaries/ # Udemy, Coursera, etc.
‚îú‚îÄ‚îÄ 3-project-archive/      # Real-world Golang projects
‚îÇ   ‚îú‚îÄ‚îÄ cli-tools/          # Command-line Go utilities
‚îÇ   ‚îú‚îÄ‚îÄ web-servers/        # REST/HTTP server projects
‚îÇ   ‚îú‚îÄ‚îÄ microservices/      # Auth, DB, API services
‚îÇ   ‚îî‚îÄ‚îÄ misc-projects/      # Other cool stuff
‚îú‚îÄ‚îÄ 4-image-infographic-archive/ # Visual aids like diagrams, cheat sheets
‚îÇ   ‚îú‚îÄ‚îÄ architecture-diagrams/
‚îÇ   ‚îú‚îÄ‚îÄ cheat-sheets/
‚îÇ   ‚îî‚îÄ‚îÄ flowcharts/
‚îú‚îÄ‚îÄ 5-community-stories/    # Real experiences, job search, career switch
‚îÇ   ‚îú‚îÄ‚îÄ job-search-experience/
‚îÇ   ‚îú‚îÄ‚îÄ rejection-learnings/
‚îÇ   ‚îî‚îÄ‚îÄ career-switch-tales/
‚îú‚îÄ‚îÄ 6-package-archive/     # Community-built Go libraries and tools
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ api-clients/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îî‚îÄ‚îÄ tools-and-libs/
‚îú‚îÄ‚îÄ 7-community-blogs/     # Written insights from the community
‚îÇ   ‚îú‚îÄ‚îÄ how-tos/
‚îÇ   ‚îú‚îÄ‚îÄ internals/
‚îÇ   ‚îú‚îÄ‚îÄ opinion-pieces/
‚îÇ   ‚îî‚îÄ‚îÄ tutorials/
‚îú‚îÄ‚îÄ 8-news-events/         # Updates from the Go world
‚îÇ   ‚îú‚îÄ‚îÄ newsletters/
‚îÇ   ‚îú‚îÄ‚îÄ conference-recaps/
‚îÇ   ‚îú‚îÄ‚îÄ meetup-summaries/
‚îÇ   ‚îî‚îÄ‚îÄ hackathons/
‚îú‚îÄ‚îÄ 9-video-archive/       # Curated video learning
‚îÇ   ‚îú‚îÄ‚îÄ tutorials/
‚îÇ   ‚îú‚îÄ‚îÄ tech-talks/
‚îÇ   ‚îú‚îÄ‚îÄ documentaries/
‚îÇ   ‚îî‚îÄ‚îÄ playlists/
‚îú‚îÄ‚îÄ 10-course-content/     # Full-length open-source Go courses
‚îÇ   ‚îú‚îÄ‚îÄ community-courses/
‚îÇ   ‚îú‚îÄ‚îÄ mini-moocs/
‚îÇ   ‚îî‚îÄ‚îÄ challenge-series/
‚îú‚îÄ‚îÄ 11-link-resource-archive/ # Curated bookmarks and links
‚îÇ   ‚îú‚îÄ‚îÄ tooling/
‚îÇ   ‚îú‚îÄ‚îÄ blogs/
‚îÇ   ‚îú‚îÄ‚îÄ documentation/
‚îÇ   ‚îú‚îÄ‚îÄ slide-decks/
‚îÇ   ‚îî‚îÄ‚îÄ benchmarks/
</code></pre>
<hr />
<h2 id="-category-overview"><a class="header" href="#-category-overview">üìÅ <strong>Category Overview</strong></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Microservice</th><th>Description</th><th>Documentation Link</th></tr></thead><tbody>
<tr><td><code>1-interview-qa/</code></td><td>Real interview Q&amp;A and Go-topic challenges</td><td>üîó <a href="category/./docs/services/intereview-qa/inteview-qa.html">Golang Interview Q&amp;A - Bangla</a></td></tr>
<tr><td><code>2-class-notes/</code></td><td>Academic and bootcamp course notes &amp; summaries</td><td>üîó <a href="category/index.html#">Class Notes Documentation</a></td></tr>
<tr><td><code>3-project-archive/</code></td><td>Real-world Go projects (CLI, web, microservices)</td><td>üîó <a href="category/index.html#">Project Archive Documentation</a></td></tr>
<tr><td><code>4-image-infographic-archive/</code></td><td>Diagrams, cheat sheets, flowcharts</td><td>üîó <a href="category/index.html#">Visual Archive Documentation</a></td></tr>
<tr><td><code>5-community-stories/</code></td><td>Job search experiences, lessons, and career stories</td><td>üîó <a href="category/index.html#">Community Stories Documentation</a></td></tr>
<tr><td><code>6-package-archive/</code></td><td>Go libraries, middleware, API clients, etc.</td><td>üîó <a href="category/index.html#">Package Archive Documentation</a></td></tr>
<tr><td><code>7-community-blogs/</code></td><td>Blogs, how-tos, opinion pieces from the community</td><td>üîó <a href="category/index.html#">Community Blogs Documentation</a></td></tr>
<tr><td><code>8-news-events/</code></td><td>Go community news, events, hackathons</td><td>üîó <a href="category/index.html#">News &amp; Events Documentation</a></td></tr>
<tr><td><code>9-video-archive/</code></td><td>Curated learning videos, tech talks, playlists</td><td>üîó <a href="category/index.html#">Video Archive Documentation</a></td></tr>
<tr><td><code>10-course-content/</code></td><td>Full-length open-source Go courses</td><td>üîó <a href="category/index.html#">Course Content Documentation</a></td></tr>
<tr><td><code>11-link-resource-archive/</code></td><td>Curated links to tools, documentation, benchmarks</td><td>üîó <a href="category/index.html#">Link Resources Documentation</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="contribution-guide"><a class="header" href="#contribution-guide">Contribution Guide</a></h2>
<h3 id="-how-to-contribute"><a class="header" href="#-how-to-contribute">‚úçÔ∏è <strong>How to Contribute?</strong></a></h3>
<p>We're excited to have you contribute to the <strong>Golang Community Vault</strong>! Whether you‚Äôre adding resources, sharing your experiences, or helping to maintain content ‚Äî you are adding to the growth and strength of our community.</p>
<hr />
<h3 id="-types-of-contributions"><a class="header" href="#-types-of-contributions">üöÄ <strong>Types of Contributions</strong></a></h3>
<p>We welcome a wide range of contributions! Here‚Äôs how you can help:</p>
<ul>
<li>
<p><strong>Knowledge Sharing</strong><br />
Contribute articles, tutorials, or reference material that can help others learn and grow.</p>
</li>
<li>
<p><strong>Real-world Experiences</strong><br />
Share your job search stories, career-switch insights, rejection learnings, or any other experiences that can inspire and educate others.</p>
</li>
<li>
<p><strong>Code &amp; Projects</strong><br />
Upload your open-source Golang projects, libraries, tools, or code snippets that can benefit the community.</p>
</li>
<li>
<p><strong>Learning Resources</strong><br />
Contribute notes, video tutorials, course summaries, or any other educational content to help others learn Golang.</p>
</li>
</ul>
<hr />
<h3 id="-contributors-guides"><a class="header" href="#-contributors-guides">üìö <strong>Contributor‚Äôs Guides</strong></a></h3>
<ul>
<li>
<p><strong>For Non-Tech Contributions</strong><br />
No coding required! Learn how you can help with documentation, resources, and content.<br />
üîó <a href="contribution-guide/NO-CODE.html">Contributor‚Äôs Guide (No-Code)</a></p>
</li>
<li>
<p><strong>For Code Contributions</strong><br />
If you want to contribute code or projects, follow our code contribution guidelines.<br />
üîó <a href="contribution-guide/CONTRIBUTING.html">Contributor‚Äôs Guide (Code)</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="-commit-strategy"><a class="header" href="#-commit-strategy">üìå COMMIT STRATEGY</a></h3>
<h4 id="-format"><a class="header" href="#-format">‚úÖ Format:</a></h4>
<pre><code>[&lt;type&gt;] &lt;short-description&gt;
</code></pre>
<h4 id="-types"><a class="header" href="#-types">üí° Types:</a></h4>
<ul>
<li><code>feat</code>: New content or file</li>
<li><code>fix</code>: Fixes formatting or broken links</li>
<li><code>docs</code>: Changes to README, guides</li>
<li><code>refactor</code>: Structural changes</li>
</ul>
<h4 id="-example-commits"><a class="header" href="#-example-commits">üß™ Example Commits:</a></h4>
<pre><code>[feat] Add interview questions for GCP
[fix] Correct broken link in course summary
[docs] Add README to cli-tools
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="-contribution-templates-for-golang-community-vault"><a class="header" href="#-contribution-templates-for-golang-community-vault">üß© CONTRIBUTION TEMPLATES FOR GOLANG COMMUNITY VAULT</a></h2>
<h4 id="welcome-to-the-golang-community-vault"><a class="header" href="#welcome-to-the-golang-community-vault">Welcome to the Golang Community Vault!</a></h4>
<p>We‚Äôre excited to have your contributions. Here's how you can help:</p>
<h4 id="-guidelines"><a class="header" href="#-guidelines">üìå Guidelines:</a></h4>
<ul>
<li><strong>Fork</strong> the repo and create a new branch (name it <code>feat/&lt;title&gt;</code> or <code>fix/&lt;title&gt;</code>).</li>
<li>Add your Markdown files to the appropriate subfolder.</li>
<li>Follow our [README] For Complete Documentation.</li>
<li>Ensure links are working and code is properly formatted.</li>
<li>Commit strategy using our <a href="contribution-guide/COMMIT-STRATEGY.html">COMMIT STRATEGY</a>.</li>
<li>Submit a pull request using our <a href="contribution-guide/PR.html">PULL REQUEST Template</a>.</li>
</ul>
<h4 id="-folder-naming-convention"><a class="header" href="#-folder-naming-convention">üìÇ Folder Naming Convention:</a></h4>
<ul>
<li>All folders must use <code>kebab-case</code>.</li>
<li>Use <code>README.md</code> inside folders for summaries.</li>
</ul>
<h4 id="-markdown-file-template"><a class="header" href="#-markdown-file-template">üìù Markdown File Template</a></h4>
<pre><code class="language-md"># [Title]

**Author:** @yourhandle
**Date:** YYYY-MM-DD
**Category:** e.g., interview-qa/topic-wise
**Tags:** [go, concurrency, channels]

---

## üß† Summary

_Brief explanation of the content._

## üß© Content

### Overview

### Key Concepts

### Code

```go
// Example snippet\`
```
</code></pre>
<h2 id="-resources"><a class="header" href="#-resources">üìö Resources</a></h2>
<ul>
<li><a href="contribution-guide/">Link1</a></li>
</ul>
<pre><code>
## ‚úÖ Contribution Rules

-   Must include summary, author, and tags
-   Format code blocks
-   External links must be verified

## üîó Links

-   [Templates](../templates)
-   [Static Site Preview](../site)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="-non-tech-contributions-no-code-required"><a class="header" href="#-non-tech-contributions-no-code-required">üí° <strong>Non-Tech Contributions (No code required!)</strong></a></h3>
<p>You can still make a huge impact without writing any code. Here‚Äôs how:</p>
<ul>
<li>
<p><strong>Content Contributions</strong><br />
Add value by submitting resources, notes, blog posts, or guides. You don‚Äôt need to write code to make a meaningful contribution!</p>
</li>
<li>
<p><strong>Community Engagement</strong><br />
Help grow the knowledge base by engaging with others. Review content, offer suggestions, and be a part of discussions that improve the Vault.</p>
</li>
</ul>
<hr />
<p>We accept many types of contributions:</p>
<ul>
<li><strong>üß† Interview Content</strong> ‚Äì Real-world Q&amp;A, curated challenges, topic-wise notes.</li>
<li><strong>üìö Class Notes</strong> ‚Äì University, bootcamp, or online course summaries.</li>
<li><strong>üñºÔ∏è Visual Resources</strong> ‚Äì Architecture diagrams, cheat sheets, flowcharts.</li>
<li><strong>üìñ Blog Posts</strong> ‚Äì How-tos, opinion pieces, technical deep-dives.</li>
<li><strong>üé¨ Videos</strong> ‚Äì Tech talks, tutorials, playlists, or webinars.</li>
<li><strong>üìñ Personal Stories</strong> ‚Äì Career transitions, rejections, job search journeys.</li>
<li><strong>üîó Curated Links</strong> ‚Äì Tools, docs, slide decks, benchmarks.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h3 id="-pull-request-template"><a class="header" href="#-pull-request-template">‚úÖ PULL REQUEST TEMPLATE</a></h3>
<pre><code class="language-md">### üìò Description

What this PR adds/fixes/improves.

### üìÇ Related Issue

Closes #[issue-number]

### üöÄ Changes Made

- Added/Updated [category/file-name.md]
- Fixed formatting/link issues

### ‚úÖ Checklist

- [ ] Follows contribution guidelines
- [ ] Uses correct Markdown format
- [ ] Tested rendering in preview
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>Mehraz
Obaydullah</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Microservice Documentation Template</strong> for each category, following a <strong>Domain-Driven Design (DDD)</strong> approach for your <code>golang-community-vault</code> project:</p>
<pre><code class="language-md"># üìò Microservice - 1-interview-qa

## üìå Domain Context

This microservice belongs to the **Interview Q&amp;A Domain**, responsible for organizing and serving real-world interview questions and structured problem-solving content. It reflects bounded contexts like company-specific Q&amp;A, topic-wise Go concepts, and curated deep dives.

## üß© Subdomains

-   `company-wise/` - Q&amp;A by hiring companies (Google, Meta, etc.)
-   `topic-wise/` - Q&amp;A by technical concept (e.g., Goroutines, Channels)
-   `curated-challenges/` - Problem-solving sets with expected patterns

## üß™ Core Capabilities

-   Serve categorized Markdown-based content for interviews
-   Support contributor-submitted Q&amp;A in structured format
-   Enable easy search/navigation via tags and metadata

## üèóÔ∏è Expected Structure - Coming Soon
</code></pre>
<pre><code>
## üîÑ Input/Output Contract

### Input
- Markdown files via pull requests
- Validated metadata in frontmatter (e.g., tags, difficulty, author)

### Output
- Rendered HTML pages for Docusaurus
- Searchable metadata (for filtering/search)

## ‚öôÔ∏è Internal Models

```go
type InterviewQuestion struct {
    Title       string   `json:"title"`
    Company     string   `json:"company,omitempty"`
    Topics      []string `json:"topics"`
    Difficulty  string   `json:"difficulty"` // easy | medium | hard
    Author      string   `json:"author"`
    Content     string   `json:"content"` // Markdown
}
</code></pre>
<h2 id="-maintainers"><a class="header" href="#-maintainers">üõ† Maintainers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>GitHub Handle</th><th>Role</th></tr></thead><tbody>
<tr><td>@username1</td><td>Lead Maintainer</td></tr>
<tr><td>@username2</td><td>Domain Reviewer</td></tr>
</tbody></table>
</div>
<h2 id="-directory-ownership"><a class="header" href="#-directory-ownership">üìÇ Directory Ownership</a></h2>
<p>This service owns:</p>
<ul>
<li><code>interview-qa/**</code></li>
</ul>
<h2 id="-references"><a class="header" href="#-references">üìö References</a></h2>
<ul>
<li><a href="interview-qna/../../.github/templates/CONTRIBUTING.html">Markdown contribution templates</a></li>
<li><a href="interview-qna/../../schemas/interview-question.schema.json">Content schema definition</a></li>
<li><a href="interview-qna/../../docs/rbac/interview-qa.html">RBAC permissions</a></li>
</ul>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-golang-playground"><a class="header" href="#-golang-playground">üêπ Golang Playground</a></h1>
<p>Welcome to my Golang knowledge hub ‚Äî a growing collection of experiments, course notes, and practical learnings as I dive deeper into Go üöÄ</p>
<hr />
<h2 id="-structure-will-be-updated-in-future"><a class="header" href="#-structure-will-be-updated-in-future">üìÇ Structure (will be updated in future)</a></h2>
<pre><code>golang/ 
    ‚îú‚îÄ‚îÄ experiment/
    ‚îî‚îÄ‚îÄ go-with-habib-class-notes/
</code></pre>
<h3 id="-experiment"><a class="header" href="#-experiment">üî¨ <code>experiment/</code></a></h3>
<p>A sandbox for all my Go experiments. From testing features to quick problem-solving attempts, this folder is all about learning by doing.</p>
<h3 id="-go-with-habib-class-notes"><a class="header" href="#-go-with-habib-class-notes">üìò <code>go-with-habib-class-notes/</code></a></h3>
<p>Detailed notes and example code from the <strong>"Go with Habib"</strong> course. Organized by class, with code and key takeaways.</p>
<hr />
<h2 id="-whats-next"><a class="header" href="#-whats-next">üìå What's Next?</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Add more Go mini-projects and tools under <code>experiment/</code></li>
<li><input disabled="" type="checkbox"/>
Continue documenting the Habib course in markdown</li>
<li><input disabled="" type="checkbox"/>
Add <code>README.md</code> for each class and experiment</li>
<li><input disabled="" type="checkbox"/>
Eventually turn this entire <code>golang/</code> folder into part of the <code>bytebook</code> mdBook</li>
</ul>
<hr />
<blockquote>
<p>This is just the beginning. Watch this space as my Go journey evolves! üò§</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>class-1: array</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-class-16--package-scope"><a class="header" href="#-class-16--package-scope">üì¶ Class 16 ‚Äî Package Scope</a></h1>
<p>üé• <strong>Video Title</strong>: <em>Package scope</em></p>
<hr />
<h2 id="-code-written-for-this-class"><a class="header" href="#-code-written-for-this-class">üß™ Code Written for This Class</a></h2>
<h3 id="addgo"><a class="header" href="#addgo"><code>add.go</code></a></h3>
<pre><code class="language-go">package main

import "fmt"

func add(n1, n2 int) {
	res := n1 + n2
	fmt.Println(res)
}
</code></pre>
<h3 id="maingo"><a class="header" href="#maingo"><code>main.go</code></a></h3>
<pre><code class="language-go">package main

var (
	a = 20
	b = 30
)

func main() {
	add(4,7)
}
</code></pre>
<h3 id="mathlibmathgo"><a class="header" href="#mathlibmathgo"><code>mathlib/math.go</code></a></h3>
<pre><code class="language-go">package mathlib

import "fmt"

func Add(x int, y int) {
	z := x + y
	fmt.Println(z)
}
</code></pre>
<h3 id="maingo-modified"><a class="header" href="#maingo-modified"><code>main.go (Modified)</code></a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
	"example.com/mathlib"
)

var (
	a = 20
	b = 30
)

func main() {
	fmt.Println("Showing Custom Package")
	mathlib.Add(4,7)
}
</code></pre>
<h1 id="-key-concepts"><a class="header" href="#-key-concepts">üîë Key Concepts</a></h1>
<ol>
<li>
<p><strong>Same Folder = Same Package</strong>
All <code>.go</code> files in the same directory should have the same package name (<code>main</code> if you want to run them).</p>
</li>
<li>
<p><strong>Running Multiple Files</strong>
You must include all necessary files when using <code>go run</code>, like:</p>
<pre><code class="language-bash">go run main.go add.go
</code></pre>
</li>
<li>
<p><strong>Initializing a New Module</strong>
Start with:</p>
<pre><code class="language-bash">go mod init &lt;module_name&gt;
</code></pre>
</li>
<li>
<p><strong>Managing Dependencies</strong>
Use:</p>
<pre><code class="language-bash">go get &lt;package_name&gt;
go mod tidy
</code></pre>
</li>
<li>
<p><strong>Package-Level Scope Rules</strong>
Only <strong>exported</strong> identifiers (functions/variables that start with a <strong>capital letter</strong>) can be accessed from outside the package.</p>
</li>
</ol>
<p>üß† This class was all about understanding how Go handles packages, visibility, and modular code ‚Äî crucial stuff for building real-world Go apps!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-class-17"><a class="header" href="#-class-17">üìò Class 17</a></h1>
<p><strong>Video Name:</strong> Scope with another boring example üôÉ</p>
<hr />
<h2 id="-code-written-in-this-class"><a class="header" href="#-code-written-in-this-class">üßë‚Äçüíª Code written in this class</a></h2>
<pre><code class="language-go">package main

import "fmt"

var (
	a = 10
	b = 20
)

func printNum(num int) {
	fmt.Println(num)
}

func add(x int, y int) {
	res := x + y
	printNum(res)
}

func main() {
	add(a, b)
}
</code></pre>
<h2 id="-key-concepts-1"><a class="header" href="#-key-concepts-1">üß† Key Concepts</a></h2>
<ol>
<li>
<p><strong>‚úÖ Order doesn't matter (for package-level stuff)</strong>
The order of functions and globally declared variables does not matter in Go.
Even if the functions and variables are defined after <code>main()</code>, Go will still recognize and compile everything correctly.</p>
</li>
<li>
<p><strong>ü§ì Go ‚â† Functional Paradigm</strong>
Although Go has borrowed some cool ideas from functional languages (like first-class functions, closures, etc.), <strong>Go is not a functional programming language.</strong></p>
</li>
<li>
<p><strong>‚öñÔ∏è What paradigm is Go really?</strong></p>
<blockquote>
<p>Go is a <strong>multi-paradigm</strong> language, but its primary style is <strong>imperative</strong> and <strong>procedural</strong>, with <strong>struct-based composition</strong> over classic OOP.</p>
</blockquote>
</li>
</ol>
<p>It's built to be:</p>
<pre><code>‚úÖ Simple

üîç Predictable

üìñ Readable
</code></pre>
<p>You can write in a functional-ish style, but Go wasn‚Äôt designed for heavy functional abstractions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-interview-question-variable-shadowing-in-go"><a class="header" href="#-interview-question-variable-shadowing-in-go">üí° Interview Question: Variable Shadowing in Go</a></h1>
<h2 id="-code-example"><a class="header" href="#-code-example">üß™ Code Example</a></h2>
<pre><code class="language-go">package main

import "fmt"

var a = 10

func main() {
	age := 30

	if age &gt; 18 {
		a := 47        // üëá Shadows the global `a` ONLY inside this `if` block
		fmt.Println(a) // ‚ûú 47
	}

	fmt.Println(a)     // ‚ûú 10 (prints the global `a`)
}
</code></pre>
<h2 id="-takeaways"><a class="header" href="#-takeaways">üìå Takeaways:</a></h2>
<ol>
<li>
<p>üîí Variable shadowing occurs when a local variable has the same name as a variable in an outer scope.</p>
</li>
<li>
<p>‚õî Go won't throw an error ‚Äî it‚Äôll just use the innermost version in the current scope.</p>
</li>
<li>
<p>üì¶ Global <code>a</code> is untouched and printed outside the <code>if</code> block.</p>
</li>
<li>
<p>‚úÖ This behavior is intentional and useful for encapsulation and temporary overrides.</p>
</li>
</ol>
<h2 id="-memory--stack-animation--step-by-step"><a class="header" href="#-memory--stack-animation--step-by-step">üß† Memory &amp; Stack Animation ‚Äî Step by Step</a></h2>
<pre><code>// ‚è± Program Start
üì¶ Data Segment:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ global a=10 ‚îÇ ‚óÑ‚îÄ‚îÄ stays alive till program ends
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// üöÄ main() gets called
üìö Stack:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üß© main() Stack Frame      ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ age = 30             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

--- age &gt; 18 is TRUE, so we enter the `if` block ---

üß± New block scope begins inside main()
üìö Stack:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üß© main() Stack Frame      ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ age = 30             ‚îÇ
‚îÇ   üî∏ a (shadows global) =47‚îÇ ‚óÑ‚îÄ‚îÄ new `a` shadows the global
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üñ®Ô∏è fmt.Println(a)
üì§ Output: 47 ‚úÖ

--- if block ends, block-scope a is destroyed ---

üìö Stack:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üß© main() Stack Frame      ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ age = 30             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üñ®Ô∏è fmt.Println(a)
üì§ Output: 10 ‚úÖ (Back to global `a`)

--- main() ends, stack is popped ---

üìö Stack:
(empty)

üßº Program exits
</code></pre>
<h2 id="-visualization-summary"><a class="header" href="#-visualization-summary">üìå Visualization Summary</a></h2>
<p>-[] üß† Global variables (like a = 10) live in the data segment.</p>
<p>-[] üßµ Local variables (like age or shadowed a) live in the stack.</p>
<p>-[] üîÑ When a new scope is entered (if, for, function block), it pushes new variables to the stack.</p>
<p>-[] ‚õìÔ∏è Once the block ends, the shadowed variable gets popped and memory is freed.</p>
<p>-[] üßº At the end, the stack is cleared, but the data segment lives throughout the whole execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-types"><a class="header" href="#function-types">Function types</a></h1>
<ul>
<li>standard or named fucntion</li>
<li>Anonymous function</li>
<li>Function expression or assign function in variable</li>
<li>Higher order fucntion or first class function</li>
<li>Callback fucntion</li>
<li>Variadic function</li>
<li>Init function - you cannot call this, Computer calls it</li>
<li>Closure - close over</li>
<li>Defer function - last in first out</li>
<li>Receiver function or method</li>
<li>IIFE- Immediately invoked function expression</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-class-19-init-function"><a class="header" href="#-class-19-init-function">üß† Class 19: Init Function</a></h1>
<p><strong>Video Topic</strong>: <code>init()</code> Function in Go</p>
<hr />
<h2 id="-code-written-in-this-class-1"><a class="header" href="#-code-written-in-this-class-1">üî§ Code Written in This Class</a></h2>
<pre><code class="language-go">//example 1
package main

import "fmt"

func main() {
	fmt.Println("Hello Init Function!")
}

func init() {
	fmt.Println("I am the function that is executed first")
}
</code></pre>
<pre><code class="language-go">//example 2
package main

import "fmt"

var a = 10

func main() {
	fmt.Println(a)
}

func init() {
	fmt.Println(a)
	a = 20
}
</code></pre>
<h2 id="-key-concepts-2"><a class="header" href="#-key-concepts-2">üîç Key Concepts</a></h2>
<ol>
<li>
<p><code>init()</code> is a special Go function that runs before <code>main()</code>, automatically.</p>
</li>
<li>
<p>You can have multiple <code>init()</code> functions across different files and packages. They all run in the order of:</p>
<ul>
<li>
<p>Dependency packages first</p>
</li>
<li>
<p>File order (top to bottom) next</p>
</li>
</ul>
</li>
<li>
<p>You don't call <code>init()</code> manually. It runs automatically before the program starts.</p>
</li>
</ol>
<h2 id="-cli-memory--execution-visualization-example-1"><a class="header" href="#-cli-memory--execution-visualization-example-1">üß† CLI Memory &amp; Execution Visualization (example 1)</a></h2>
<p>Let‚Äôs visualize how Go handles <code>init()</code> under the hood:</p>
<pre><code>// üõ† Compile Time: Go detects init()

Found init() in main package ‚úÖ

----------- EXECUTION BEGINS -----------

üß† Data Segment:
(none)

üìö Stack:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üß© init()           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üñ®Ô∏è Output:
"I am the function that is executed first"

üëã init() returns

üìö Stack:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üß© main()           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üñ®Ô∏è Output:
"Hello Init Function!"

‚úÖ Program ends gracefully
</code></pre>
<h2 id="-cli-visualization-execution--memory-layout-example-2"><a class="header" href="#-cli-visualization-execution--memory-layout-example-2">üîç CLI Visualization: Execution &amp; Memory Layout (example 2)</a></h2>
<pre><code>=========== Program Compilation ===========
Found global variable: a = 10
Found init() ‚úÖ
Found main() ‚úÖ

=========== Execution Begins ==============

üß† Data Segment (Globals):
a = 10 ‚Üê initialized before anything runs

üìö Stack Frame:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  init()    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üîÅ init() runs
‚Üí Prints: 10
‚Üí Updates a = 20

Stack after init():
(returns to runtime)

üìö Stack Frame:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  main()    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üîÅ main() runs
‚Üí Prints: 20

=========== Execution Ends ================

üìå Summary

    ‚úÖ Global variable a is initialized before any function runs.

    ‚öôÔ∏è init() executes first:

        Reads a = 10

        Changes a = 20

    üß® main() sees updated value: 20

This is a classic example of how init() can prepare or modify the runtime environment before the actual program logic in main() kicks in.

</code></pre>
<h2 id="-quick-recap"><a class="header" href="#-quick-recap">‚ö° Quick Recap</a></h2>
<ol>
<li>
<p>‚úÖ <code>init()</code> always runs before <code>main()</code> even if it‚Äôs written after <code>main()</code> in your code.</p>
</li>
<li>
<p>‚õìÔ∏è You can use it to initialize configs, connections, default values, etc.</p>
</li>
<li>
<p>üí° A Go file can have at most one <code>main()</code>, but multiple <code>init()</code>s.</p>
</li>
</ol>
<blockquote>
<p>üß™ "Init is like the secret backstage crew. You don‚Äôt see them during the show, but they‚Äôre the reason the lights come on."</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-class-21--expressions-anonymous-functions--iife-in-go"><a class="header" href="#-class-21--expressions-anonymous-functions--iife-in-go">üìò Class 21 ‚Äì Expressions, Anonymous Functions &amp; IIFE in Go</a></h1>
<h3 id="-video-name"><a class="header" href="#-video-name">üé• Video Name:</a></h3>
<p><strong>Anonymous function, Expression &amp; IIFE</strong></p>
<hr />
<h2 id="-code-written-in-this-class-2"><a class="header" href="#-code-written-in-this-class-2">üì¶ Code Written in This Class</a></h2>
<pre><code class="language-go">// Anonymous function
// IIFE - Immediately Invoked Function Expression

package main

import "fmt"

func main() {
	// Anonymous function
	func(a int, b int) {
		c := a + b
		fmt.Println(c)
	}(5, 7) // IIFE
}

func init() {
	fmt.Println("I'll be called first")
}
</code></pre>
<h2 id="-key-concepts-3"><a class="header" href="#-key-concepts-3">üß† Key Concepts</a></h2>
<h3 id="-expression-in-go"><a class="header" href="#-expression-in-go">üßÆ Expression in Go</a></h3>
<blockquote>
<p>An expression is any snippet of code that evaluates to a value.</p>
</blockquote>
<p><strong>Examples:</strong></p>
<pre><code class="language-go">a + b          // is an expression
func(x, y){}   // is a function expression
</code></pre>
<p>Expressions can be used as values, passed around, or even executed immediately ‚Äî which leads us to‚Ä¶</p>
<h3 id="-anonymous-function"><a class="header" href="#-anonymous-function"><strong>üßô Anonymous Function</strong></a></h3>
<p>An <strong>anonymous function</strong> is a function <strong>without a name.</strong></p>
<p>Instead of:</p>
<pre><code class="language-go">func add(a, b int) int {
	return a + b
}
</code></pre>
<p>You write:</p>
<pre><code class="language-go">func(a, b int) int {
	return a + b
}
</code></pre>
<p>‚úÖ You can assign it to a variable, pass it as an argument, or invoke it on the spot.</p>
<h3 id="-iife-immediately-invoked-function-expression"><a class="header" href="#-iife-immediately-invoked-function-expression">‚ö° IIFE (Immediately Invoked Function Expression)</a></h3>
<blockquote>
<p>An <strong>IIFE</strong> is an anonymous function that is <strong>executed immediately</strong> right after it's defined.</p>
</blockquote>
<p>Syntax:</p>
<pre><code class="language-go">func(a int, b int) {
	// do stuff
}(5, 7)
</code></pre>
<p><strong>Use-case</strong>: You want to run a small block of logic <strong>immediately, without polluting the namespace</strong> with a new function name.</p>
<h2 id="-cli-style-execution-visualization"><a class="header" href="#-cli-style-execution-visualization">üñ•Ô∏è CLI-style Execution Visualization</a></h2>
<pre><code>=========== Compilation Phase =============
Found init() ‚úÖ
Found main() ‚úÖ

=========== Execution Phase ===============

üîÅ init() runs first
‚Üí Prints: I'll be called first

üß† Data Segment:
(No global vars in this case)

üìö Stack Frame:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    main()           ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ  anonymous func ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

main() calls an IIFE:
‚Üí Passes 5 and 7
‚Üí Inside IIFE: c := 5 + 7 = 12
‚Üí Prints: 12

=========== Execution Complete =============
</code></pre>
<h2 id="-tldr"><a class="header" href="#-tldr">üßµ TL;DR</a></h2>
<p>-[] ‚úÖ Expressions return values and can be assigned or executed.</p>
<p>-[] üß™ Anonymous functions have no name, great for quick logic blocks.</p>
<p>-[] üöÄ IIFE: Define &amp; execute in one go. Great for one-off logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-class-22--function-expressions--shadowing-in-go"><a class="header" href="#-class-22--function-expressions--shadowing-in-go">üìò Class 22 ‚Äì Function Expressions &amp; Shadowing in Go</a></h1>
<h3 id="-video-name-1"><a class="header" href="#-video-name-1">üé• Video Name:</a></h3>
<p><strong>Function Expression Example</strong></p>
<hr />
<h2 id="-code-1-working-example"><a class="header" href="#-code-1-working-example">‚úÖ Code 1: Working Example</a></h2>
<pre><code class="language-go">package main

import "fmt"

// Global function expression
var add = func(x, y int) {
	fmt.Println(x + y)
}

func main() {
	add(4, 7) // Calls the global `add`

	// Function expression assigned to local variable
	add := func(a int, b int) {
		c := a + b
		fmt.Println(c)
	}

	add(2, 3) // Calls the local `add`
}

func init() {
	fmt.Println("I will be called first")
}
</code></pre>
<h2 id="-key-concepts-4"><a class="header" href="#-key-concepts-4">üß† Key Concepts</a></h2>
<h3 id="-function-expression"><a class="header" href="#-function-expression">üîß Function Expression</a></h3>
<p>A function <strong>assigned to a variable</strong>. It allows us to:</p>
<p>-[] Store logic in a variable</p>
<p>-[] Treat functions like first-class citizens</p>
<p>-[] Create inline, nameless (anonymous) functions</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">add := func(a int, b int) {
	fmt.Println(a + b)
}
</code></pre>
<h3 id="-shadowing"><a class="header" href="#-shadowing">üß± Shadowing</a></h3>
<p>When a variable in a <strong>smaller (local) scope</strong> has the <strong>same name</strong> as one in a <strong>larger (outer) scope</strong>, it "shadows" or hides it temporarily.</p>
<p>In the <code>main()</code> function:</p>
<pre><code class="language-go">add := func(a int, b int) {...}
</code></pre>
<p>This local <code>add</code> shadows the global <code>add</code> from that point onward.</p>
<h2 id="-execution-visualization-working-example"><a class="header" href="#-execution-visualization-working-example">üñ•Ô∏è Execution Visualization (Working Example)</a></h2>
<pre><code>========== Compilation Phase ==========
‚úî Found init()
‚úî Found main()
‚úî Global `add` assigned to function

========== Execution Begins ===========

init():
‚Üí Prints: I will be called first

main():
‚Üí Calls global `add(4, 7)` ‚Üí Prints: 11

Local Scope in main():
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Stack Frame ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ main()                     ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ ‚îÇ add (local)  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
       (shadows global) ‚óÑ‚îÄ‚îÄ‚îÄ‚îò

‚Üí Calls local `add(2, 3)` ‚Üí Prints: 5

========== Execution Ends ==========
</code></pre>
<h2 id="-code-2-fails-to-compile"><a class="header" href="#-code-2-fails-to-compile">‚ùå Code 2: Fails to Compile</a></h2>
<pre><code class="language-go">package main

import "fmt"

// Global function expression
var add = func(x, y int) {
	fmt.Println(x + y)
}

func main() {
	adder(4, 7) // ‚ùå ERROR: undefined: adder

	// Function expression or Assign function in variable
	adder := func(a int, b int) {
		c := a + b
		fmt.Println(c)
	}

	add(2, 3)
}

func init() {
	fmt.Println("I will be called first")
}
</code></pre>
<h3 id="-why-it-fails"><a class="header" href="#-why-it-fails">‚ùå Why it fails</a></h3>
<p>This line:</p>
<pre><code class="language-go">adder(4, 7)
</code></pre>
<p>is <strong>above</strong> the declaration:</p>
<pre><code class="language-go">adder := func(a int, b int) { ... }
</code></pre>
<h3 id="-the-problem-temporal-dead-zone"><a class="header" href="#-the-problem-temporal-dead-zone">‚õî The Problem: Temporal Dead Zone</a></h3>
<p>In Go, <strong>you can't use a variable before it's declared</strong>, even if it‚Äôs in the same block.</p>
<p>So, when you try to use <code>adder</code>, it hasn‚Äôt been declared yet. Hence:</p>
<pre><code class="language-bash">./main.go:10:2: undefined: adder
</code></pre>
<h2 id="-tldr-1"><a class="header" href="#-tldr-1">üìö TL;DR</a></h2>
<p>Concept | Meaning
Function Expression | A function assigned to a variable
Anonymous Function | A function with no name
Shadowing | Local variable hides the same-named global one
Temporal Dead Zone | You can't use variables before their declaration in Go
IIFE vs Assignment | IIFE executes immediately; assignment waits to be called explicitly</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-23-functional-programming-concepts-in-go"><a class="header" href="#class-23-functional-programming-concepts-in-go">Class 23: Functional Programming Concepts in Go</a></h1>
<h2 id="code-example"><a class="header" href="#code-example">Code Example</a></h2>
<pre><code class="language-go">package main

import "fmt"

func add(a int, b int) { // Parameter: a and b
	c := a + b
	fmt.Println(c)
}

func main() {
	add(2, 5) // 2 and 5 are arguments
	processOperation(4, 5, add)
	sum := call() // function expression
	sum(4, 7)
}

func processOperation(a int, b int, op func(p int, q int)) { // Higher order function
	op(a, b)
}

func call() func(x int, y int) {
	return add
}
</code></pre>
<hr />
<h2 id="-key-concepts-5"><a class="header" href="#-key-concepts-5">üß† Key Concepts</a></h2>
<h3 id="1-parameter-vs-argument"><a class="header" href="#1-parameter-vs-argument">1. <strong>Parameter vs Argument</strong></a></h3>
<ul>
<li><strong>Parameter</strong>: The variable listed inside the function definition. (e.g., <code>a int, b int</code> in <code>add(a, b)</code>)</li>
<li><strong>Argument</strong>: The actual value passed to the function when it's called. (e.g., <code>add(2, 5)</code>)</li>
</ul>
<h3 id="2-first-order-function"><a class="header" href="#2-first-order-function">2. <strong>First Order Function</strong></a></h3>
<p>A regular function that does not take another function as input or return one.</p>
<ul>
<li>Examples:
<ul>
<li>Named function: <code>func add(a, b int)</code></li>
<li>Anonymous function: <code>func(a int, b int) { ... }</code></li>
<li>IIFE (Immediately Invoked Function Expression): <code>func(a, b int) { ... }(5, 7)</code></li>
<li>Function expression: <code>sum := func(a, b int) { ... }</code></li>
</ul>
</li>
</ul>
<h3 id="3-higher-order-function"><a class="header" href="#3-higher-order-function">3. <strong>Higher Order Function</strong></a></h3>
<p>A function that <strong>takes a function as a parameter</strong>, <strong>returns a function</strong>, or <strong>both</strong>.</p>
<ul>
<li>Example:
<ul>
<li><code>processOperation</code> takes a function <code>op</code> as a parameter</li>
<li><code>call()</code> returns a function <code>add</code></li>
</ul>
</li>
</ul>
<h3 id="4-callback-function"><a class="header" href="#4-callback-function">4. <strong>Callback Function</strong></a></h3>
<ul>
<li>A function that is passed into another function to be executed later.</li>
<li>In <code>processOperation(4, 5, add)</code>, the function <code>add</code> is a callback.</li>
</ul>
<h3 id="5-first-class-citizen-function"><a class="header" href="#5-first-class-citizen-function">5. <strong>First-Class Citizen (Function)</strong></a></h3>
<ul>
<li>In Go, functions can be assigned to variables, passed as arguments, and returned from other functions.</li>
<li>This makes them <em>first-class citizens</em>.</li>
</ul>
<hr />
<h2 id="-conceptual-context-functional-paradigm"><a class="header" href="#-conceptual-context-functional-paradigm">üß† Conceptual Context (Functional Paradigm)</a></h2>
<blockquote>
<p>Functional programming treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.</p>
</blockquote>
<h3 id="inspiration-from-mathematics"><a class="header" href="#inspiration-from-mathematics">Inspiration from Mathematics</a></h3>
<ul>
<li><strong>First Order Logic</strong>: Objects with properties (e.g., <code>Person</code>, <code>Car</code>, etc.)</li>
<li><strong>Higher Order Logic</strong>: Functions and their relation with other functions (like in Go's higher-order functions)</li>
</ul>
<p>Languages like <strong>Haskell</strong>, <strong>Racket</strong>, etc., are built on deep functional paradigms.</p>
<p>Go borrows <strong>some</strong> of these concepts, but it is still <strong>imperative and procedural</strong> by nature.</p>
<hr />
<h2 id="-cli-visualization-call-stack--segments"><a class="header" href="#-cli-visualization-call-stack--segments">üìü CLI Visualization (Call Stack + Segments)</a></h2>
<h3 id="1-data-segment"><a class="header" href="#1-data-segment">1. <strong>Data Segment</strong></a></h3>
<ul>
<li><code>add</code> (global function definition)</li>
<li><code>call</code> (returns a function)</li>
<li><code>processOperation</code> (stored function)</li>
</ul>
<h3 id="2-code-execution-flow-stack-frames"><a class="header" href="#2-code-execution-flow-stack-frames">2. <strong>Code Execution Flow (Stack Frames)</strong></a></h3>
<pre><code class="language-shell">Call Stack:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ main()                   ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ add(2, 5)            ‚îÇ =&gt; prints 7
‚îÇ ‚îú‚îÄ‚îÄ processOperation     ‚îÇ
‚îÇ ‚îÇ   ‚îî‚îÄ‚îÄ op(4, 5) =&gt; add  ‚îÇ =&gt; prints 9
‚îÇ ‚îú‚îÄ‚îÄ call()               ‚îÇ =&gt; returns add
‚îÇ ‚îî‚îÄ‚îÄ sum(4, 7)            ‚îÇ =&gt; prints 11
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p>Everything runs in the order written, but since functions are first-class, Go can pass and return them like variables.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>üå± Go supports functional programming <strong>concepts</strong> like first-class and higher-order functions.</li>
<li>üí° You can pass around functions like variables ‚Äî extremely powerful for modular and clean code.</li>
<li>üß† Understanding <strong>first order vs higher order functions</strong>, <strong>parameters vs arguments</strong>, and <strong>callback functions</strong> gives you a major edge in writing elegant Go code.</li>
</ul>
<hr />
<p>‚úÖ This was a big brain class. You crushed it!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-24--go-internal-memory-code-data-stack-heap"><a class="header" href="#class-24--go-internal-memory-code-data-stack-heap">Class 24 ‚Äî Go Internal Memory (Code, Data, Stack, Heap)</a></h1>
<h3 id="-topics-covered"><a class="header" href="#-topics-covered">üß† Topics Covered</a></h3>
<p>This class dives deep into how Go programs are structured in memory. Concepts explained include:</p>
<ul>
<li><strong>Code Segment</strong>: Stores compiled instructions (functions).</li>
<li><strong>Data Segment</strong>: Stores global/static variables (like <code>var a = 10</code>).</li>
<li><strong>Stack</strong>: Stores local function variables. Each function call creates a new <em>stack frame</em>.</li>
<li><strong>Heap</strong>: Used for dynamically allocated memory (we'll explore this more later).</li>
<li><strong>Garbage Collector</strong>: Runs on the heap. Cleans up memory that's no longer in use.</li>
</ul>
<hr />
<h3 id="-code-from-class-24"><a class="header" href="#-code-from-class-24">üìú Code from Class 24</a></h3>
<pre><code class="language-go">package main

import "fmt"

var a = 10

func add(x, y int) {
	z := x + y
	fmt.Println(z)
}

func main() {
	add(5,4)
	add(a,3)
}

func init() {
	fmt.Println("Hello")
}
</code></pre>
<h2 id="-code-execution-flow--memory-layout"><a class="header" href="#-code-execution-flow--memory-layout">üîç Code Execution Flow &amp; Memory Layout</a></h2>
<pre><code class="language-pgsql">           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ               Code Segment                 ‚îÇ
           ‚îÇ--------------------------------------------‚îÇ
           ‚îÇ Functions: init, main, add                 ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ              Data Segment                  ‚îÇ
           ‚îÇ--------------------------------------------‚îÇ
           ‚îÇ Global Variable: a = 10                    ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ          Stack             ‚îÇ
              ‚îÇ----------------------------‚îÇ
              ‚îÇ main() Stack Frame         ‚îÇ
              ‚îÇ   - Calls add(5, 4)        ‚îÇ
              ‚îÇ       - x=5, y=4           ‚îÇ
              ‚îÇ       - z=9                ‚îÇ
              ‚îÇ   - Calls add(10, 3)       ‚îÇ
              ‚îÇ       - x=10, y=3          ‚îÇ
              ‚îÇ       - z=13               ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ               Heap (Unused here)           ‚îÇ
           ‚îÇ       (Managed by the Garbage Collector)   ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="-execution-order"><a class="header" href="#-execution-order">‚öôÔ∏è Execution Order</a></h2>
<ol>
<li><code>init()</code> is run automatically before <code>main()</code> ‚Üí prints:</li>
</ol>
<pre><code class="language-nginx">Hello
</code></pre>
<ol start="2">
<li><code>main()</code> runs and calls:
-[] <code>add(5, 4)</code> ‚Üí prints:
<pre><code>9
</code></pre>
-[] <code>add(a, 3)</code> ‚Üí uses <code>a = 10</code> ‚Üí prints:
<pre><code>13
</code></pre>
</li>
</ol>
<h2 id="-key-concepts-recap"><a class="header" href="#-key-concepts-recap">üìå Key Concepts Recap</a></h2>
<p>Concept | Meaning
Code Segment | Where all functions live after compilation
Data Segment | Stores global variables
Stack | Temporary memory for function execution (local vars, params)
Heap | For dynamic memory (we didn't use heap explicitly here)
Garbage Collector | Automatically manages memory on the heap
init() Function | Special function in Go ‚Äî runs before main()</p>
<blockquote>
<p>üßº Garbage Collector Insight:
Go‚Äôs GC sits on the heap and sweeps unused allocations to keep memory clean. You won't notice it in this small program, but it's your bestie when your app scales.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-25---internal-memory-deep-dive-compilation--execution-phases"><a class="header" href="#class-25---internal-memory-deep-dive-compilation--execution-phases">Class 25 - Internal Memory Deep Dive: Compilation &amp; Execution Phases</a></h1>
<hr />
<h2 id="-topics-covered-1"><a class="header" href="#-topics-covered-1">‚ú® Topics Covered</a></h2>
<p>This class focused on the internal workings of a Go program with a spotlight on what happens under the hood during:</p>
<ul>
<li><strong>Compilation Phase</strong></li>
<li><strong>Execution Phase</strong></li>
<li>How Go builds a binary with <code>go build</code></li>
<li>What gets stored in that binary (functions, constants, globals, etc.)</li>
<li>How function expressions (e.g., <code>add := func(...)</code>) are treated in memory</li>
</ul>
<hr />
<h2 id="-key-concepts-6"><a class="header" href="#-key-concepts-6">üëç Key Concepts</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Explanation</th></tr></thead><tbody>
<tr><td><strong>Compilation Phase</strong></td><td>Parses and compiles source code into a binary executable. No code runs yet.</td></tr>
<tr><td><strong>Execution Phase</strong></td><td>Runs the compiled binary, starting from <code>init()</code> and then <code>main()</code>.</td></tr>
<tr><td><strong>Code Segment</strong></td><td>Where compiled functions (<code>main</code>, <code>call</code>, anonymous <code>add</code>) and constants (<code>a</code>) are stored as part of executable instructions.</td></tr>
<tr><td><strong>Data Segment</strong></td><td>Holds global variables (like <code>p</code>).</td></tr>
<tr><td><strong>Function Expressions</strong></td><td>Treated as runtime function objects, stored in code segment.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="-code-used-in-class-25"><a class="header" href="#-code-used-in-class-25">üìã Code Used in Class 25</a></h2>
<pre><code class="language-go">package main

import "fmt"

const a = 10 // constant
var p = 100

func call() {
	add := func(x int, y int) {
		z := x + y
		fmt.Println(z)
	}

	add(5, 6)
	add(p, a)
}

func main() {
	call()
	fmt.Println(a)
}

func init() {
	fmt.Println("Hello")
}
</code></pre>
<hr />
<h2 id="-compilation-phase-visualized"><a class="header" href="#-compilation-phase-visualized">üîÑ Compilation Phase Visualized</a></h2>
<h3 id="go-build-maingo"><a class="header" href="#go-build-maingo"><code>go build main.go</code></a></h3>
<ul>
<li><strong>Parser/Compiler</strong> checks for syntax, scope, and dependencies.</li>
<li>Stores:
<ul>
<li>Constants: <code>a = 10</code></li>
<li>Globals: <code>p = 100</code></li>
<li>Functions: <code>init</code>, <code>main</code>, <code>call</code>, and the anonymous <code>add</code> function inside <code>call</code></li>
</ul>
</li>
<li>Generates a <strong>binary</strong> that includes all necessary machine code + metadata.</li>
</ul>
<p>Binary includes:</p>
<ul>
<li>Code Segment: <code>const a</code>, <code>main</code>, <code>call</code>, anonymous function</li>
<li>Data Segment: <code>var p</code></li>
<li>No execution happens here.</li>
</ul>
<hr />
<h2 id="-execution-phase-visualized"><a class="header" href="#-execution-phase-visualized">‚è± Execution Phase Visualized</a></h2>
<pre><code>   1. init()            =&gt; "Hello"
   2. main()            =&gt; calls call()
   3. call()            =&gt; declares and invokes add()
       - add(5, 6)      =&gt; 11
       - add(100, 10)   =&gt; 110
   4. fmt.Println(a)    =&gt; 10
</code></pre>
<hr />
<h2 id="-memory-layout"><a class="header" href="#-memory-layout">üß† Memory Layout</a></h2>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Code Segment          ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ const a = 10                |
| main, call, init, add-func  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Data Segment          ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ var p = 100                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Stack             ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ call() frame ‚Üí add func     ‚îÇ
‚îÇ   x=5,y=6,z=11              ‚îÇ
‚îÇ   x=100,y=10,z=110          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h2 id="-summary"><a class="header" href="#-summary">üîπ Summary</a></h2>
<ul>
<li>Go runs in <strong>two phases</strong>: Compilation and Execution.</li>
<li>During <strong>compilation</strong>, Go prepares memory layout, compiles functions and expressions.</li>
<li>In <strong>execution</strong>, it runs <code>init()</code> and then <code>main()</code>.</li>
<li><strong>Function expressions</strong> like <code>add := func(...)</code> are first-class values and live in the code segment.</li>
<li>The resulting binary from <code>go build</code> holds everything: code, data, metadata.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-26-closure--go-internal-memory-deep-dive-"><a class="header" href="#class-26-closure--go-internal-memory-deep-dive-">Class 26: Closure &amp; Go Internal Memory Deep Dive üí°</a></h1>
<p>Welcome to Class 26, where we uncover the magic behind closures in Go, escape analysis, and how memory is managed under the hood! üß†üî•</p>
<hr />
<h2 id="-the-code"><a class="header" href="#-the-code">üßæ The Code</a></h2>
<pre><code class="language-go">package main

import "fmt"

const a = 10
var p = 100

//Closure
func outer(money int) func() {
	age := 30
	fmt.Println("Age =", age)

	show := func() {
		money = money + a + p
		fmt.Println(money)
	}

	return show
}

func call() {
	incr1 := outer(100)
	incr1() // money = 100 + 10 + 100 = 210
	incr1() // money = 210 + 10 + 100 = 320

	incr2 := outer(100)
	incr2()
	incr2()
}

func main() {
	call()
}

func init() {
	fmt.Println("=== Bank ===")
}
</code></pre>
<hr />
<h2 id="-key-concepts-7"><a class="header" href="#-key-concepts-7">üîç Key Concepts</a></h2>
<h3 id="-what-is-a-closure"><a class="header" href="#-what-is-a-closure">üîí What is a Closure?</a></h3>
<p>A <strong>closure</strong> is a function that references variables from outside its own scope. In this case:</p>
<pre><code class="language-go">show := func() {
    money = money + a + p
    fmt.Println(money)
}
</code></pre>
<p><code>show</code> forms a closure by capturing the <code>money</code> variable defined in <code>outer()</code>.</p>
<h3 id="-why-is-closure-important"><a class="header" href="#-why-is-closure-important">üß† Why is Closure Important?</a></h3>
<p>Closures let you encapsulate logic along with state. This is why <code>incr1()</code> and <code>incr2()</code> maintain separate <code>money</code> values even though they use the same function.</p>
<h3 id="-stack-vs-heap"><a class="header" href="#-stack-vs-heap">üßÆ Stack vs Heap</a></h3>
<ul>
<li><strong>Stack</strong>: Fast memory, used for function calls and local variables.</li>
<li><strong>Heap</strong>: Used when variables need to persist beyond the function call (like in closures!).</li>
</ul>
<p>Because <code>money</code> needs to stick around <em>after</em> <code>outer()</code> returns, <strong>escape analysis</strong> detects this and allocates <code>money</code> on the heap.</p>
<h3 id="-what-is-escape-analysis"><a class="header" href="#-what-is-escape-analysis">üß™ What is Escape Analysis?</a></h3>
<p>Escape analysis is the process that the <strong>Go compiler</strong> uses during the <strong>compilation phase</strong> to determine whether variables can be safely allocated on the stack or must go to the heap.</p>
<ul>
<li>‚úÖ If a variable is used <em>only</em> inside a function, it's put on the <strong>stack</strong>.</li>
<li>üöÄ If a variable is used <em>outside</em> (like in a returned closure), it's moved to the <strong>heap</strong>.</li>
</ul>
<h3 id="-memory-segments"><a class="header" href="#-memory-segments">üß± Memory Segments</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>What's Stored</th></tr></thead><tbody>
<tr><td>Code Segment</td><td>Compiled instructions (functions)</td></tr>
<tr><td>Data Segment</td><td>Global and static variables (<code>a</code>, <code>p</code>)</td></tr>
<tr><td>Stack</td><td>Local variables (<code>age</code>)</td></tr>
<tr><td>Heap</td><td>Escaping variables (<code>money</code>)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="-visualization"><a class="header" href="#-visualization">üß† Visualization</a></h2>
<h3 id="cli-style-memory-layout"><a class="header" href="#cli-style-memory-layout">CLI-Style Memory Layout</a></h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Code Segment          ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ main, call, init, outer,    ‚îÇ
‚îÇ anonymous show function     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Data Segment          ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ const a = 10                ‚îÇ
‚îÇ var p = 100                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Stack             ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ outer() frame               ‚îÇ
‚îÇ   age = 30                  ‚îÇ
‚îÇ   return address            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Heap             ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ money = 100 (for incr1)     ‚îÇ
‚îÇ money = 100 (for incr2)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p>Each closure has its own <code>money</code> on the heap. Every call to <code>outer(100)</code> results in a new memory block being allocated.</p>
<h3 id="garbage-collectors-role-"><a class="header" href="#garbage-collectors-role-">Garbage Collector‚Äôs Role üßπ</a></h3>
<p>When the closure is no longer referenced (e.g., <code>incr1</code> or <code>incr2</code> goes out of scope), the <strong>Garbage Collector</strong> detects that the heap memory (e.g., <code>money</code>) is unreachable. It then safely reclaims that memory so your program doesn‚Äôt become a memory hoarder. This is vital for maintaining efficiency, especially when many closures are involved.</p>
<p>GC is triggered automatically and runs concurrently with your program. It uses a combination of <strong>mark-and-sweep</strong> and <strong>concurrent garbage collection techniques</strong> to do this efficiently.</p>
<hr />
<h2 id="-tldr-2"><a class="header" href="#-tldr-2">üß† TL;DR</a></h2>
<ul>
<li>Closures can capture and remember variable state üîÅ</li>
<li>Escape analysis figures out which variables must live on the heap üì¶</li>
<li>Stack is temporary, heap is persistent (with GC üßπ)</li>
<li>Go separates memory into Code, Data, Stack, Heap ‚Äî each with its role üß©</li>
<li>GC ensures unused heap memory (like old closure data) is recycled ‚ôªÔ∏è</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-27-structs--memory-layout-in-go-"><a class="header" href="#class-27-structs--memory-layout-in-go-">Class 27: Structs &amp; Memory Layout in Go üß±</a></h1>
<p>Welcome to Class 27! Today we're diving into <strong>structs</strong>, how to define and instantiate them, and how they interact with Go's memory model. Let's visualize everything from scratch like pros. üß†üí°</p>
<hr />
<h2 id="-the-code-1"><a class="header" href="#-the-code-1">‚úçÔ∏è The Code</a></h2>
<pre><code class="language-go">package main

import "fmt"

type User struct {
	Name string
	Age  int
}

func (usr User) printDetails() {
	fmt.Println("Name:", usr.Name)
	fmt.Println("Age:", usr.Age)
}

func main() {
	user1 := User{
		Name: "Ruhin",
		Age:  21,
	}

	user2 := User{
		Name: "Mukim",
		Age:  15,
	}

	user1.printDetails()
	user2.printDetails()
}
</code></pre>
<hr />
<h2 id="-key-concepts-8"><a class="header" href="#-key-concepts-8">üß† Key Concepts</a></h2>
<h3 id="-what-is-a-struct"><a class="header" href="#-what-is-a-struct">üß© What is a Struct?</a></h3>
<p>A <strong>struct</strong> is a user-defined type in Go used to group related data together. It‚Äôs like a custom container for fields.</p>
<pre><code class="language-go">type User struct {
	Name string
	Age  int
}
</code></pre>
<p>This defines a new type called <code>User</code> with fields <code>Name</code> and <code>Age</code>.</p>
<hr />
<h3 id="-creating-instances-instantiation"><a class="header" href="#-creating-instances-instantiation">üî® Creating Instances (Instantiation)</a></h3>
<p>When we create an actual value using a struct type, that‚Äôs called <strong>instantiating</strong>.</p>
<pre><code class="language-go">user1 := User{
	Name: "Ruhin",
	Age:  21,
}
</code></pre>
<p>Here <code>user1</code> is an <strong>instance</strong> of <code>User</code>. This allocates memory to hold <code>Name</code> and <code>Age</code> values.</p>
<hr />
<h2 id="-memory-layout-visualization"><a class="header" href="#-memory-layout-visualization">üß† Memory Layout (Visualization)</a></h2>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Code Segment          ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ main, printDetails,         ‚îÇ
‚îÇ type User struct {...}      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Data Segment          ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ -                           ‚îÇ
‚îÇ (Global vars if present)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Stack             ‚îÇ
‚îÇ-----------------------------‚îÇ
‚îÇ main() frame ‚Üí              ‚îÇ
‚îÇ   user1 ‚Üí Name: "Ruhin"     ‚îÇ
‚îÇ           Age: 21           ‚îÇ
‚îÇ   user2 ‚Üí Name: "Mukim"     ‚îÇ
‚îÇ           Age: 15           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<blockquote>
<p>‚ö†Ô∏è NOTE: If a struct is returned from a function or captured by a closure, it may escape to the heap instead of stack.</p>
</blockquote>
<hr />
<h2 id="-example-use-case"><a class="header" href="#-example-use-case">üìã Example Use Case</a></h2>
<pre><code class="language-go">type Book struct {
	Title  string
	Author string
	Pages  int
}

book1 := Book{
	Title: "1984",
	Author: "George Orwell",
	Pages: 328,
}
</code></pre>
<p>This lets us build real-world models with multiple fields.</p>
<hr />
<h2 id="-role-of-the-garbage-collector-gc"><a class="header" href="#-role-of-the-garbage-collector-gc">üßπ Role of the Garbage Collector (GC)</a></h2>
<ul>
<li>If a struct instance <strong>escapes</strong> (used outside the function, stored long-term, etc.), Go stores it on the <strong>heap</strong>.</li>
<li>Go‚Äôs <strong>garbage collector</strong> then tracks and cleans it when it‚Äôs no longer in use.</li>
<li>This means you don‚Äôt have to manually <code>free()</code> anything ‚Äî Go handles memory cleanup for heap objects.</li>
</ul>
<hr />
<h2 id="-tldr-3"><a class="header" href="#-tldr-3">üöÄ TL;DR</a></h2>
<ul>
<li><code>type User struct {...}</code> is metadata ‚Üí stored in the <strong>Code Segment</strong>.</li>
<li><code>user1 := User{...}</code> is runtime data ‚Üí stored in <strong>Stack</strong> or <strong>Heap</strong> depending on usage.</li>
<li>Structs bundle fields into one logical unit ‚úÖ</li>
<li>Memory layout varies depending on usage ‚Üí escape analysis decides üì¶üß≥</li>
<li>GC only manages objects in the <strong>heap</strong>, not on the <strong>stack</strong> üßπ</li>
</ul>
<hr />
<h3 id="q-is-struct-a-datatype"><a class="header" href="#q-is-struct-a-datatype">Q: Is struct a datatype?</a></h3>
<p><strong>Ans:</strong>
Yes, 100% ‚Äî a struct in Go is a user-defined data type. Think of it like creating your own custom "blueprint" for a data object. üí°</p>
<p><strong>Here's how it fits in:</strong></p>
<p>-[] Go has primitive data types like <code>int</code>, <code>string</code>, <code>bool</code>, <code>etc</code>.</p>
<p>-[] You can then use <code>struct</code> to define a custom data type that groups multiple fields together.</p>
<p>For example:</p>
<pre><code class="language-go">type User struct {
	Name string
	Age  int
}
</code></pre>
<p>This <code>User</code> struct becomes its own data type, and now you can create instances of it just like you would for <code>int</code> or <code>string</code>:</p>
<pre><code class="language-go">var u User
u.Name = "Ruhin"
u.Age = 21
</code></pre>
<p>It‚Äôs like building your own Lego brick with a custom shape, and then making as many copies of that brick as you want. üß±‚ú®</p>
<blockquote>
<p>You‚Äôre now struct-urally sound in Go! üòé Next time you model data, flex your type muscles and track those memory segments like a boss.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-28-receiver-functions-in-go"><a class="header" href="#class-28-receiver-functions-in-go">Class 28: Receiver Functions in Go</a></h1>
<h2 id="-key-concept-receiver-functions"><a class="header" href="#-key-concept-receiver-functions">üîë Key Concept: Receiver Functions</a></h2>
<p>In Go, a <strong>receiver function</strong> (also called a <strong>method</strong>) is a function that is associated with a particular <strong>type</strong> (usually a struct). It allows us to add behavior to data types, like attaching functions to objects in other languages (e.g., methods in OOP).</p>
<hr />
<h2 id="-what-is-a-receiver-function"><a class="header" href="#-what-is-a-receiver-function">üß† What Is a Receiver Function?</a></h2>
<p>A <strong>receiver function</strong> is defined like a normal function, but with a special receiver parameter placed between the <code>func</code> keyword and the function name.</p>
<pre><code class="language-go">func (r ReceiverType) FunctionName(params) returnType {
    // function body
}
</code></pre>
<p>The receiver type can be:</p>
<ul>
<li>A <strong>value receiver</strong>: <code>(t Type)</code> ‚Üí receives a copy</li>
<li>A <strong>pointer receiver</strong>: <code>(t *Type)</code> ‚Üí receives a reference (can modify original)</li>
</ul>
<hr />
<h2 id="-from-the-project-code"><a class="header" href="#-from-the-project-code">üèóÔ∏è From the Project Code</a></h2>
<pre><code class="language-go">func (todos *Todos) add(title string) {
    todo := Todo{
        Title: title,
        Completed: false,
        CompletedAt: nil,
        CreatedAt: time.Now(),
    }
    *todos = append(*todos, todo)
}
</code></pre>
<ul>
<li><code>todos *Todos</code> is the <strong>receiver</strong></li>
<li>This method is attached to <code>Todos</code> (which is a custom type: <code>[]Todo</code>)</li>
<li>The <code>*Todos</code> pointer allows modifications to the original slice</li>
</ul>
<p>Example usage from <code>main.go</code>:</p>
<pre><code class="language-go">todos.add("Buy milk")
</code></pre>
<hr />
<h2 id="-why-use-receiver-functions"><a class="header" href="#-why-use-receiver-functions">üîÅ Why Use Receiver Functions?</a></h2>
<ul>
<li>Organize logic with the data it operates on ‚úÖ</li>
<li>Achieve OOP-like behavior in Go ‚úÖ</li>
<li>Maintain cleaner and modular code ‚úÖ</li>
</ul>
<hr />
<h2 id="-extra-simple-example"><a class="header" href="#-extra-simple-example">üí° Extra Simple Example</a></h2>
<pre><code class="language-go">type User struct {
    Name string
}

// Value receiver (no change to original)
func (u User) SayHi() {
    fmt.Println("Hi, I am", u.Name)
}

// Pointer receiver (can change original)
func (u *User) ChangeName(newName string) {
    u.Name = newName
}

func main() {
    user := User{Name: "Ruhin"}
    user.SayHi() // Hi, I am Ruhin
    user.ChangeName("Mukim")
    user.SayHi() // Hi, I am Mukim
}
</code></pre>
<hr />
<h2 id="-summary-1"><a class="header" href="#-summary-1">‚öôÔ∏è Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Receiver</td><td>The type a method is attached to (e.g., <code>*Todos</code>)</td></tr>
<tr><td>Value Receiver</td><td>Gets a copy of the value; doesn't affect the original</td></tr>
<tr><td>Pointer Receiver</td><td>Gets a reference; can modify the original</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="-visualizing-it"><a class="header" href="#-visualizing-it">üìò Visualizing It</a></h2>
<p>Think of <code>todos.add()</code> as calling a behavior of the object:</p>
<pre><code class="language-go">object.method()
</code></pre>
<p>This pattern lets <code>Todos</code> have its own custom logic, like <code>add</code>, <code>delete</code>, <code>toggle</code>, <code>print</code>, etc., just like class methods in Python/Java.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-29---go-arrays-and-memory-layout"><a class="header" href="#class-29---go-arrays-and-memory-layout">Class 29 - Go Arrays and Memory Layout</a></h1>
<p>üìÖ <em>Date: April 24, 2025</em></p>
<h2 id="-key-concepts-9"><a class="header" href="#-key-concepts-9">üîë Key Concepts</a></h2>
<h3 id="-what-is-an-array"><a class="header" href="#-what-is-an-array">‚úÖ What is an Array?</a></h3>
<ul>
<li>An <strong>array</strong> is a fixed-size collection of elements of the same type.</li>
<li>In Go, arrays are <strong>value types</strong>, meaning they are copied when passed around.</li>
</ul>
<h3 id="-array-in-go"><a class="header" href="#-array-in-go">üß† Array in Go</a></h3>
<pre><code class="language-go">var arr [2]int       // Declares an array of 2 integers. Default values: [0, 0]
arr[0] = 3           // Assigning values using index
arr[1] = 6

// Short way of declaring an array with values
arr := [2]int{3, 6}
</code></pre>
<h3 id="-indexing"><a class="header" href="#-indexing">üí° Indexing</a></h3>
<ul>
<li>Arrays in Go are <strong>zero-indexed</strong>, meaning the first element is accessed with <code>array[0]</code>.</li>
</ul>
<h3 id="-default-values"><a class="header" href="#-default-values">‚öôÔ∏è Default Values</a></h3>
<ul>
<li>If you declare an array without initializing it, Go assigns default values:
<ul>
<li>For <code>int</code>, <code>float</code>, etc: <code>0</code></li>
<li>For <code>string</code>: <code>""</code> (empty string)</li>
<li>For <code>bool</code>: <code>false</code></li>
<li>For pointers/interfaces: <code>nil</code></li>
</ul>
</li>
</ul>
<h3 id="-memory-layout-visualization-1"><a class="header" href="#-memory-layout-visualization-1">üîç Memory Layout Visualization</a></h3>
<p>Example:</p>
<pre><code class="language-go">arr := [2]int{3, 6}
</code></pre>
<p><strong>Memory Layout</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Value</th><th>Meaning</th></tr></thead><tbody>
<tr><td>0x1000</td><td>3</td><td>arr[0]</td></tr>
<tr><td>0x1004</td><td>6</td><td>arr[1]</td></tr>
</tbody></table>
</div>
<p>Note: The actual address is abstract. The concept is: array elements are stored <strong>contiguously</strong> in memory.</p>
<p>Another example:</p>
<pre><code class="language-go">arr2 := [3]string{"I", "love", "you"}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>Value</th></tr></thead><tbody>
<tr><td>0</td><td>"I"</td></tr>
<tr><td>1</td><td>"love"</td></tr>
<tr><td>2</td><td>"you"</td></tr>
</tbody></table>
</div>
<p>Accessing <code>arr2[1]</code> returns <code>"love"</code>.</p>
<hr />
<h2 id="-full-code-example-from-class"><a class="header" href="#-full-code-example-from-class">üß™ Full Code Example (From Class)</a></h2>
<pre><code class="language-go">package main

import "fmt"

var arr2 = [3]string{"I", "love", "you"}

func main() {
    arr := [2]int{3,6}
    fmt.Println(arr)
    fmt.Println(arr2)
    fmt.Println(arr2[1])
}
</code></pre>
<hr />
<h2 id="-summary-2"><a class="header" href="#-summary-2">üì¶ Summary</a></h2>
<ul>
<li>Arrays are great for working with fixed-size collections.</li>
<li>Be aware of default values.</li>
<li>They're stored contiguously in memory.</li>
<li>Go makes it easy to work with arrays, and it's a good base before moving to slices!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-cpu-structure-and-stack-frame-execution-notes"><a class="header" href="#-cpu-structure-and-stack-frame-execution-notes">üß† CPU Structure and Stack Frame Execution Notes</a></h1>
<h2 id="-cpu-two-core-components"><a class="header" href="#-cpu-two-core-components">üîπ CPU: Two Core Components</a></h2>
<ol>
<li>
<p><strong>Processing Unit</strong></p>
<ul>
<li><strong>Arithmetic Logic Unit (ALU)</strong>: Performs all arithmetic and logical operations.</li>
<li><strong>Control Unit (CU)</strong>: Directs operations within the CPU; controls input/output and instruction decoding.</li>
</ul>
</li>
<li>
<p><strong>Register Set</strong></p>
<ul>
<li><strong>Program Counter (PC)</strong>: Holds the address of the next instruction to be executed.</li>
<li><strong>Stack Pointer (SP)</strong>: Points to the top of the current stack in memory.</li>
<li><strong>Base Pointer (BP)</strong>: Points to the base of the current function stack frame.</li>
<li><strong>Instruction Register (IR)</strong>: Holds the currently executing instruction.</li>
<li><strong>General Purpose Registers</strong>: For temporary data manipulation.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="-bits-and-bytes"><a class="header" href="#-bits-and-bytes">üîπ Bits and Bytes</a></h2>
<ul>
<li><strong>8-bit = 1 byte</strong></li>
<li><strong>32-bit = 4 bytes</strong></li>
<li><strong>64-bit = 8 bytes</strong></li>
</ul>
<p>Memory addressing = ( 2^n )</p>
<hr />
<h2 id="-ram-addressing-on-32-bit-system"><a class="header" href="#-ram-addressing-on-32-bit-system">üîπ RAM Addressing on 32-bit System</a></h2>
<p>Memory cells increase by 4 bytes (since 32-bit = 4 bytes):</p>
<pre><code>Address:  0   4   8  12  16  20  24  ...
         [ ] [ ] [ ] [ ] [ ] [ ] [ ]
</code></pre>
<hr />
<h2 id="-os-ram-and-process-execution"><a class="header" href="#-os-ram-and-process-execution">üîπ OS, RAM, and Process Execution</a></h2>
<ol>
<li><strong>OS pulls executable code</strong> from HDD ‚Üí loads into <strong>RAM</strong></li>
<li><strong>OS creates a process</strong></li>
<li><strong>RAM segments the process memory into:</strong>
<ul>
<li>Code Segment (for constants and instructions)</li>
<li>Data Segment (for global/static variables)</li>
<li>Stack (for function calls and local variables)</li>
<li>Heap (for dynamically allocated memory)</li>
</ul>
</li>
</ol>
<hr />
<h2 id="-stack-frame-in-function-call"><a class="header" href="#-stack-frame-in-function-call">üîπ Stack Frame in Function Call</a></h2>
<ul>
<li>The OS sets up <strong>SP</strong> and <strong>BP</strong>.</li>
<li><strong>SP &lt; BP</strong> (SP points lower in memory).</li>
</ul>
<h3 id="stack-frame-layout"><a class="header" href="#stack-frame-layout">Stack Frame Layout:</a></h3>
<pre><code>[ Local Variables        ]   &lt;-- SP (grows downward)
[ Old Base Pointer       ]
[ Return Address         ]
[ Parameters (right‚Üíleft)]   &lt;-- BP
</code></pre>
<ul>
<li><strong>Return Address</strong> is typically at <code>BP + 4</code>, <code>+8</code>, <code>+16</code>, etc.</li>
<li>Using <strong>BP</strong>, the CPU can easily access:
<ul>
<li>Function parameters</li>
<li>Return address</li>
<li>Local variables</li>
</ul>
</li>
</ul>
<hr />
<h2 id="-stack-frame-exit"><a class="header" href="#-stack-frame-exit">üîπ Stack Frame Exit</a></h2>
<ul>
<li>Stack frame pops:
<ul>
<li>Local variables</li>
<li>Old BP is restored</li>
<li>SP is reset</li>
<li>Execution jumps to Return Address</li>
</ul>
</li>
</ul>
<h3 id="final-condition"><a class="header" href="#final-condition">Final Condition:</a></h3>
<pre><code>BP == SP  =&gt; Stack Frame Closed
</code></pre>
<hr />
<h2 id="-diagram-stack-frame-example-32-bit"><a class="header" href="#-diagram-stack-frame-example-32-bit">üß≠ Diagram: Stack Frame Example (32-bit)</a></h2>
<pre><code class="language-plaintext">Memory Address ‚Üì

+----------------------+  &lt;- BP
| Parameter 1          |
+----------------------+
| Parameter 2          |
+----------------------+
| Return Address       | &lt;- BP + 4
+----------------------+
| Old Base Pointer     | &lt;- BP + 8
+----------------------+
| Local Variable A     | &lt;- SP
+----------------------+

Stack grows downward ‚Üì
</code></pre>
<hr />
<h2 id="-summary-3"><a class="header" href="#-summary-3">‚úÖ Summary</a></h2>
<ul>
<li>CPU is divided into <strong>Processing Unit</strong> and <strong>Register Set</strong></li>
<li>The <strong>Stack Frame</strong> is key to function call handling</li>
<li><strong>Base Pointer (BP)</strong> acts as a fixed reference point</li>
<li><strong>Stack Pointer (SP)</strong> moves during function execution</li>
<li><strong>Returning</strong> from a function resets <strong>BP</strong> and <strong>SP</strong></li>
</ul>
<hr />
<blockquote>
<p>Understanding stack frames is essential for debugging, compiler design, and low-level programming.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="topic-wise"><a class="header" href="#topic-wise">Topic wise</a></h2>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/arrays
<strong>Tags:</strong> [go, arrays, functions]
]</p>
<h1 id="arrays-in-go"><a class="header" href="#arrays-in-go">Arrays in Go</a></h1>
<h2 id="declaring-arrays"><a class="header" href="#declaring-arrays">Declaring Arrays</a></h2>
<p>You can declare an array in Go using the following syntax:</p>
<pre><code class="language-go">var arrayName [size]elementType
</code></pre>
<p>Example:</p>
<pre><code class="language-go">var numbers [5]int
</code></pre>
<h2 id="initializing-arrays"><a class="header" href="#initializing-arrays">Initializing Arrays</a></h2>
<p>Arrays can be initialized at the time of declaration:</p>
<pre><code class="language-go">var numbers = [5]int{1, 2, 3, 4, 5}
</code></pre>
<p>Or you can use the shorthand notation:</p>
<pre><code class="language-go">numbers := [5]int{1, 2, 3, 4, 5}
</code></pre>
<h2 id="accessing-array-elements"><a class="header" href="#accessing-array-elements">Accessing Array Elements</a></h2>
<p>Array elements are accessed using the index, which starts from 0:</p>
<pre><code class="language-go">fmt.Println(numbers[0]) // Output: 1
</code></pre>
<h2 id="iterating-over-arrays"><a class="header" href="#iterating-over-arrays">Iterating Over Arrays</a></h2>
<p>You can iterate over arrays using a <code>for</code> loop:</p>
<pre><code class="language-go">for i := 0; i &lt; len(numbers); i++ {
    fmt.Println(numbers[i])
}
</code></pre>
<p>Or using the <code>range</code> keyword:</p>
<pre><code class="language-go">for index, value := range numbers {
    fmt.Println(index, value)
}
</code></pre>
<h2 id="multidimensional-arrays"><a class="header" href="#multidimensional-arrays">Multidimensional Arrays</a></h2>
<p>Go supports multidimensional arrays. A two-dimensional array is declared as follows:</p>
<pre><code class="language-go">var matrix [3][3]int
</code></pre>
<p>Example:</p>
<pre><code class="language-go">matrix := [3][3]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
</code></pre>
<h2 id="array-of-arrays"><a class="header" href="#array-of-arrays">Array of Arrays</a></h2>
<p>You can also create an array of arrays:</p>
<pre><code class="language-go">var arrayOfArrays [2][3]int
</code></pre>
<p>Example:</p>
<pre><code class="language-go">arrayOfArrays := [2][3]int{
    {1, 2, 3},
    {4, 5, 6},
}
</code></pre>
<h2 id="passing-arrays-to-functions"><a class="header" href="#passing-arrays-to-functions">Passing Arrays to Functions</a></h2>
<p>Arrays can be passed to functions by value, meaning the function receives a copy of the array:</p>
<pre><code class="language-go">func printArray(arr [5]int) {
    for i := 0; i &lt; len(arr); i++ {
        fmt.Println(arr[i])
    }
}
</code></pre>
<p>To modify the original array, you can pass a pointer to the array:</p>
<pre><code class="language-go">func modifyArray(arr *[5]int) {
    arr[0] = 100
}
</code></pre>
<h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h2>
<h3 id="q1-how-can-i-find-the-length-of-an-array-in-go"><a class="header" href="#q1-how-can-i-find-the-length-of-an-array-in-go">Q1: How can I find the length of an array in Go?</a></h3>
<p>You can use the built-in <code>len()</code> function to find the length of an array.</p>
<p>Example:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    fmt.Println("Length of the array:", len(arr)) // Output: 5
}
</code></pre>
<h3 id="q2-how-do-i-copy-an-array-in-go"><a class="header" href="#q2-how-do-i-copy-an-array-in-go">Q2: How do I copy an array in Go?</a></h3>
<p>In Go, you can copy an array by simply assigning it to another array of the same type and size.</p>
<p>Example:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    original := [3]int{1, 2, 3}
    copy := original
    fmt.Println("Original:", original) // Output: [1 2 3]
    fmt.Println("Copy:", copy)         // Output: [1 2 3]
}
</code></pre>
<h3 id="q3-how-can-i-pass-an-array-to-a-function-without-copying-it"><a class="header" href="#q3-how-can-i-pass-an-array-to-a-function-without-copying-it">Q3: How can I pass an array to a function without copying it?</a></h3>
<p>To avoid copying, you can pass a pointer to the array.</p>
<p>Example:</p>
<pre><code class="language-go">package main

import "fmt"

func modifyArray(arr *[3]int) {
    arr[0] = 42
}

func main() {
    arr := [3]int{1, 2, 3}
    modifyArray(&amp;arr)
    fmt.Println("Modified array:", arr) // Output: [42 2 3]
}
</code></pre>
<h3 id="example-code-to-test-maingo"><a class="header" href="#example-code-to-test-maingo">Example code to test: main.go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func main() {
	arr1 := [5]int{1, 2, 3, 4, 5}
	arr2 := [5]int{1, 2, 3, 4, 5}

	fmt.Println(arr1)
	fmt.Println(arr2)

	var arr3 [5]int
	// fmt.Println(arr3) // this should print [0 0 0 0 0]
	// println("Length:", len(arr3))

	for i := 0; i &lt; len(arr3); i++ {
	    fmt.Scan(&amp;arr3[i])
	}
	fmt.Println(arr3)

	strArr := [3]string{"one", "two", "three"}

	for i := 0; i &lt; len(strArr); i++ {
		fmt.Print(strArr[i]+ "")
	}


}



</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/boolean
<strong>Tags:</strong> [go, boolean, data-types]
]</p>
<h1 id="a-boolean-data-type-can-either-be-true-or-false"><a class="header" href="#a-boolean-data-type-can-either-be-true-or-false">A boolean data-type can either be "TRUE" or "FALSE"</a></h1>
<pre><code class="language-go">package main

import "fmt"

func main() {
	isGolangPL := true
	isHtmlPL := false
	fmt.Println(isGolangPL)
	fmt.Println(isHtmlPL)
}
</code></pre>
<h2 id="frequently-asked-questions-1"><a class="header" href="#frequently-asked-questions-1">Frequently Asked Questions</a></h2>
<h3 id="q1-how-can-i-use-boolean-values-in-conditional-statements"><a class="header" href="#q1-how-can-i-use-boolean-values-in-conditional-statements">Q1: How can I use boolean values in conditional statements?</a></h3>
<p><strong>Answer:</strong> Boolean values are often used in conditional statements to control the flow of a program. For example:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	isEven := true
	if isEven {
		fmt.Println("The number is even.")
	} else {
		fmt.Println("The number is odd.")
	}
}
</code></pre>
<h3 id="q2-can-boolean-values-be-compared-directly"><a class="header" href="#q2-can-boolean-values-be-compared-directly">Q2: Can boolean values be compared directly?</a></h3>
<p><strong>Answer:</strong> Yes, boolean values can be compared directly using comparison operators. For example:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	isTrue := true
	isFalse := false
	fmt.Println(isTrue == isFalse) // Output: false
	fmt.Println(isTrue != isFalse) // Output: true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callback-functions"><a class="header" href="#callback-functions">Callback Functions</a></h1>
<p>If a function is passed as an argument to another function, then such types of functions are known as a Higher-Order function. This passing function as an argument is also known as a callback function or first-class function in the Go language.</p>
<pre><code class="language-go">package main
import "fmt"

func addName(name string, callback func(string)) {
    callback(name)
}

func main() {
    addName("HuXn", func(nm string) {
        fmt.Printf("Hi, my name is %v\n", nm)
    })
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-22
<strong>Category:</strong> interview-qa/arrays
<strong>Tags:</strong> [go, clousers, functions]
]</p>
<h2 id="-program-code-example"><a class="header" href="#-program-code-example">üîÅ Program Code Example</a></h2>
<pre><code class="language-go">package main

import "fmt"

const a = 10
var b = 20

func Outer() func() {
	// Outer function variables
	money := 100
	age := 20

	fmt.Println("Outer function")
	fmt.Println("Age:", age)

	show := func() {
		money += a + b
		fmt.Println("Money:", money)
	}

	return show
}

func call() {
	inc := Outer()
	inc()
	inc()
	fmt.Println("=========================")
	inc1 := Outer()
	inc1()
	inc1()
}

func main() {
	call()
}

func init() {
	fmt.Print("============ Begin ============\n")
}
</code></pre>
<hr />
<h2 id="-code-execution-phases"><a class="header" href="#-code-execution-phases">‚öôÔ∏è Code Execution Phases</a></h2>
<h3 id="-phase-1-compilation"><a class="header" href="#-phase-1-compilation">üß© Phase 1: Compilation</a></h3>
<ul>
<li>Compile and generate the binary:</li>
</ul>
<pre><code class="language-bash">go build main.go
</code></pre>
<h3 id="-phase-2-execution"><a class="header" href="#-phase-2-execution">üöÄ Phase 2: Execution</a></h3>
<ul>
<li>Run the binary:</li>
</ul>
<pre><code class="language-bash">./main
</code></pre>
<h2 id="-closures-in-go"><a class="header" href="#-closures-in-go">üîí Closures in Go</a></h2>
<h3 id="-what-is-a-closure-1"><a class="header" href="#-what-is-a-closure-1">‚úÖ What is a Closure?</a></h3>
<p>A closure is a function <strong>defined within another function</strong> and <strong>has access to the outer function's variables</strong> even after the outer function has finished executing.</p>
<pre><code class="language-go">func Outer() func() {
    money := 100
    show := func() {
        money += 10
        fmt.Println("Money:", money)
    }
    return show
}
</code></pre>
<ul>
<li><code>money</code> is captured by the inner function.</li>
<li>On each call to the returned function, <code>money</code> is updated.</li>
</ul>
<h3 id="-multiple-closures"><a class="header" href="#-multiple-closures">‚úÖ Multiple Closures</a></h3>
<ul>
<li>Each call to <code>Outer()</code> creates a new instance of <code>money</code>, isolated from others.</li>
</ul>
<hr />
<h2 id="-output-explanation"><a class="header" href="#-output-explanation">üß† Output Explanation</a></h2>
<pre><code class="language-go">init() runs first: ============ Begin ============

Outer function
Age: 20
Money: 130
Money: 160
=========================
Outer function
Age: 20
Money: 130
Money: 160
</code></pre>
<ul>
<li>Two closures are created, each with its own instance of <code>money</code>.</li>
<li>They do not interfere with each other.</li>
</ul>
<hr />
<h2 id="-types-of-closures"><a class="header" href="#-types-of-closures">üîç Types of Closures</a></h2>
<h3 id="1-closure-with-outer-variable"><a class="header" href="#1-closure-with-outer-variable">1. <strong>Closure with Outer Variable</strong></a></h3>
<p><strong>Question:</strong> Write a Go program that demonstrates how a closure can access and modify a variable from the outer function.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func outer() func() {
    x := 10
    return func() {
        x++
        fmt.Println(x)
    }
}

func main() {
    closure := outer()
    closure() // Output: 11
    closure() // Output: 12
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>outer</code> function creates a closure that captures and modifies the <code>x</code> variable.</li>
<li>Every time the closure is called, the value of <code>x</code> is incremented.</li>
</ul>
<hr />
<h3 id="2-multiple-closures-with-separate-states"><a class="header" href="#2-multiple-closures-with-separate-states">2. <strong>Multiple Closures with Separate States</strong></a></h3>
<p><strong>Question:</strong> Demonstrate how multiple closures created in the same function each maintain their own state.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func createCounter() func() int {
    counter := 0
    return func() int {
        counter++
        return counter
    }
}

func main() {
    counter1 := createCounter()
    counter2 := createCounter()

    fmt.Println(counter1()) // Output: 1
    fmt.Println(counter1()) // Output: 2
    fmt.Println(counter2()) // Output: 1
    fmt.Println(counter2()) // Output: 2
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>counter1</code> and <code>counter2</code> each maintain their own state because they are independent closures.</li>
<li>Each counter starts at 0 and increments on each call.</li>
</ul>
<hr />
<h3 id="3-closure-with-parameters"><a class="header" href="#3-closure-with-parameters">3. <strong>Closure with Parameters</strong></a></h3>
<p><strong>Question:</strong> Write a closure that accepts parameters and demonstrates how closures can be passed arguments.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func multiplier(factor int) func(int) int {
    return func(n int) int {
        return n * factor
    }
}

func main() {
    double := multiplier(2)
    triple := multiplier(3)

    fmt.Println(double(5))  // Output: 10
    fmt.Println(triple(5))  // Output: 15
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The closure <code>multiplier</code> takes a <code>factor</code> argument and returns a function that multiplies a number by that factor.</li>
<li>Each closure (<code>double</code>, <code>triple</code>) uses its own <code>factor</code> value to perform the operation.</li>
</ul>
<hr />
<h3 id="4-closures-with-deferred-execution"><a class="header" href="#4-closures-with-deferred-execution">4. <strong>Closures with Deferred Execution</strong></a></h3>
<p><strong>Question:</strong> How can closures be used in Go with deferred execution, and what happens when the closure accesses variables after the outer function returns?</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    a := 10
    defer func(a int) { // Pass 'a' as a parameter to the deferred function
        fmt.Println("Deferred closure:", a)
    }(a) // Pass the current value of 'a' here
    a = 20
    fmt.Println("Inside main:", a)
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>Even though <code>a</code> is modified inside <code>main</code>, the deferred closure captures the value of <code>a</code> at the time the defer statement was encountered by passing it as a parameter.</li>
<li>The closure prints the value of <code>a</code> that was captured before it was modified.</li>
</ul>
<hr />
<h3 id="5-closure-capturing-loop-variable"><a class="header" href="#5-closure-capturing-loop-variable">5. <strong>Closure Capturing Loop Variable</strong></a></h3>
<p><strong>Question:</strong> Write a Go program that demonstrates a common pitfall when using closures inside loops. The closure captures the loop variable incorrectly.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    funcs := []func(){}

    for i := 0; i &lt; 3; i++ {
        funcs = append(funcs, func() {
            fmt.Println(i) // Output: 3, 3, 3
        })
    }

    for _, f := range funcs {
        f()
    }
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>All closures capture the same <code>i</code> variable. At the time of closure execution, <code>i</code> is 3 (the value after the loop ends).</li>
<li>To fix this, you need to pass <code>i</code> as a parameter to the closure:</li>
</ul>
<p><strong>Fixed Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    funcs := []func(){}

    for i := 0; i &lt; 3; i++ {
        i := i // Create a new variable inside the loop
        funcs = append(funcs, func() {
            fmt.Println(i) // Output: 0, 1, 2
        })
    }

    for _, f := range funcs {
        f()
    }
}
</code></pre>
<hr />
<h3 id="6-closures-with-function-arguments"><a class="header" href="#6-closures-with-function-arguments">6. <strong>Closures with Function Arguments</strong></a></h3>
<p><strong>Question:</strong> Create a closure that adds two numbers and demonstrates how closures can capture arguments passed to the inner function.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func adder(a int) func(int) int {
    return func(b int) int {
        return a + b
    }
}

func main() {
    add5 := adder(5)
    fmt.Println(add5(3))  // Output: 8
    fmt.Println(add5(10)) // Output: 15
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The outer function <code>adder</code> captures <code>a</code> and returns a closure that adds <code>a</code> to the argument <code>b</code>.</li>
<li>The closure <code>add5</code> remembers <code>a = 5</code> and adds it to the argument passed to it.</li>
</ul>
<hr />
<h3 id="7-closures-with-a-function-factory"><a class="header" href="#7-closures-with-a-function-factory">7. <strong>Closures with a Function Factory</strong></a></h3>
<p><strong>Question:</strong> Implement a closure that acts as a function factory, returning different mathematical operations based on the argument passed to the factory.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func operationFactory(operator string) func(int, int) int {
    switch operator {
    case "add":
        return func(a, b int) int {
            return a + b
        }
    case "subtract":
        return func(a, b int) int {
            return a - b
        }
    case "multiply":
        return func(a, b int) int {
            return a * b
        }
    }
    return nil
}

func main() {
    add := operationFactory("add")
    subtract := operationFactory("subtract")
    multiply := operationFactory("multiply")

    fmt.Println(add(3, 4))       // Output: 7
    fmt.Println(subtract(9, 4))  // Output: 5
    fmt.Println(multiply(3, 4))  // Output: 12
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>operationFactory</code> returns different closures based on the operator passed.</li>
<li>Each closure performs a corresponding mathematical operation.</li>
</ul>
<hr />
<h3 id="8-closures-with-state-preservation"><a class="header" href="#8-closures-with-state-preservation">8. <strong>Closures with State Preservation</strong></a></h3>
<p><strong>Question:</strong> Write a closure that preserves state across multiple invocations (like a simple counter) and explain its working.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {
    c1 := counter()
    c2 := counter()

    fmt.Println(c1()) // Output: 1
    fmt.Println(c1()) // Output: 2
    fmt.Println(c2()) // Output: 1
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>Each call to <code>counter</code> returns a closure that maintains a unique <code>count</code> variable, preserving state across invocations.</li>
</ul>
<hr />
<h3 id="9-closure-with-function-composition"><a class="header" href="#9-closure-with-function-composition">9. <strong>Closure with Function Composition</strong></a></h3>
<p><strong>Question:</strong> Create a Go program that demonstrates function composition using closures.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func compose(f, g func(int) int) func(int) int {
    return func(x int) int {
        return f(g(x))
    }
}

func double(x int) int {
    return x * 2
}

func addFive(x int) int {
    return x + 5
}

func main() {
    composed := compose(double, addFive)
    fmt.Println(composed(3)) // Output: 16 (3 + 5 = 8, 8 * 2 = 16)
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>compose</code> function takes two functions (<code>f</code> and <code>g</code>) and returns a new function that applies <code>g</code> first, then applies <code>f</code> to the result.</li>
<li>The result is a composition of <code>double</code> and <code>addFive</code>.</li>
</ul>
<hr />
<pre><code class="language-markdown"># Go Closures - 20 Questions with Code Examples and Explanations

This document contains 20 questions related to closures in Go, along with code examples and detailed explanations.

---

### 1. **What is a closure in Go?**

**Question:** Define what a closure is in Go with an example.

**Code:**

```go
package main

import "fmt"

func outer() func() {
    return func() {
        fmt.Println("This is a closure")
    }
}

func main() {
    closure := outer()
    closure()
}
```
</code></pre>
<p><strong>Explanation:</strong><br />
A closure is a function that captures the variables from its surrounding context. In the example, the inner function returned by <code>outer</code> is a closure, as it can access the environment in which it was created.</p>
<hr />
<h3 id="2-how-does-a-closure-access-variables-from-its-outer-function"><a class="header" href="#2-how-does-a-closure-access-variables-from-its-outer-function">2. <strong>How does a closure access variables from its outer function?</strong></a></h3>
<p><strong>Question:</strong> Show how a closure can access and modify variables in the outer function.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func outer() func() {
    x := 10
    return func() {
        x++
        fmt.Println(x)
    }
}

func main() {
    closure := outer()
    closure() // Output: 11
    closure() // Output: 12
}
</code></pre>
<p><strong>Explanation:</strong><br />
The closure captures the <code>x</code> variable from the <code>outer</code> function and modifies it each time it is invoked.</p>
<hr />
<h3 id="3-what-happens-when-closures-access-variables-from-a-loop"><a class="header" href="#3-what-happens-when-closures-access-variables-from-a-loop">3. <strong>What happens when closures access variables from a loop?</strong></a></h3>
<p><strong>Question:</strong> Demonstrate the common mistake with closures capturing loop variables.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    funcs := []func(){}

    for i := 0; i &lt; 3; i++ {
        funcs = append(funcs, func() {
            fmt.Println(i)
        })
    }

    for _, f := range funcs {
        f()
    }
}
</code></pre>
<p><strong>Explanation:</strong><br />
All closures capture the same <code>i</code> variable, and when executed, they all print <code>3</code>. This happens because the closure captures a reference to the variable <code>i</code>, not its value at the time of closure creation.</p>
<hr />
<h3 id="4-how-can-you-fix-the-loop-closure-problem"><a class="header" href="#4-how-can-you-fix-the-loop-closure-problem">4. <strong>How can you fix the loop closure problem?</strong></a></h3>
<p><strong>Question:</strong> How can you avoid closures capturing the same variable in a loop?</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    funcs := []func(){}

    for i := 0; i &lt; 3; i++ {
        i := i // New variable for each iteration
        funcs = append(funcs, func() {
            fmt.Println(i)
        })
    }

    for _, f := range funcs {
        f()
    }
}
</code></pre>
<p><strong>Explanation:</strong><br />
By introducing a new variable <code>i</code> in the loop, each closure captures a separate value of <code>i</code>, resulting in <code>0</code>, <code>1</code>, and <code>2</code> being printed.</p>
<hr />
<h3 id="5-closures-as-function-parameters"><a class="header" href="#5-closures-as-function-parameters">5. <strong>Closures as Function Parameters</strong></a></h3>
<p><strong>Question:</strong> How do you pass a closure as an argument to another function?</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func applyClosure(f func()) {
    f()
}

func main() {
    closure := func() {
        fmt.Println("Closure passed as argument")
    }
    applyClosure(closure)
}
</code></pre>
<p><strong>Explanation:</strong><br />
You can pass a closure as an argument to another function. In this example, <code>applyClosure</code> accepts a closure and invokes it.</p>
<hr />
<h3 id="6-closures-with-parameters"><a class="header" href="#6-closures-with-parameters">6. <strong>Closures with Parameters</strong></a></h3>
<p><strong>Question:</strong> Write a closure that accepts a parameter and demonstrates how closures work with arguments.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func multiplier(factor int) func(int) int {
    return func(n int) int {
        return n * factor
    }
}

func main() {
    double := multiplier(2)
    fmt.Println(double(4)) // Output: 8
}
</code></pre>
<p><strong>Explanation:</strong><br />
The closure <code>multiplier</code> takes a parameter <code>factor</code> and returns a function that multiplies the given number <code>n</code> by <code>factor</code>.</p>
<hr />
<h3 id="7-closures-with-function-return-values"><a class="header" href="#7-closures-with-function-return-values">7. <strong>Closures with Function Return Values</strong></a></h3>
<p><strong>Question:</strong> How do closures work when they return values?</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func adder(a int) func(int) int {
    return func(b int) int {
        return a + b
    }
}

func main() {
    addFive := adder(5)
    fmt.Println(addFive(3)) // Output: 8
}
</code></pre>
<p><strong>Explanation:</strong><br />
The closure captures the <code>a</code> variable and uses it when adding <code>b</code> in the returned function.</p>
<hr />
<h3 id="8-returning-a-closure-from-a-function"><a class="header" href="#8-returning-a-closure-from-a-function">8. <strong>Returning a Closure from a Function</strong></a></h3>
<p><strong>Question:</strong> Demonstrate how to return a closure from a function.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func createCounter() func() int {
    counter := 0
    return func() int {
        counter++
        return counter
    }
}

func main() {
    counter1 := createCounter()
    counter2 := createCounter()

    fmt.Println(counter1()) // Output: 1
    fmt.Println(counter2()) // Output: 1
}
</code></pre>
<p><strong>Explanation:</strong><br />
Each call to <code>createCounter</code> creates a new closure, which maintains its own counter state.</p>
<hr />
<h3 id="9-closure-with-state-preservation"><a class="header" href="#9-closure-with-state-preservation">9. <strong>Closure with State Preservation</strong></a></h3>
<p><strong>Question:</strong> Write a closure that remembers its previous state across calls.</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {
    c1 := counter()
    c2 := counter()

    fmt.Println(c1()) // Output: 1
    fmt.Println(c1()) // Output: 2
    fmt.Println(c2()) // Output: 1
}
</code></pre>
<p><strong>Explanation:</strong><br />
A closure retains its own state, meaning each call to <code>counter</code> results in separate states for <code>c1</code> and <code>c2</code>.</p>
<hr />
<h3 id="10-closures-and-anonymous-functions"><a class="header" href="#10-closures-and-anonymous-functions">10. <strong>Closures and Anonymous Functions</strong></a></h3>
<p><strong>Question:</strong> How can closures be used with anonymous functions?</p>
<p><strong>Code:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    a := 5
    closure := func() {
        fmt.Println("Captured value:", a)
    }
    closure() // Output: Captured value: 5
}
</code></pre>
<p><strong>Explanation:</strong><br />
Anonymous functions can be used as closures. In this case, the anonymous function captures the variable <code>a</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> e.g., interview-qa/topic_name
<strong>Tags:</strong> [go, concurrency, channels]
]</p>
<h1 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h1>
<h2 id="comparison-operators-are-used-to-compare-two-values"><a class="header" href="#comparison-operators-are-used-to-compare-two-values">Comparison operators are used to compare two values</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Name</th><th>Example</th></tr></thead><tbody>
<tr><td>==</td><td>Equal to</td><td>x == y</td></tr>
<tr><td>!=</td><td>Not equal</td><td>x != y</td></tr>
<tr><td>&gt;</td><td>Greater than</td><td>x &gt; y</td></tr>
<tr><td>&lt;</td><td>Less than</td><td>x &lt; y</td></tr>
<tr><td>&gt;=</td><td>Greater than or equal to</td><td>x &gt;= y</td></tr>
<tr><td>&lt;=</td><td>Less than or equal to</td><td>x &lt;= y</td></tr>
</tbody></table>
</div>
<pre><code class="language-go">
package main

import "fmt"

func main() {
	fmt.Println(2 &gt; 2) // false
	fmt.Println(2 &lt; 2) // false
	fmt.Println(2 &gt;= 2) // true
	fmt.Println(2 &lt;= 2) // true
	fmt.Println(2 == 2) // true
	fmt.Println(2 != 2) // false
}
</code></pre>
<h2 id="frequently-asked-questions-2"><a class="header" href="#frequently-asked-questions-2">Frequently Asked Questions</a></h2>
<h3 id="1-what-is-the-purpose-of-comparison-operators-in-go"><a class="header" href="#1-what-is-the-purpose-of-comparison-operators-in-go">1. What is the purpose of comparison operators in Go?</a></h3>
<p><strong>Answer:</strong> Comparison operators are used to compare two values and return a boolean result (true or false).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	x := 10
	y := 20
	fmt.Println(x &gt; y) // false
	fmt.Println(x &lt; y) // true
}
</code></pre>
<h3 id="2-can-comparison-operators-be-used-with-strings-in-go"><a class="header" href="#2-can-comparison-operators-be-used-with-strings-in-go">2. Can comparison operators be used with strings in Go?</a></h3>
<p><strong>Answer:</strong> Yes, comparison operators can be used with strings to compare their lexicographical order.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println("apple" &gt; "banana") // false
	fmt.Println("apple" &lt; "banana") // true
}
</code></pre>
<h3 id="3-how-does-the--operator-work-with-structs-in-go"><a class="header" href="#3-how-does-the--operator-work-with-structs-in-go">3. How does the <code>==</code> operator work with structs in Go?</a></h3>
<p><strong>Answer:</strong> The <code>==</code> operator can be used to compare structs if all their fields are comparable.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

type Point struct {
	x, y int
}

func main() {
	p1 := Point{1, 2}
	p2 := Point{1, 2}
	fmt.Println(p1 == p2) // true
}
</code></pre>
<h3 id="4-what-happens-if-you-compare-two-different-types-in-go"><a class="header" href="#4-what-happens-if-you-compare-two-different-types-in-go">4. What happens if you compare two different types in Go?</a></h3>
<p><strong>Answer:</strong> Comparing two different types will result in a compile-time error.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

func main() {
	// Uncommenting the following line will cause a compile-time error
	// fmt.Println(10 == "10")
}
</code></pre>
<h3 id="5-can-comparison-operators-be-used-with-pointers"><a class="header" href="#5-can-comparison-operators-be-used-with-pointers">5. Can comparison operators be used with pointers?</a></h3>
<p><strong>Answer:</strong> Yes, comparison operators can be used to compare pointers for equality or inequality.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	a := 10
	b := 10
	pa := &amp;a
	pb := &amp;b
	fmt.Println(pa == pb) // false
}
</code></pre>
<h3 id="6-how-does-the--operator-work"><a class="header" href="#6-how-does-the--operator-work">6. How does the <code>!=</code> operator work?</a></h3>
<p><strong>Answer:</strong> The <code>!=</code> operator checks if two values are not equal.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	x := 5
	y := 10
	fmt.Println(x != y) // true
}
</code></pre>
<h3 id="7-can-comparison-operators-be-used-with-arrays"><a class="header" href="#7-can-comparison-operators-be-used-with-arrays">7. Can comparison operators be used with arrays?</a></h3>
<p><strong>Answer:</strong> Yes, arrays can be compared using <code>==</code> and <code>!=</code> if their elements are comparable.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	a1 := [3]int{1, 2, 3}
	a2 := [3]int{1, 2, 3}
	fmt.Println(a1 == a2) // true
}
</code></pre>
<h3 id="8-what-is-the-result-of-comparing-two-slices-using-"><a class="header" href="#8-what-is-the-result-of-comparing-two-slices-using-">8. What is the result of comparing two slices using <code>==</code>?</a></h3>
<p><strong>Answer:</strong> Slices cannot be compared using <code>==</code> except for comparison with <code>nil</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	s1 := []int{1, 2, 3}
	s2 := []int{1, 2, 3}
	fmt.Println(s1 == nil) // false
	// Uncommenting the following line will cause a compile-time error
	// fmt.Println(s1 == s2)
}
</code></pre>
<h3 id="9-how-does-go-handle-floating-point-comparison"><a class="header" href="#9-how-does-go-handle-floating-point-comparison">9. How does Go handle floating-point comparison?</a></h3>
<p><strong>Answer:</strong> Floating-point numbers can be compared using comparison operators, but be cautious of precision issues.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	x := 0.1 + 0.2
	y := 0.3
	fmt.Println(x == y) // false due to precision issues
}
</code></pre>
<h3 id="10-can-you-compare-custom-types-using-comparison-operators"><a class="header" href="#10-can-you-compare-custom-types-using-comparison-operators">10. Can you compare custom types using comparison operators?</a></h3>
<p><strong>Answer:</strong> Custom types can be compared if their underlying types support comparison.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

type Age int

func main() {
	var a1 Age = 30
	var a2 Age = 25
	fmt.Println(a1 &gt; a2) // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/conditional-statements
<strong>Tags:</strong> [go, conditional-statements, if-else]
]</p>
<h2 id="go-conditions"><a class="header" href="#go-conditions">Go Conditions</a></h2>
<h3 id="conditional-statements-allow-us-to-control-the-structure-of-our-program"><a class="header" href="#conditional-statements-allow-us-to-control-the-structure-of-our-program">Conditional statements allow us to control the structure of our program.</a></h3>
<h3 id="there-are-different-ways-by-which-we-can-control-the-flow-of-our-program-if-else-if-else-are-one-of-them"><a class="header" href="#there-are-different-ways-by-which-we-can-control-the-flow-of-our-program-if-else-if-else-are-one-of-them">There are different ways by which we can control the flow of our program, (If, else if, else) are one of them.</a></h3>
<h3 id="if-else-if-else-statments-allow-us-to-make-decisions-while-our-program-is-running-theyre-also-called-conditional-statments-in-programming"><a class="header" href="#if-else-if-else-statments-allow-us-to-make-decisions-while-our-program-is-running-theyre-also-called-conditional-statments-in-programming">(If, else if, else) statments allow us to make "decisions" while our program is running, They're also called (conditional statments) in programming.</a></h3>
<pre><code class="language-go">    // Sudo Syntax
     if condition { &lt;code&gt; }
     else if condition { &lt;code&gt; }
     else { &lt;code&gt; }
</code></pre>
<pre><code class="language-go">// Actual Code
package main
import "fmt"

func main() {
	password := "12345678"
	if len(password) &gt; 7 {
		fmt.Println("Valid Password")
	} else {
		fmt.Println("Invalid Password")
	}
}
</code></pre>
<h2 id="frequently-asked-questions-faqs"><a class="header" href="#frequently-asked-questions-faqs">Frequently Asked Questions (FAQs)</a></h2>
<h3 id="1-what-is-the-syntax-of-an-if-else-statement-in-go"><a class="header" href="#1-what-is-the-syntax-of-an-if-else-statement-in-go">1. <strong>What is the syntax of an if-else statement in Go?</strong></a></h3>
<p><strong>Answer:</strong>
The syntax of an if-else statement in Go is as follows:</p>
<pre><code class="language-go">if condition {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	number := 10
	if number%2 == 0 {
		fmt.Println("Even Number")
	} else {
		fmt.Println("Odd Number")
	}
}
</code></pre>
<h3 id="2-can-we-use-an-if-statement-without-an-else-block"><a class="header" href="#2-can-we-use-an-if-statement-without-an-else-block">2. <strong>Can we use an if statement without an else block?</strong></a></h3>
<p><strong>Answer:</strong>
Yes, an if statement can be used without an else block.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	number := 5
	if number &gt; 0 {
		fmt.Println("Positive Number")
	}
}
</code></pre>
<h3 id="3-what-is-an-else-if-ladder-in-go"><a class="header" href="#3-what-is-an-else-if-ladder-in-go">3. <strong>What is an else-if ladder in Go?</strong></a></h3>
<p><strong>Answer:</strong>
An else-if ladder is used to check multiple conditions sequentially.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	score := 85
	if score &gt;= 90 {
		fmt.Println("Grade: A")
	} else if score &gt;= 75 {
		fmt.Println("Grade: B")
	} else {
		fmt.Println("Grade: C")
	}
}
</code></pre>
<h3 id="4-how-do-you-use-a-short-statement-in-an-if-condition"><a class="header" href="#4-how-do-you-use-a-short-statement-in-an-if-condition">4. <strong>How do you use a short statement in an if condition?</strong></a></h3>
<p><strong>Answer:</strong>
A short statement can be used to initialize a variable within an if condition.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	if num := 10; num%2 == 0 {
		fmt.Println("Even Number")
	}
}
</code></pre>
<h3 id="5-can-we-nest-if-else-statements-in-go"><a class="header" href="#5-can-we-nest-if-else-statements-in-go">5. <strong>Can we nest if-else statements in Go?</strong></a></h3>
<p><strong>Answer:</strong>
Yes, if-else statements can be nested.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	number := 15
	if number &gt; 0 {
		if number%2 == 0 {
			fmt.Println("Positive Even Number")
		} else {
			fmt.Println("Positive Odd Number")
		}
	} else {
		fmt.Println("Non-Positive Number")
	}
}
</code></pre>
<h3 id="6-what-is-the-difference-between-if-else-and-switch-statements"><a class="header" href="#6-what-is-the-difference-between-if-else-and-switch-statements">6. <strong>What is the difference between if-else and switch statements?</strong></a></h3>
<p><strong>Answer:</strong>
If-else is used for conditional branching, while switch is used for selecting one of many blocks of code.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	day := 3
	switch day {
	case 1:
		fmt.Println("Monday")
	case 2:
		fmt.Println("Tuesday")
	case 3:
		fmt.Println("Wednesday")
	default:
		fmt.Println("Invalid Day")
	}
}
</code></pre>
<h3 id="7-how-do-you-handle-multiple-conditions-in-a-single-if-statement"><a class="header" href="#7-how-do-you-handle-multiple-conditions-in-a-single-if-statement">7. <strong>How do you handle multiple conditions in a single if statement?</strong></a></h3>
<p><strong>Answer:</strong>
Logical operators like <code>&amp;&amp;</code> (AND) and <code>||</code> (OR) can be used to handle multiple conditions.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	number := 15
	if number &gt; 0 &amp;&amp; number%3 == 0 {
		fmt.Println("Positive and Divisible by 3")
	}
}
</code></pre>
<h3 id="8-what-happens-if-the-condition-in-an-if-statement-is-not-a-boolean"><a class="header" href="#8-what-happens-if-the-condition-in-an-if-statement-is-not-a-boolean">8. <strong>What happens if the condition in an if statement is not a boolean?</strong></a></h3>
<p><strong>Answer:</strong>
In Go, the condition in an if statement must evaluate to a boolean. Otherwise, it will result in a compilation error.
<strong>Example:</strong></p>
<pre><code class="language-go">// This will cause a compilation error
// if 10 {
//     fmt.Println("Invalid Condition")
// }
</code></pre>
<h3 id="9-can-we-use-a-function-call-in-an-if-condition"><a class="header" href="#9-can-we-use-a-function-call-in-an-if-condition">9. <strong>Can we use a function call in an if condition?</strong></a></h3>
<p><strong>Answer:</strong>
Yes, a function call can be used in an if condition.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func isEven(num int) bool {
	return num%2 == 0
}

func main() {
	if isEven(10) {
		fmt.Println("Even Number")
	}
}
</code></pre>
<h3 id="10-how-do-you-use-if-else-with-user-input"><a class="header" href="#10-how-do-you-use-if-else-with-user-input">10. <strong>How do you use if-else with user input?</strong></a></h3>
<p><strong>Answer:</strong>
You can use the <code>fmt.Scan</code> function to take user input and use it in an if-else statement.
<strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
	var age int
	fmt.Print("Enter your age: ")
	fmt.Scan(&amp;age)
	if age &gt;= 18 {
		fmt.Println("You are eligible to vote.")
	} else {
		fmt.Println("You are not eligible to vote.")
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/constants
<strong>Tags:</strong> [go, constants, beginner]
]</p>
<h1 id="the-const-keyword-declares-the-variable-as-constant-which-means-that-it-is-unchangeable-and-read-only"><a class="header" href="#the-const-keyword-declares-the-variable-as-constant-which-means-that-it-is-unchangeable-and-read-only">The const keyword declares the variable as "constant", which means that it is unchangeable and read-only.</a></h1>
<pre><code class="language-go">package main
import ("fmt")

const user = "admin" // cannot be changed

func main() {
  fmt.Println("admin")
}
</code></pre>
<h1 id="constant-rules"><a class="header" href="#constant-rules">Constant Rules</a></h1>
<h3 id="1-constant-names-follow-the-same-naming-rules-as-variables"><a class="header" href="#1-constant-names-follow-the-same-naming-rules-as-variables">1. Constant names follow the same naming rules as variables</a></h3>
<h3 id="2-constant-names-are-usually-written-in-uppercase-letters"><a class="header" href="#2-constant-names-are-usually-written-in-uppercase-letters">2. Constant names are usually written in uppercase letters</a></h3>
<h3 id="3-constants-can-be-declared-both-inside-and-outside-of-a-function"><a class="header" href="#3-constants-can-be-declared-both-inside-and-outside-of-a-function">3. Constants can be declared both inside and outside of a function</a></h3>
<h1 id="frequently-asked-questions-3"><a class="header" href="#frequently-asked-questions-3">Frequently Asked Questions</a></h1>
<h3 id="1-what-is-a-constant-in-go"><a class="header" href="#1-what-is-a-constant-in-go">1. <strong>What is a constant in Go?</strong></a></h3>
<p><strong>Answer:</strong> A constant is a variable whose value cannot be changed once it is assigned. Constants are declared using the <code>const</code> keyword.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const PI = 3.14

func main() {
    fmt.Println("The value of PI is:", PI)
}
</code></pre>
<hr />
<h3 id="2-can-constants-be-declared-inside-a-function"><a class="header" href="#2-can-constants-be-declared-inside-a-function">2. <strong>Can constants be declared inside a function?</strong></a></h3>
<p><strong>Answer:</strong> Yes, constants can be declared both inside and outside of a function.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    const GREETING = "Hello, World!"
    fmt.Println(GREETING)
}
</code></pre>
<hr />
<h3 id="3-can-constants-hold-values-other-than-numbers"><a class="header" href="#3-can-constants-hold-values-other-than-numbers">3. <strong>Can constants hold values other than numbers?</strong></a></h3>
<p><strong>Answer:</strong> Yes, constants can hold string, boolean, or even character values.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const IS_ACTIVE = true
const MESSAGE = "Welcome to Go!"

func main() {
    fmt.Println("Is Active:", IS_ACTIVE)
    fmt.Println("Message:", MESSAGE)
}
</code></pre>
<hr />
<h3 id="4-can-constants-be-computed-at-runtime"><a class="header" href="#4-can-constants-be-computed-at-runtime">4. <strong>Can constants be computed at runtime?</strong></a></h3>
<p><strong>Answer:</strong> No, constants must be assigned a value that can be determined at compile time.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const VALUE = 10 * 2 // Valid

func main() {
    fmt.Println("Value:", VALUE)
}
</code></pre>
<hr />
<h3 id="5-what-happens-if-you-try-to-change-a-constants-value"><a class="header" href="#5-what-happens-if-you-try-to-change-a-constants-value">5. <strong>What happens if you try to change a constant's value?</strong></a></h3>
<p><strong>Answer:</strong> The compiler will throw an error if you try to change the value of a constant.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const NAME = "John"

func main() {
    // NAME = "Doe" // Uncommenting this line will cause a compilation error
    fmt.Println(NAME)
}
</code></pre>
<hr />
<h3 id="6-can-constants-be-used-in-expressions"><a class="header" href="#6-can-constants-be-used-in-expressions">6. <strong>Can constants be used in expressions?</strong></a></h3>
<p><strong>Answer:</strong> Yes, constants can be used in expressions to compute other constants.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const A = 5
const B = 10
const SUM = A + B

func main() {
    fmt.Println("Sum:", SUM)
}
</code></pre>
<hr />
<h3 id="7-what-is-the-difference-between-const-and-var-in-go"><a class="header" href="#7-what-is-the-difference-between-const-and-var-in-go">7. <strong>What is the difference between <code>const</code> and <code>var</code> in Go?</strong></a></h3>
<p><strong>Answer:</strong> <code>const</code> is used for values that do not change, while <code>var</code> is used for variables whose values can change.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const FIXED = 100
var changeable = 200

func main() {
    fmt.Println("Fixed:", FIXED)
    fmt.Println("Changeable:", changeable)
    changeable = 300
    fmt.Println("Updated Changeable:", changeable)
}
</code></pre>
<hr />
<h3 id="8-can-constants-be-of-type-array-or-slice"><a class="header" href="#8-can-constants-be-of-type-array-or-slice">8. <strong>Can constants be of type array or slice?</strong></a></h3>
<p><strong>Answer:</strong> No, constants cannot be of type array, slice, or map.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    // const ARR = [3]int{1, 2, 3} // This will cause a compilation error
    fmt.Println("Constants cannot be arrays or slices.")
}
</code></pre>
<hr />
<h3 id="9-can-constants-be-exported-in-go"><a class="header" href="#9-can-constants-be-exported-in-go">9. <strong>Can constants be exported in Go?</strong></a></h3>
<p><strong>Answer:</strong> Yes, constants can be exported if their names start with an uppercase letter.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const ExportedConstant = "I am exported!"

func main() {
    fmt.Println(ExportedConstant)
}
</code></pre>
<hr />
<h3 id="10-what-are-untyped-constants-in-go"><a class="header" href="#10-what-are-untyped-constants-in-go">10. <strong>What are untyped constants in Go?</strong></a></h3>
<p><strong>Answer:</strong> Untyped constants do not have a specific type until they are assigned to a variable.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

const VALUE = 42

func main() {
    var x int = VALUE
    var y float64 = VALUE
    fmt.Println("x:", x, "y:", y)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defer-keyword"><a class="header" href="#defer-keyword">Defer Keyword</a></h1>
<p>The <code>defer</code> keyword is used to delay the execution of a function or a statement until the nearby function returns. In simple words, <code>defer</code> will move the execution of the statement to the very end inside a function.</p>
<pre><code class="language-go">package main
import "fmt"

func greet() {
    defer fmt.Println("World")
    fmt.Println("Hello")
}

func main() {
    greet()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @fardinabir
<strong>Date:</strong> 2025-04-27
<strong>Category:</strong> interview-qa/go-routines
<strong>Tags:</strong> [go, go-routines, concurrency, routine]</p>
<h1 id="top-15-golang-interview-questions-on-concurrency-and-goroutines-detailed-answers-with-bonus"><a class="header" href="#top-15-golang-interview-questions-on-concurrency-and-goroutines-detailed-answers-with-bonus">Top 15 Golang Interview Questions on Concurrency and Goroutines (Detailed Answers with Bonus)</a></h1>
<p>This page provides a comprehensive list of 15 Go interview questions focused on concurrency and goroutines, with detailed, explanatory answers, followed by a bonus question comparing Go‚Äôs concurrency model to other languages. The questions cover theoretical concepts, practical applications, and common pitfalls, suitable for interview preparation or deepening your understanding of Go‚Äôs concurrency model. The bonus question explores why Go‚Äôs goroutines are praised compared to concurrency mechanisms in Java, Python, and other languages, with a focus on efficiency and performance.</p>
<img src="https://www.clipartmax.com/png/middle/277-2771013_golang-routine-channel-golang-gopher.png" alt="Golang Routine Channel - Golang Gopher@clipartmax.com">
<hr />
<h2 id="1-what-are-goroutines-and-how-do-they-differ-from-threads"><a class="header" href="#1-what-are-goroutines-and-how-do-they-differ-from-threads">1. What are goroutines, and how do they differ from threads?</a></h2>
<p><strong>Answer:</strong></p>
<p>Goroutines are lightweight, user-space threads managed by the Go runtime rather than the operating system. They enable concurrent execution of functions with minimal overhead, making it practical to create thousands or even millions of goroutines in a single program.</p>
<p><strong>Key Differences from Threads:</strong></p>
<ul>
<li><strong>Management</strong>: Goroutines are managed by the Go runtime‚Äôs scheduler, while threads are managed by the OS. This allows Go to optimize goroutine scheduling without relying on OS-level thread switching, which is costly.</li>
<li><strong>Memory Overhead</strong>: Goroutines start with a small stack (as low as 2KB, dynamically growing as needed), whereas OS threads typically require a fixed, larger stack (e.g., 1MB on Linux). This makes goroutines far more memory-efficient.</li>
<li><strong>Creation and Switching</strong>: Creating and context-switching goroutines is faster because it happens in user space, avoiding system calls. Thread creation and switching involve OS kernel operations, which are slower.</li>
<li><strong>Scalability</strong>: Go‚Äôs scheduler multiplexes many goroutines onto a smaller number of OS threads, enabling efficient scaling. Threads are limited by OS constraints and resource availability.</li>
<li><strong>Concurrency Model</strong>: Goroutines follow Go‚Äôs concurrency model, emphasizing channels for communication, while threads often rely on locks and shared memory, which can lead to complex synchronization issues.</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func printNumbers() {
    for i := 1; i &lt;= 5; i++ {
        fmt.Println(i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    go printNumbers() // Runs concurrently
    printNumbers()   // Runs in main goroutine
    time.Sleep(1 * time.Second) // Wait for goroutines to finish
}
</code></pre>
<p>In this example, <code>go printNumbers()</code> spawns a new goroutine, allowing two functions to run concurrently. Unlike threads, creating this goroutine is inexpensive and managed entirely by Go.</p>
<hr />
<h2 id="2-how-does-the-go-scheduler-work-with-goroutines"><a class="header" href="#2-how-does-the-go-scheduler-work-with-goroutines">2. How does the Go scheduler work with goroutines?</a></h2>
<p><strong>Answer:</strong></p>
<p>The Go scheduler is part of the Go runtime and is responsible for managing the execution of goroutines. It uses a model called the <strong>M:N scheduler</strong>, where M goroutines are multiplexed onto N OS threads. The scheduler ensures efficient utilization of CPU resources and minimizes overhead.</p>
<p><strong>Key Components</strong>:</p>
<ul>
<li><strong>G (Goroutine)</strong>: Represents a single goroutine, including its stack, program counter, and state.</li>
<li><strong>M (Machine)</strong>: Represents an OS thread, which executes goroutines.</li>
<li><strong>P (Processor)</strong>: A logical processor that schedules goroutines onto an M. The number of Ps is set by <code>GOMAXPROCS</code> (defaults to the number of CPU cores).</li>
</ul>
<p><strong>How It Works</strong>:</p>
<ol>
<li><strong>Goroutine Creation</strong>: When a goroutine is created (via <code>go</code> keyword), it‚Äôs added to a run queue managed by a P.</li>
<li><strong>Scheduling</strong>: Each P has a local run queue of goroutines. The scheduler assigns Ps to Ms (OS threads), and Ps execute goroutines from their queues.</li>
<li><strong>Work Stealing</strong>: If a P‚Äôs run queue is empty, it can steal goroutines from another P‚Äôs queue, balancing the workload.</li>
<li><strong>Preemption</strong>: The scheduler can preempt long-running goroutines (e.g., during function calls or blocking operations like syscalls) to ensure fairness.</li>
<li><strong>Blocking Handling</strong>: If a goroutine performs a blocking operation (e.g., I/O), the scheduler parks it and assigns another goroutine to the thread, maximizing CPU usage.</li>
</ol>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
)

func main() {
    fmt.Println("GOMAXPROCS:", runtime.GOMAXPROCS(0)) // Number of Ps
    for i := 0; i &lt; 10; i++ {
        go func(id int) {
            for {
                fmt.Printf("Goroutine %d running\n", id)
            }
        }(i)
    }
    select {} // Keep main goroutine alive
}
</code></pre>
<p>Here, multiple goroutines are scheduled across available Ps. The scheduler ensures they share CPU time, and <code>GOMAXPROCS</code> determines how many threads can run goroutines simultaneously.</p>
<hr />
<h2 id="3-what-is-the-purpose-of-the-go-keyword-in-go"><a class="header" href="#3-what-is-the-purpose-of-the-go-keyword-in-go">3. What is the purpose of the <code>go</code> keyword in Go?</a></h2>
<p><strong>Answer:</strong></p>
<p>The <code>go</code> keyword is used to launch a new goroutine, enabling a function to execute concurrently with other goroutines, including the main program. It‚Äôs a simple, idiomatic way to introduce concurrency in Go without explicitly managing threads.</p>
<p><strong>Purpose</strong>:</p>
<ul>
<li><strong>Concurrency</strong>: Allows functions to run independently, improving performance for tasks like parallel processing, I/O-bound operations, or background tasks.</li>
<li><strong>Simplicity</strong>: Abstracts away low-level thread management, letting the Go runtime handle scheduling.</li>
<li><strong>Scalability</strong>: Enables creating many goroutines (e.g., for handling thousands of connections) due to their low overhead.</li>
</ul>
<p><strong>How It Works</strong>:
When <code>go function()</code> is called, the Go runtime creates a new goroutine, places it in a run queue, and schedules it for execution. The calling goroutine continues immediately, without waiting for the new goroutine to complete.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    go sayHello() // Launch goroutine
    fmt.Println("Hello from main!")
    time.Sleep(100 * time.Millisecond) // Allow goroutine to run
}
</code></pre>
<p>In this example, <code>go sayHello()</code> runs <code>sayHello</code> concurrently. Without <code>time.Sleep</code>, the main goroutine might exit before <code>sayHello</code> prints, as goroutines are not guaranteed to execute immediately.</p>
<p><strong>Note</strong>: The <code>time.Sleep</code> is used here for demonstration. In production, use synchronization mechanisms like <code>sync.WaitGroup</code> or channels to coordinate goroutines.</p>
<hr />
<h2 id="4-how-do-you-synchronize-goroutines-in-go"><a class="header" href="#4-how-do-you-synchronize-goroutines-in-go">4. How do you synchronize goroutines in Go?</a></h2>
<p><strong>Answer:</strong></p>
<p>Synchronization in Go ensures that goroutines coordinate their actions, avoiding issues like race conditions or accessing shared resources incorrectly. Go provides two primary approaches: <strong>channels</strong> for communication-based synchronization and <strong>sync package primitives</strong> for traditional locking.</p>
<p><strong>Approaches</strong>:</p>
<ol>
<li>
<p><strong>Channels</strong>:</p>
<ul>
<li>Channels are the idiomatic way to synchronize goroutines, following Go‚Äôs philosophy: ‚ÄúDon‚Äôt communicate by sharing memory; share memory by communicating.‚Äù</li>
<li>Channels allow goroutines to send and receive data, inherently synchronizing their execution.</li>
<li>Example:
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan string)
    go func() {
        ch &lt;- "Hello from goroutine!" // Send
    }()
    msg := &lt;-ch // Receive, blocks until data is sent
    fmt.Println(msg)
}
</code></pre>
Here, the main goroutine waits for the message, ensuring synchronization.</li>
</ul>
</li>
<li>
<p><strong>sync.WaitGroup</strong>:</p>
<ul>
<li>Used to wait for multiple goroutines to complete.</li>
<li>Methods: <code>Add(n)</code> to set the number of goroutines, <code>Done()</code> to signal completion, and <code>Wait()</code> to block until all are done.</li>
<li>Example:
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    var wg sync.WaitGroup
    for i := 1; i &lt;= 3; i++ {
        wg.Add(1)
        go worker(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println("All workers done")
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>sync.Mutex and sync.RWMutex</strong>:</p>
<ul>
<li><code>sync.Mutex</code> provides mutual exclusion, ensuring only one goroutine accesses a critical section at a time.</li>
<li><code>sync.RWMutex</code> allows multiple readers or one writer, useful for read-heavy workloads.</li>
<li>Example:
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

var counter int
var mu sync.Mutex

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    mu.Lock()
    counter++
    mu.Unlock()
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go increment(&amp;wg)
    }
    wg.Wait()
    fmt.Println("Counter:", counter) // Always 100
}
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong>Best Practice</strong>: Prefer channels for coordination and data passing, as they reduce the risk of errors like deadlocks or race conditions compared to mutexes.</p>
<hr />
<h2 id="5-what-are-channels-and-how-do-they-facilitate-concurrency"><a class="header" href="#5-what-are-channels-and-how-do-they-facilitate-concurrency">5. What are channels, and how do they facilitate concurrency?</a></h2>
<p><strong>Answer:</strong></p>
<p>Channels are typed, thread-safe conduits that allow goroutines to communicate by sending and receiving values. They are a core feature of Go‚Äôs concurrency model, enabling safe and idiomatic coordination without shared memory.</p>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li><strong>Typed</strong>: Channels carry values of a specific type (e.g., <code>chan int</code>, <code>chan string</code>).</li>
<li><strong>Synchronized</strong>: Sending and receiving operations block until both sender and receiver are ready (for unbuffered channels), ensuring coordination.</li>
<li><strong>Safe</strong>: Channels prevent race conditions by serializing access to data.</li>
</ul>
<p><strong>Types of Channels</strong>:</p>
<ul>
<li><strong>Unbuffered</strong>: Created with <code>make(chan T)</code>. Sending blocks until a receiver is ready, and receiving blocks until a sender is ready.</li>
<li><strong>Buffered</strong>: Created with <code>make(chan T, n)</code>. Allows sending up to <code>n</code> values without blocking, but blocks when the buffer is full or empty.</li>
</ul>
<p><strong>How Channels Facilitate Concurrency</strong>:</p>
<ul>
<li><strong>Communication</strong>: Channels allow goroutines to pass data, coordinating their execution. For example, a producer goroutine can send data to a consumer goroutine.</li>
<li><strong>Synchronization</strong>: Blocking behavior ensures goroutines wait for each other, preventing premature execution.</li>
<li><strong>Control Flow</strong>: Channels can signal events, like completion or cancellation, using empty structs (<code>chan struct{}</code>).</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func producer(ch chan&lt;- int) {
    for i := 1; i &lt;= 5; i++ {
        ch &lt;- i
        time.Sleep(100 * time.Millisecond)
    }
    close(ch)
}

func main() {
    ch := make(chan int)
    go producer(ch)
    for v := range ch {
        fmt.Println("Received:", v)
    }
}
</code></pre>
<p>Here, the producer sends integers, and the main goroutine receives them. The <code>range</code> loop exits when the channel is closed, demonstrating clean coordination.</p>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Pipelines for data processing.</li>
<li>Worker pools for task distribution.</li>
<li>Signaling completion or cancellation.</li>
</ul>
<hr />
<h2 id="6-what-is-the-difference-between-buffered-and-unbuffered-channels"><a class="header" href="#6-what-is-the-difference-between-buffered-and-unbuffered-channels">6. What is the difference between buffered and unbuffered channels?</a></h2>
<p><strong>Answer:</strong></p>
<p>Channels in Go can be <strong>unbuffered</strong> or <strong>buffered</strong>, and their behavior differs significantly in terms of blocking and synchronization.</p>
<p><strong>Unbuffered Channels</strong>:</p>
<ul>
<li>Created with <code>make(chan T)</code>.</li>
<li><strong>Behavior</strong>: Sending (<code>ch &lt;- v</code>) blocks until a receiver is ready (<code>&lt;-ch</code>), and receiving blocks until a sender is ready. This ensures strict synchronization.</li>
<li><strong>Use Case</strong>: Ideal for scenarios requiring guaranteed handoff, like coordinating two goroutines.</li>
<li><strong>Example</strong>:
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan string)
    go func() {
        ch &lt;- "Hello" // Blocks until main receives
    }()
    fmt.Println(&lt;-ch) // Blocks until goroutine sends
}
</code></pre>
</li>
</ul>
<p><strong>Buffered Channels</strong>:</p>
<ul>
<li>Created with <code>make(chan T, n)</code>, where <code>n</code> is the buffer size.</li>
<li><strong>Behavior</strong>: Sending blocks only if the buffer is full, and receiving blocks only if the buffer is empty. This allows asynchronous communication within the buffer‚Äôs capacity.</li>
<li><strong>Use Case</strong>: Useful for decoupling producers and consumers or handling bursts of data.</li>
<li><strong>Example</strong>:
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan int, 2)
    ch &lt;- 1 // Non-blocking
    ch &lt;- 2 // Non-blocking
    // ch &lt;- 3 // Would block (buffer full)
    fmt.Println(&lt;-ch) // 1
    fmt.Println(&lt;-ch) // 2
}
</code></pre>
</li>
</ul>
<p><strong>Key Differences</strong>:</p>
<ul>
<li><strong>Synchronization</strong>: Unbuffered channels enforce strict synchronization; buffered channels allow some asynchrony.</li>
<li><strong>Blocking</strong>: Unbuffered channels always block unless both sender and receiver are ready; buffered channels block only when the buffer is full or empty.</li>
<li><strong>Use Cases</strong>: Unbuffered for tight coordination; buffered for throughput or decoupling.</li>
</ul>
<p><strong>Pitfall</strong>: Overusing buffered channels can hide synchronization issues or lead to goroutine leaks if the buffer fills and no receiver consumes the data.</p>
<hr />
<h2 id="7-how-does-select-work-with-channels"><a class="header" href="#7-how-does-select-work-with-channels">7. How does <code>select</code> work with channels?</a></h2>
<p><strong>Answer:</strong></p>
<p>The <code>select</code> statement in Go allows a goroutine to wait on multiple channel operations (send or receive) simultaneously, proceeding with the first operation that becomes ready. It‚Äôs analogous to a <code>switch</code> for channels, enabling flexible concurrency patterns.</p>
<p><strong>Key Features</strong>:</p>
<ul>
<li><strong>Non-blocking Choice</strong>: If multiple channel operations are ready, <code>select</code> randomly chooses one.</li>
<li><strong>Default Case</strong>: An optional <code>default</code> case runs if no channel operation is ready, making <code>select</code> non-blocking.</li>
<li><strong>Blocking</strong>: Without a <code>default</code> case, <code>select</code> blocks until at least one channel operation is ready.</li>
</ul>
<p><strong>Syntax</strong>:</p>
<pre><code class="language-go">select {
case v := &lt;-ch1:
    // Handle value from ch1
case ch2 &lt;- x:
    // Handle sending x to ch2
case v, ok := &lt;-ch3:
    // Handle value or channel closure
default:
    // Run if no channel is ready
}
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 &lt;- "from ch1"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        ch2 &lt;- "from ch2"
    }()

    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-ch1:
            fmt.Println("Received:", msg1)
        case msg2 := &lt;-ch2:
            fmt.Println("Received:", msg2)
        }
    }
}
</code></pre>
<p><strong>How It Works</strong>:</p>
<ul>
<li>The <code>select</code> waits for either <code>ch1</code> or <code>ch2</code> to send a value.</li>
<li>After 1 second, <code>ch1</code> sends, and <code>select</code> processes it.</li>
<li>After another second, <code>ch2</code> sends, and <code>select</code> processes it.</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<ul>
<li><strong>Multiplexing</strong>: Handle multiple channels in a single goroutine (e.g., aggregating logs).</li>
<li><strong>Timeouts</strong>: Combine with <code>time.After</code> to limit waiting time.</li>
<li><strong>Non-blocking Checks</strong>: Use <code>default</code> to check channel readiness without blocking.</li>
</ul>
<p><strong>Example with Timeout</strong>:</p>
<pre><code class="language-go">select {
case msg := &lt;-ch:
    fmt.Println("Received:", msg)
case &lt;-time.After(1 * time.Second):
    fmt.Println("Timeout")
}
</code></pre>
<p><strong>Pitfall</strong>: Avoid empty <code>select{}</code> (causes deadlock) or <code>select</code> with only <code>default</code> in a loop (can consume CPU).</p>
<hr />
<h2 id="8-what-is-a-race-condition-and-how-can-you-detect-and-prevent-it-in-go"><a class="header" href="#8-what-is-a-race-condition-and-how-can-you-detect-and-prevent-it-in-go">8. What is a race condition, and how can you detect and prevent it in Go?</a></h2>
<p><strong>Answer:</strong></p>
<p>A <strong>race condition</strong> occurs when multiple goroutines access shared data concurrently, and at least one access is a write, leading to unpredictable results. Race conditions are a common concurrency bug, especially in programs with shared memory.</p>
<p><strong>Example of a Race Condition</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

var counter int

func increment() {
    counter++ // Read, increment, write (not atomic)
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
    fmt.Println("Counter:", counter) // Likely not 1000
}
</code></pre>
<p>Here, <code>counter++</code> is not atomic, so concurrent increments may overwrite each other, resulting in a final value less than 1000.</p>
<p><strong>Detecting Race Conditions</strong>:</p>
<ul>
<li>Use the <strong>race detector</strong> by running your program with <code>go run -race</code>, <code>go test -race</code>, or <code>go build -race</code>.</li>
<li>The race detector instruments memory accesses and reports potential races, even if they don‚Äôt cause immediate errors.</li>
<li>Example: Running the above code with <code>go run -race</code> will flag the race on <code>counter</code>.</li>
</ul>
<p><strong>Preventing Race Conditions</strong>:</p>
<ol>
<li>
<p><strong>Mutexes</strong>:</p>
<ul>
<li>Use <code>sync.Mutex</code> to ensure exclusive access to shared data.</li>
<li>Example:
<pre><code class="language-go">var mu sync.Mutex
func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Channels</strong>:</p>
<ul>
<li>Use channels to serialize access to data, avoiding shared memory.</li>
<li>Example:
<pre><code class="language-go">func main() {
    ch := make(chan int)
    go func() {
        sum := 0
        for i := 0; i &lt; 1000; i++ {
            sum++
        }
        ch &lt;- sum
    }()
    fmt.Println("Counter:", &lt;-ch)
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Atomic Operations</strong>:</p>
<ul>
<li>Use <code>sync/atomic</code> for simple operations like counters.</li>
<li>Example:
<pre><code class="language-go">var counter int64
func increment() {
    atomic.AddInt64(&amp;counter, 1)
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Avoid Shared Memory</strong>:</p>
<ul>
<li>Design goroutines to communicate via channels, reducing the need for locks.</li>
</ul>
</li>
</ol>
<p><strong>Best Practice</strong>: Run tests with <code>-race</code> in CI pipelines to catch race conditions early.</p>
<hr />
<h2 id="9-what-is-the-purpose-of-syncwaitgroup"><a class="header" href="#9-what-is-the-purpose-of-syncwaitgroup">9. What is the purpose of <code>sync.WaitGroup</code>?</a></h2>
<p><strong>Answer:</strong></p>
<p>The <code>sync.WaitGroup</code> is a synchronization primitive in the <code>sync</code> package used to wait for a collection of goroutines to complete their execution. It‚Äôs particularly useful when you need to ensure that all concurrent tasks finish before proceeding.</p>
<p><strong>How It Works</strong>:</p>
<ul>
<li><strong>Add(n)</strong>: Increments the WaitGroup counter by <code>n</code>, representing the number of goroutines to wait for.</li>
<li><strong>Done()</strong>: Decrements the counter by 1, typically called when a goroutine completes.</li>
<li><strong>Wait()</strong>: Blocks until the counter reaches 0, indicating all goroutines have called <code>Done()</code>.</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    var wg sync.WaitGroup
    for i := 1; i &lt;= 3; i++ {
        wg.Add(1)
        go worker(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println("All workers completed")
}
</code></pre>
<p><strong>Key Points</strong>:</p>
<ul>
<li><strong>Thread-Safe</strong>: <code>sync.WaitGroup</code> is safe for concurrent use.</li>
<li><strong>Reusable</strong>: A WaitGroup can be reused after <code>Wait()</code> returns, but you must call <code>Add()</code> again.</li>
<li><strong>Common Pitfall</strong>: Calling <code>Done()</code> without a corresponding <code>Add()</code> or calling <code>Add()</code> after <code>Wait()</code> starts can cause panics or incorrect behavior.</li>
</ul>
<p><strong>Use Case</strong>:</p>
<ul>
<li>Waiting for multiple API calls to complete.</li>
<li>Coordinating parallel tasks in a worker pool.</li>
</ul>
<p><strong>Alternative</strong>: Channels can achieve similar coordination but are better for passing data or signaling specific events.</p>
<hr />
<h2 id="10-how-do-you-implement-a-worker-pool-using-goroutines"><a class="header" href="#10-how-do-you-implement-a-worker-pool-using-goroutines">10. How do you implement a worker pool using goroutines?</a></h2>
<p><strong>Answer:</strong></p>
<p>A <strong>worker pool</strong> is a pattern where a fixed number of goroutines (workers) process tasks from a shared channel, allowing controlled concurrency and efficient resource usage. It‚Äôs commonly used for tasks like processing jobs, handling requests, or performing computations.</p>
<p><strong>Steps to Implement</strong>:</p>
<ol>
<li>Create a channel for tasks (jobs).</li>
<li>Launch a fixed number of worker goroutines that read from the task channel.</li>
<li>Send tasks to the channel.</li>
<li>Collect results (if needed) via another channel.</li>
<li>Close the task channel to signal workers to exit.</li>
</ol>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func worker(id int, jobs &lt;-chan int, results chan&lt;- int, wg *sync.WaitGroup) {
    defer wg.Done()
    for j := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, j)
        results &lt;- j * 2 // Process job
    }
}

func main() {
    const numWorkers = 3
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    var wg sync.WaitGroup

    // Start workers
    for w := 1; w &lt;= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &amp;wg)
    }

    // Send jobs
    for j := 1; j &lt;= 5; j++ {
        jobs &lt;- j
    }
    close(jobs)

    // Wait for workers to finish
    wg.Wait()
    close(results)

    // Collect results
    for r := range results {
        fmt.Println("Result:", r)
    }
}
</code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li><strong>Jobs Channel</strong>: <code>jobs</code> is a buffered channel holding tasks (integers in this case).</li>
<li><strong>Workers</strong>: Three goroutines read from <code>jobs</code>, process tasks (multiply by 2), and send results to <code>results</code>.</li>
<li><strong>Results Channel</strong>: Collects processed outputs.</li>
<li><strong>WaitGroup</strong>: Ensures all workers finish before closing <code>results</code>.</li>
<li><strong>Channel Closure</strong>: Closing <code>jobs</code> signals workers to exit after processing all tasks.</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Limits concurrency to a fixed number of workers, preventing resource exhaustion.</li>
<li>Decouples task submission from processing.</li>
<li>Scales easily by adjusting the number of workers or buffer size.</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Processing batches of database queries.</li>
<li>Handling HTTP requests in a server.</li>
<li>Parallel file processing.</li>
</ul>
<hr />
<h2 id="11-what-happens-if-a-goroutine-panics"><a class="header" href="#11-what-happens-if-a-goroutine-panics">11. What happens if a goroutine panics?</a></h2>
<p><strong>Answer:</strong></p>
<p>A <strong>panic</strong> in Go is a runtime error that typically causes the program to crash. When a goroutine panics, the behavior depends on whether the panic is recovered.</p>
<p><strong>What Happens</strong>:</p>
<ul>
<li>If a goroutine panics and the panic is not recovered, the entire program terminates with a stack trace, including the panicking goroutine‚Äôs state.</li>
<li>Other goroutines are not directly affected until the program crashes, but they may not complete their work due to the abrupt termination.</li>
<li>Panics can occur due to errors like nil pointer dereferences, index out of bounds, or explicit calls to <code>panic()</code>.</li>
</ul>
<p><strong>Recovering Panics</strong>:</p>
<ul>
<li>Use <code>defer</code> with <code>recover()</code> to catch and handle panics within a goroutine.</li>
<li><code>recover()</code> returns the value passed to <code>panic()</code> if called in a deferred function; otherwise, it returns <code>nil</code>.</li>
<li>Example:
<pre><code class="language-go">package main

import "fmt"

func safeGoroutine() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("Something went wrong")
}

func main() {
    go safeGoroutine()
    go func() {
        panic("Unrecovered panic") // Crashes program
    }()
    fmt.Println("Main continues")
    select {} // Keep program alive
}
</code></pre>
</li>
</ul>
<p><strong>Key Points</strong>:</p>
<ul>
<li><strong>Isolation</strong>: Each goroutine must handle its own panics; a panic in one goroutine doesn‚Äôt directly affect others until the program crashes.</li>
<li><strong>Best Practice</strong>: Always use <code>defer recover()</code> in goroutines that might panic to prevent program crashes, especially in long-running servers.</li>
<li><strong>Logging</strong>: Log recovered panics for debugging (e.g., to a monitoring system).</li>
<li><strong>Pitfall</strong>: Overusing <code>recover()</code> can hide bugs; use it only for specific, recoverable errors.</li>
</ul>
<p><strong>Use Case</strong>: In a web server, recover panics in request-handling goroutines to prevent one bad request from crashing the entire server.</p>
<hr />
<h2 id="12-how-can-you-limit-the-number-of-concurrent-goroutines"><a class="header" href="#12-how-can-you-limit-the-number-of-concurrent-goroutines">12. How can you limit the number of concurrent goroutines?</a></h2>
<p><strong>Answer:</strong></p>
<p>Limiting concurrent goroutines is essential to control resource usage (e.g., CPU, memory, or network connections) and prevent overwhelming a system. Common techniques include using a <strong>semaphore</strong> (via a buffered channel) or a <strong>worker pool</strong>.</p>
<p><strong>Technique 1: Semaphore with Buffered Channel</strong>:</p>
<ul>
<li>A buffered channel acts as a semaphore, where the buffer size limits the number of concurrent goroutines.</li>
<li>Sending to the channel ‚Äúacquires‚Äù a slot, and receiving ‚Äúreleases‚Äù it.</li>
<li>Example:
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func task(id int, sem chan struct{}, wg *sync.WaitGroup) {
    defer wg.Done()
    defer func() { &lt;-sem }() // Release semaphore
    fmt.Printf("Task %d running\n", id)
    time.Sleep(time.Second)
}

func main() {
    const maxConcurrency = 2
    sem := make(chan struct{}, maxConcurrency)
    var wg sync.WaitGroup

    for i := 1; i &lt;= 5; i++ {
        wg.Add(1)
        sem &lt;- struct{}{} // Acquire semaphore
        go task(i, sem, &amp;wg)
    }
    wg.Wait()
}
</code></pre>
</li>
</ul>
<p><strong>Technique 2: Worker Pool</strong>:</p>
<ul>
<li>As shown in question 10, a worker pool limits concurrency by launching a fixed number of workers.</li>
<li>Tasks are sent to a channel, and only the available workers process them.</li>
</ul>
<p><strong>Key Considerations</strong>:</p>
<ul>
<li><strong>Semaphore Size</strong>: Choose a buffer size based on system resources (e.g., CPU cores, database connections).</li>
<li><strong>Error Handling</strong>: Ensure tasks handle errors to avoid deadlocks or leaks.</li>
<li><strong>Resource Cleanup</strong>: Use <code>defer</code> to release semaphore slots or close channels properly.</li>
</ul>
<p><strong>Use Case</strong>: Limiting concurrent HTTP requests or database queries to avoid overloading a server.</p>
<hr />
<h2 id="13-what-is-the-difference-between-close-and-nil-channels"><a class="header" href="#13-what-is-the-difference-between-close-and-nil-channels">13. What is the difference between <code>close</code> and <code>nil</code> channels?</a></h2>
<p><strong>Answer:</strong></p>
<p>Channels in Go can be in different states, including <strong>closed</strong> and <strong>nil</strong>, and their behavior differs significantly in terms of sending, receiving, and usage in <code>select</code>.</p>
<p><strong>Closed Channel</strong>:</p>
<ul>
<li>A channel is closed using <code>close(ch)</code>.</li>
<li><strong>Behavior</strong>:
<ul>
<li>Sending to a closed channel causes a <strong>panic</strong>.</li>
<li>Receiving from a closed channel returns the zero value of the channel‚Äôs type immediately, with <code>ok</code> set to <code>false</code> in <code>v, ok := &lt;-ch</code>.</li>
<li>Closing a channel signals that no more values will be sent, often used to broadcast completion.</li>
</ul>
</li>
<li><strong>Example</strong>:
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan int)
    go func() {
        ch &lt;- 1
        close(ch)
    }()
    v, ok := &lt;-ch
    fmt.Println(v, ok) // 1, true
    v, ok = &lt;-ch
    fmt.Println(v, ok) // 0, false
    // ch &lt;- 2 // Panic: send on closed channel
}
</code></pre>
</li>
</ul>
<p><strong>Nil Channel</strong>:</p>
<ul>
<li>A channel is <code>nil</code> if it‚Äôs declared but not initialized (e.g., <code>var ch chan int</code>).</li>
<li><strong>Behavior</strong>:
<ul>
<li>Sending or receiving on a <code>nil</code> channel blocks forever.</li>
<li>In a <code>select</code>, a <code>nil</code> channel is effectively ignored, as its operations are never ready.</li>
</ul>
</li>
<li><strong>Example</strong>:
<pre><code class="language-go">package main

import "fmt"

func main() {
    var ch chan int
    select {
    case v := &lt;-ch:
        fmt.Println(v) // Never executes
    default:
        fmt.Println("Nil channel ignored")
    }
}
</code></pre>
</li>
</ul>
<p><strong>Key Differences</strong>:</p>
<ul>
<li><strong>Purpose</strong>: Closing a channel signals completion; a <code>nil</code> channel is typically an uninitialized or dynamically disabled channel.</li>
<li><strong>Operations</strong>: Closed channels allow receiving (zero values); <code>nil</code> channels block all operations.</li>
<li><strong>Select Behavior</strong>: A closed channel may trigger a case (if not drained); a <code>nil</code> channel is skipped.</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<ul>
<li><strong>Closed Channel</strong>: Signal task completion or broadcast to multiple receivers.</li>
<li><strong>Nil Channel</strong>: Dynamically enable/disable channel operations in <code>select</code> (e.g., toggling a timeout channel).</li>
</ul>
<p><strong>Pitfall</strong>: Closing a channel twice or closing a <code>nil</code> channel causes a panic.</p>
<hr />
<h2 id="14-how-does-context-help-manage-goroutines"><a class="header" href="#14-how-does-context-help-manage-goroutines">14. How does context help manage goroutines?</a></h2>
<p><strong>Answer:</strong></p>
<p>The <code>context</code> package provides a way to manage goroutine lifecycles by carrying deadlines, cancellation signals, and key-value pairs across API boundaries. It‚Äôs widely used to coordinate and terminate goroutines gracefully, especially in long-running or networked applications.</p>
<p><strong>Key Features</strong>:</p>
<ul>
<li><strong>Context Types</strong>:
<ul>
<li><code>context.Background()</code>: Root context, used as a starting point.</li>
<li><code>context.TODO()</code>: Placeholder for contexts not yet defined.</li>
<li><code>context.WithCancel</code>: Adds cancellation.</li>
<li><code>context.WithTimeout</code>/<code>WithDeadline</code>: Adds a time-based cutoff.</li>
<li><code>context.WithValue</code>: Attaches key-value pairs (use sparingly).</li>
</ul>
</li>
<li><strong>Methods</strong>:
<ul>
<li><code>Done()</code>: Returns a channel that closes when the context is canceled or times out.</li>
<li><code>Err()</code>: Returns the reason for cancellation (e.g., <code>context.Canceled</code>, <code>context.DeadlineExceeded</code>).</li>
<li><code>Deadline()</code>: Returns the context‚Äôs deadline (if any).</li>
<li><code>Value()</code>: Retrieves a value by key.</li>
</ul>
</li>
</ul>
<p><strong>How It Manages Goroutines</strong>:</p>
<ul>
<li><strong>Cancellation</strong>: A context‚Äôs <code>Done()</code> channel signals goroutines to stop work, allowing graceful shutdown.</li>
<li><strong>Timeouts/Deadlines</strong>: Ensures goroutines don‚Äôt run indefinitely, critical for timeouts in network requests.</li>
<li><strong>Propagation</strong>: Contexts can be passed through a call chain, coordinating multiple goroutines.</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "time"
)

func longRunningTask(ctx context.Context, id int) {
    select {
    case &lt;-time.After(2 * time.Second): // Simulate work
        fmt.Printf("Task %d completed\n", id)
    case &lt;-ctx.Done():
        fmt.Printf("Task %d canceled: %v\n", id, ctx.Err())
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    for i := 1; i &lt;= 3; i++ {
        go longRunningTask(ctx, i)
    }
    time.Sleep(3 * time.Second) // Wait to see results
}
</code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li>The context times out after 1 second, closing its <code>Done()</code> channel.</li>
<li>Tasks check <code>ctx.Done()</code> and exit early if canceled, printing the error.</li>
</ul>
<p><strong>Best Practices</strong>:</p>
<ul>
<li>Always pass contexts explicitly (don‚Äôt store in structs).</li>
<li>Cancel contexts using <code>cancel()</code> to free resources.</li>
<li>Use <code>context.WithValue</code> sparingly, as it can obscure intent.</li>
<li>Check <code>ctx.Done()</code> frequently in long-running loops.</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Canceling HTTP requests on client disconnect.</li>
<li>Timing out database queries.</li>
<li>Coordinating multiple goroutines in a pipeline.</li>
</ul>
<hr />
<h2 id="15-what-are-common-pitfalls-when-using-goroutines-and-channels"><a class="header" href="#15-what-are-common-pitfalls-when-using-goroutines-and-channels">15. What are common pitfalls when using goroutines and channels?</a></h2>
<p><strong>Answer:</strong></p>
<p>While Go‚Äôs concurrency model is powerful, it‚Äôs easy to introduce subtle bugs. Below are common pitfalls and how to avoid them.</p>
<p><strong>1. Goroutine Leaks</strong>:</p>
<ul>
<li><strong>Problem</strong>: Goroutines that never terminate, consuming resources (e.g., waiting on a channel that never sends).</li>
<li><strong>Example</strong>:
<pre><code class="language-go">ch := make(chan int)
go func() {
    &lt;-ch // Blocks forever if no sender
}()
</code></pre>
</li>
<li><strong>Solution</strong>: Use <code>context</code> for cancellation, close channels, or ensure all goroutines have an exit path.</li>
<li><strong>Detection</strong>: Monitor <code>runtime.NumGoroutine()</code> or use tools like <code>pprof</code>.</li>
</ul>
<p><strong>2. Deadlocks</strong>:</p>
<ul>
<li><strong>Problem</strong>: All goroutines are blocked, waiting on each other (e.g., unbuffered channel with no receiver).</li>
<li><strong>Example</strong>:
<pre><code class="language-go">ch := make(chan int)
ch &lt;- 1 // Blocks, no receiver
</code></pre>
</li>
<li><strong>Solution</strong>: Ensure channels have matching senders/receivers, use buffered channels, or add timeouts.</li>
<li><strong>Detection</strong>: Go‚Äôs runtime detects deadlocks and panics with ‚Äúall goroutines are asleep‚Äù.</li>
</ul>
<p><strong>3. Sending to a Closed Channel</strong>:</p>
<ul>
<li><strong>Problem</strong>: Sending to a closed channel causes a panic.</li>
<li><strong>Example</strong>:
<pre><code class="language-go">ch := make(chan int)
close(ch)
ch &lt;- 1 // Panic
</code></pre>
</li>
<li><strong>Solution</strong>: Use <code>select</code> with a default case or ensure senders know when a channel is closed.</li>
<li><strong>Prevention</strong>: Close channels in the producer, not the consumer.</li>
</ul>
<p><strong>4. Overusing Mutexes</strong>:</p>
<ul>
<li><strong>Problem</strong>: Using <code>sync.Mutex</code> instead of channels for coordination, leading to complex locking logic.</li>
<li><strong>Example</strong>:
<pre><code class="language-go">var mu sync.Mutex
var data int
go func() {
    mu.Lock()
    data++
    mu.Unlock()
}()
</code></pre>
</li>
<li><strong>Solution</strong>: Prefer channels for communication and coordination where possible.</li>
<li><strong>When to Use Mutex</strong>: For protecting shared data with simple read/write patterns.</li>
</ul>
<p><strong>5. Incorrect Channel Buffer Size</strong>:</p>
<ul>
<li><strong>Problem</strong>: Choosing a buffer size that‚Äôs too small (causes blocking) or too large (hides synchronization issues).</li>
<li><strong>Example</strong>:
<pre><code class="language-go">ch := make(chan int, 1000) // May hide producer/consumer imbalance
</code></pre>
</li>
<li><strong>Solution</strong>: Start with unbuffered channels, add buffering only when needed, and monitor channel usage.</li>
<li><strong>Guideline</strong>: Buffer size should reflect expected workload and system constraints.</li>
</ul>
<p><strong>Best Practices</strong>:</p>
<ul>
<li>Test with <code>-race</code> to catch race conditions.</li>
<li>Use <code>context</code> for cancellation and timeouts.</li>
<li>Close channels responsibly and avoid sending to closed channels.</li>
<li>Prefer channels over mutexes for coordination.</li>
<li>Monitor goroutine counts and channel usage in production.</li>
</ul>
<hr />
<h2 id="bonus-question--why-are-goroutines-so-praised-compared-to-concurrency-techniques-of-other-languages"><a class="header" href="#bonus-question--why-are-goroutines-so-praised-compared-to-concurrency-techniques-of-other-languages">Bonus Question : Why are goroutines so praised compared to concurrency techniques of other languages?</a></h2>
<p><strong>Answer:</strong></p>
<p>Go‚Äôs goroutines are widely praised for their simplicity, efficiency, and performance, particularly when compared to concurrency mechanisms in languages like Java, Python, C++, and Node.js. Below is a detailed comparison focusing on <strong>efficiency</strong> (resource usage, scalability) and <strong>performance</strong> (speed, throughput), highlighting why Go‚Äôs concurrency model stands out.</p>
<h3 id="gos-goroutine-model"><a class="header" href="#gos-goroutine-model">Go‚Äôs Goroutine Model</a></h3>
<ul>
<li><strong>Goroutines</strong>: Lightweight, user-space threads managed by the Go runtime, multiplexed onto a small number of OS threads via the M:N scheduler.</li>
<li><strong>Channels</strong>: Provide a safe, idiomatic way to communicate and synchronize, reducing reliance on locks.</li>
<li><strong>Key Features</strong>:
<ul>
<li>Small initial stack size (~2KB, grows dynamically).</li>
<li>Fast creation and context switching (nanoseconds).</li>
<li>Built-in scheduler with work-stealing and preemption.</li>
<li>Native support for concurrency patterns like worker pools and pipelines.</li>
</ul>
</li>
</ul>
<h3 id="why-goroutines-are-praised"><a class="header" href="#why-goroutines-are-praised">Why Goroutines Are Praised</a></h3>
<ol>
<li>
<p><strong>Lightweight and Scalable</strong>:</p>
<ul>
<li>Goroutines use minimal memory (~2KB vs. 1MB for threads), enabling massive concurrency (e.g., millions of goroutines). Java, Python, and C++ threads are limited to thousands due to memory constraints.</li>
<li>Go‚Äôs scheduler automatically scales to available cores, unlike Python‚Äôs GIL or Node.js‚Äôs single-threaded event loop.</li>
</ul>
</li>
<li>
<p><strong>Fast Creation and Switching</strong>:</p>
<ul>
<li>Goroutine creation (~100ns) and context switching are orders of magnitude faster than Java/C++ threads (~10¬µs) or Python processes (~1ms). They‚Äôre competitive with Node.js callbacks and C++ coroutines but more versatile.</li>
<li>Go‚Äôs user-space scheduling avoids OS overhead, unlike Java/C++ threads.</li>
</ul>
</li>
<li>
<p><strong>Simplified Programming Model</strong>:</p>
<ul>
<li>Channels provide a safe, high-level abstraction for communication, reducing bugs compared to Java/C++ locks or Python‚Äôs multiprocessing IPC.</li>
<li>Goroutines hide low-level details, unlike Node.js‚Äôs explicit async/await or C++‚Äôs manual coroutine management.</li>
</ul>
</li>
<li>
<p><strong>Performance for Mixed Workloads</strong>:</p>
<ul>
<li>Go handles both CPU- and I/O-bound tasks efficiently, unlike Node.js (I/O-focused) or Python (GIL-limited for CPU tasks). Java and C++ require complex async frameworks for I/O-bound tasks, while Go‚Äôs scheduler manages both seamlessly.</li>
<li>Benchmarks (e.g., HTTP servers) show Go outperforming Java (without async frameworks) and Python for concurrent workloads, with throughput close to C++ but simpler code.</li>
</ul>
</li>
<li>
<p><strong>Built-in Runtime Support</strong>:</p>
<ul>
<li>Go‚Äôs scheduler, preemption, and garbage collector are optimized for concurrency, unlike C++‚Äôs reliance on third-party libraries or Python‚Äôs GIL constraints.</li>
<li>Java‚Äôs concurrency utilities (e.g., ExecutorService) are powerful but verbose, while Go‚Äôs model is concise and integrated.</li>
</ul>
</li>
</ol>
<h3 id="quantitative-example-with-others"><a class="header" href="#quantitative-example-with-others">Quantitative Example with Others</a></h3>
<p>Consider a server handling 100,000 concurrent connections:</p>
<ul>
<li><strong>Go</strong>: 100,000 goroutines use ~200MB memory, with fast creation (~100ns each) and high throughput due to multi-core scheduling.</li>
<li><strong>Java</strong>: 100,000 threads use ~100GB, with creation times of ~10¬µs each, requiring thread pools or async frameworks (e.g., Netty) for efficiency.</li>
<li><strong>Python</strong>: Threading is GIL-limited, multiprocessing uses ~1TB, and AsyncIO struggles with CPU tasks, requiring hybrid approaches.</li>
<li><strong>C++</strong>: Threads use ~100GB; coroutines are lightweight but lack standard scheduling, requiring custom libraries.</li>
<li><strong>Node.js</strong>: Event loop handles I/O well but bottlenecks on CPU tasks, needing worker threads (~100GB).</li>
</ul>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Goroutines are praised for their <strong>lightweight nature</strong>, <strong>fast performance</strong>, and <strong>simple programming model</strong>, making them more efficient and scalable than Java/C++ threads, Python‚Äôs threading/multiprocessing, and Node.js‚Äôs event loop for most workloads. Channels and the Go scheduler eliminate much of the complexity of traditional concurrency, enabling developers to write robust, high-performance concurrent programs with ease. While Java and C++ offer powerful concurrency tools, they require more boilerplate and tuning, and Python‚Äôs GIL and Node.js‚Äôs single-threaded model limit their versatility. Go strikes a unique balance, making it a preferred choice for concurrent systems like servers, microservices, and distributed applications.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-22
<strong>Category:</strong> interview-qa/Higher-Order
<strong>Tags:</strong> [go, First-Order, Higher-Order]
]</p>
<h2 id="first-order-function-and-higher-order-function"><a class="header" href="#first-order-function-and-higher-order-function">First-Order Function and Higher-Order Function</a></h2>
<h3 id="first-order-function"><a class="header" href="#first-order-function">First-Order Function</a></h3>
<p>A <strong>first-order function</strong> is a function that operates on basic data types (integers, strings, etc.) and does not take other functions as arguments nor returns a function as its result.</p>
<h3 id="higher-order-function"><a class="header" href="#higher-order-function">Higher-Order Function</a></h3>
<p>A <strong>higher-order function</strong> is a function that can accept other functions as arguments and/or return a function as its result. Higher-order functions are key in functional programming paradigms.</p>
<h3 id="example-code"><a class="header" href="#example-code">Example Code</a></h3>
<h4 id="first-order-function-1"><a class="header" href="#first-order-function-1">First-Order Function</a></h4>
<pre><code class="language-go">package main

import "fmt"

// First-order function: does not take or return another function
func add(a int, b int) int {
    return a + b
}

func main() {
    result := add(5, 3)
    fmt.Println("Result:", result) // Output: Result: 8
}
</code></pre>
<h4 id="higher-order-function-1"><a class="header" href="#higher-order-function-1">Higher-Order Function</a></h4>
<pre><code class="language-go">package main

import "fmt"

// Higher-order function: takes a function as an argument
func applyOperation(a int, b int, operation func(int, int) int) int {
    return operation(a, b)
}

// Function to be passed as an argument
func multiply(a int, b int) int {
    return a * b
}

func main() {
    result := applyOperation(5, 3, multiply)
    fmt.Println("Result:", result) // Output: Result: 15
}
</code></pre>
<h3 id="logic-in-mathematics"><a class="header" href="#logic-in-mathematics">Logic in Mathematics</a></h3>
<p>In discrete mathematics, logic is used to define and analyze the properties and relationships of objects.</p>
<ol>
<li><strong>Object</strong>: An entity that has a physical existence (e.g., people, animals).</li>
<li><strong>Property</strong>: Characteristics or attributes of objects (e.g., color, height).</li>
<li><strong>Relation</strong>: Describes how objects are related to each other (e.g., "all customers must pay their pizza bills").</li>
</ol>
<p>Example:</p>
<ul>
<li>
<p><strong>Object</strong>: Customer</p>
</li>
<li>
<p><strong>Property</strong>: Has a bill</p>
</li>
<li>
<p><strong>Relation</strong>: Must pay the bill</p>
</li>
<li>
<p><strong>First-Order Logic</strong>: Works with objects, properties, and relations.</p>
</li>
<li>
<p><strong>Higher-Order Logic</strong>: Works with relations between functions and operations.</p>
</li>
</ul>
<p>In the context of functions:</p>
<ul>
<li><strong>First-Order Function</strong>: Operates directly on objects and their properties.</li>
<li><strong>Higher-Order Function</strong>: Operates on relations between functions, allowing for more abstract and flexible operations.</li>
</ul>
<h3 id="functional-paradigms"><a class="header" href="#functional-paradigms">Functional Paradigms</a></h3>
<p>Functional programming is a programming paradigm where programs are constructed by applying and composing functions. It emphasizes <strong>pure functions</strong>, <strong>immutability</strong>, and <strong>higher-order functions</strong>.</p>
<ul>
<li><strong>Pure Functions</strong>: Functions that always produce the same output for the same input and have no side effects.</li>
<li><strong>Immutability</strong>: Data cannot be changed once it is created. New data structures are created with updated values.</li>
<li><strong>First-Class Functions</strong>: Functions are treated as first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions.</li>
<li><strong>Higher-Order Functions</strong>: Functions that take other functions as arguments or return them as results.</li>
</ul>
<p>Functional programming languages like <strong>Haskell</strong>, <strong>Racket</strong>, and <strong>Lisp</strong> provide powerful abstractions for working with functions.</p>
<h3 id="additional-example-code"><a class="header" href="#additional-example-code">Additional Example Code</a></h3>
<h4 id="higher-order-function-returning-another-function"><a class="header" href="#higher-order-function-returning-another-function">Higher-Order Function Returning Another Function</a></h4>
<pre><code class="language-go">package main

import "fmt"

// Higher-order function: returns another function
func call() func(int, int) {
    return add
}

func add(a, b int) {
    z := a + b
    fmt.Println(z)
}

func main() {
    // call() is a higher-order function which returns the function add.
    // The returned function is assigned to a variable f, then f is called with arguments 10, 20.
    f := call()
    f(10, 20) // Output: 30
}
</code></pre>
<h4 id="higher-order-function-with-first-class-functions"><a class="header" href="#higher-order-function-with-first-class-functions">Higher-Order Function with First-Class Functions</a></h4>
<pre><code class="language-go">package main

import "fmt"

// Higher-order function: accepts another function as an argument
func applyAndReturn(fn func(int, int) int, x int, y int) int {
    return fn(x, y)
}

// Function to be passed as an argument
func subtract(a int, b int) int {
    return a - b
}

func main() {
    result := applyAndReturn(subtract, 10, 5)
    fmt.Println("Result:", result) // Output: Result: 5
}
</code></pre>
<h3 id="interview-qa-code-examples"><a class="header" href="#interview-qa-code-examples">Interview Q&amp;A (Code Examples)</a></h3>
<h4 id="1-what-is-a-higher-order-function"><a class="header" href="#1-what-is-a-higher-order-function">1. <strong>What is a higher-order function?</strong></a></h4>
<p><strong>Question</strong>: What is a higher-order function, and how does it work in Go?</p>
<p><strong>Answer</strong>:
A higher-order function is a function that either accepts other functions as parameters or returns a function.</p>
<p>Example:</p>
<pre><code class="language-go">package main

import "fmt"

func applyOperation(a int, b int, operation func(int, int) int) int {
    return operation(a, b)
}

func add(a, b int) int {
    return a + b
}

func main() {
    result := applyOperation(3, 4, add)
    fmt.Println("Result:", result) // Output: Result: 7
}
</code></pre>
<h4 id="2-what-is-a-first-order-function"><a class="header" href="#2-what-is-a-first-order-function">2. <strong>What is a first-order function?</strong></a></h4>
<p><strong>Question</strong>: Explain a first-order function in Go.</p>
<p><strong>Answer</strong>:
A first-order function operates on basic data types and does not take other functions as parameters nor return functions.</p>
<p>Example:</p>
<pre><code class="language-go">package main

import "fmt"

func add(a int, b int) int {
    return a + b
}

func main() {
    result := add(3, 5)
    fmt.Println("Result:", result) // Output: Result: 8
}
</code></pre>
<h4 id="3-can-you-create-a-function-that-returns-another-function"><a class="header" href="#3-can-you-create-a-function-that-returns-another-function">3. <strong>Can you create a function that returns another function?</strong></a></h4>
<p><strong>Question</strong>: Write a function that returns another function and demonstrates its usage.</p>
<p><strong>Answer</strong>:
Yes, you can create a higher-order function that returns another function. Here's an example:</p>
<pre><code class="language-go">package main

import "fmt"

func multiply(a int) func(int) int {
    return func(b int) int {
        return a * b
    }
}

func main() {
    multiplyBy2 := multiply(2)
    fmt.Println("Result:", multiplyBy2(5)) // Output: Result: 10
}
</code></pre>
<h4 id="4-what-is-an-anonymous-function-in-go"><a class="header" href="#4-what-is-an-anonymous-function-in-go">4. <strong>What is an anonymous function in Go?</strong></a></h4>
<p><strong>Question</strong>: Show an example of an anonymous function in Go.</p>
<p><strong>Answer</strong>:
An anonymous function is a function defined without a name, often used for short-lived operations.</p>
<p>Example:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    func(a int, b int) {
        fmt.Println("Sum:", a+b)
    }(3, 4) // Output: Sum: 7
}
</code></pre>
<h4 id="5-what-is-an-immediately-invoked-function-expression-iife-in-go"><a class="header" href="#5-what-is-an-immediately-invoked-function-expression-iife-in-go">5. <strong>What is an Immediately Invoked Function Expression (IIFE) in Go?</strong></a></h4>
<p><strong>Question</strong>: Write a code example for an Immediately Invoked Function Expression (IIFE) in Go.</p>
<p><strong>Answer</strong>:
An IIFE is a function that is defined and immediately invoked.</p>
<p>Example:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    result := func(a int, b int) int {
        return a + b
    }(3, 4)

    fmt.Println("Result:", result) // Output: Result: 7
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-22
<strong>Category:</strong> interview-qa/Function Expressions
<strong>Tags:</strong> [go, Function Expressions, Anonymous Functions ]
]</p>
<h3 id="function-expressions-and-anonymous-functions-in-go"><a class="header" href="#function-expressions-and-anonymous-functions-in-go">Function Expressions and Anonymous Functions in Go</a></h3>
<p>In Go, functions can be treated as first-class citizens, meaning they can be assigned to variables, passed as arguments, or returned from other functions. These capabilities make Go flexible in terms of handling operations that require dynamic behavior.</p>
<h3 id="function-expressions"><a class="header" href="#function-expressions">Function Expressions</a></h3>
<p>A <strong>function expression</strong> is when you assign a function to a variable. This allows you to treat the function like any other value in Go, and invoke it using the variable name.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    // Assigning a function to a variable
    add := func(a int, b int) int {
        return a + b
    }

    // Using the variable to call the function
    result := add(3, 4)
    fmt.Println("Sum:", result) // Output: Sum: 7
}
</code></pre>
<h3 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h3>
<p>An <strong>anonymous function</strong> is a function that is defined without a name. These are often used for one-off tasks, such as callbacks or short-lived operations.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    // Anonymous function without a name
    func(message string) {
        fmt.Println(message)
    }("Hello, Go!") // Output: Hello, Go!
}
</code></pre>
<h3 id="immediately-invoked-function-expressions-iife"><a class="header" href="#immediately-invoked-function-expressions-iife">Immediately Invoked Function Expressions (IIFE)</a></h3>
<p>In Go, you can also define an anonymous function and immediately invoke it. This is useful for initializing values, performing a quick operation, or executing code that does not need to be reused.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    // Immediately Invoked Function Expression (IIFE)
    result := func(a int, b int) int {
        return a + b
    }(3, 4) // Function is invoked immediately with the arguments

    fmt.Println("Sum:", result) // Output: Sum: 7
}
</code></pre>
<h3 id="more-examples"><a class="header" href="#more-examples">More Examples</a></h3>
<h4 id="1-returning-a-function-from-another-function"><a class="header" href="#1-returning-a-function-from-another-function">1. Returning a Function from Another Function</a></h4>
<p>You can return a function from another function, which can then be used later.</p>
<pre><code class="language-go">package main
import "fmt"

func multiply(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

func main() {
    // Creating a multiplier function with factor 2
    multiplyByTwo := multiply(2)
    result := multiplyByTwo(5)
    fmt.Println("Multiplication Result:", result) // Output: 10
}
</code></pre>
<h4 id="2-using-function-expressions-with-map-operations"><a class="header" href="#2-using-function-expressions-with-map-operations">2. Using Function Expressions with Map Operations</a></h4>
<p>Function expressions can be used with map functions to process elements in collections.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    // Using a function expression to map each element
    doubledNumbers := mapFunc(numbers, func(x int) int {
        return x * 2
    })

    fmt.Println("Doubled Numbers:", doubledNumbers) // Output: [2 4 6 8 10]
}

func mapFunc(numbers []int, f func(int) int) []int {
    var result []int
    for _, number := range numbers {
        result = append(result, f(number))
    }
    return result
}
</code></pre>
<h3 id="interview-questions-and-answers"><a class="header" href="#interview-questions-and-answers">Interview Questions and Answers</a></h3>
<h4 id="1-what-are-function-expressions-in-go-and-how-are-they-useful"><a class="header" href="#1-what-are-function-expressions-in-go-and-how-are-they-useful">1. What are function expressions in Go, and how are they useful?</a></h4>
<p><strong>Answer:</strong>
A function expression is when a function is assigned to a variable. This allows you to treat functions as values and pass them around like other types, enabling dynamic behavior. For instance, you can pass functions as arguments, return them from other functions, and store them in data structures.</p>
<h4 id="2-what-is-an-anonymous-function-in-go-give-an-example"><a class="header" href="#2-what-is-an-anonymous-function-in-go-give-an-example">2. What is an anonymous function in Go? Give an example.</a></h4>
<p><strong>Answer:</strong>
An anonymous function is a function without a name. It can be used for quick, short-lived tasks where the function's name is not necessary. Here's an example of an anonymous function:</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    // Anonymous function used to print a message
    func(message string) {
        fmt.Println(message)
    }("Hello, Go!") // Output: Hello, Go!
}
</code></pre>
<h4 id="3-what-is-the-difference-between-a-function-expression-and-a-named-function"><a class="header" href="#3-what-is-the-difference-between-a-function-expression-and-a-named-function">3. What is the difference between a function expression and a named function?</a></h4>
<p><strong>Answer:</strong>
A named function has a specific name and can be called by that name. A function expression is an unnamed function assigned to a variable, and the function can be called using that variable. Function expressions offer more flexibility, as you can assign them to variables, pass them around, and invoke them in different contexts.</p>
<h4 id="4-what-is-an-immediately-invoked-function-expression-iife-in-go"><a class="header" href="#4-what-is-an-immediately-invoked-function-expression-iife-in-go">4. What is an Immediately Invoked Function Expression (IIFE) in Go?</a></h4>
<p><strong>Answer:</strong>
An Immediately Invoked Function Expression (IIFE) is a function that is defined and called immediately in one expression. This is useful for scenarios where you need to perform a quick operation without the need for a function name or reuse. Example:</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    // IIFE to perform an immediate calculation
    result := func(a int, b int) int {
        return a + b
    }(3, 4) // Function is invoked immediately

    fmt.Println("Sum:", result) // Output: Sum: 7
}
</code></pre>
<h4 id="5-how-can-you-pass-a-function-as-an-argument-to-another-function-in-go"><a class="header" href="#5-how-can-you-pass-a-function-as-an-argument-to-another-function-in-go">5. How can you pass a function as an argument to another function in Go?</a></h4>
<p><strong>Answer:</strong>
In Go, you can pass a function as an argument to another function by defining the function signature in the argument list. This allows you to treat the passed function as a value and invoke it within the receiving function.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func applyOperation(a int, b int, operation func(int, int) int) int {
    return operation(a, b)
}

func main() {
    add := func(a int, b int) int {
        return a + b
    }

    result := applyOperation(3, 4, add) // Passing function as argument
    fmt.Println("Sum:", result) // Output: Sum: 7
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-20
<strong>Category:</strong> interview-qa/internal_memory
<strong>Tags:</strong> [go, internal_memory]
]</p>
<h1 id="internal-memory-in-go"><a class="header" href="#internal-memory-in-go">Internal Memory in Go</a></h1>
<p>In Go, internal memory management is a crucial concept that helps developers understand how the Go runtime handles memory allocation and execution. This includes understanding the code segment, data segment, stack, and heap.</p>
<h2 id="code-segment"><a class="header" href="#code-segment">Code Segment</a></h2>
<p>The code segment contains all the functions and executable instructions of a program. It is a read-only section of memory where the compiled code resides. This segment is loaded into memory when the program starts.</p>
<h3 id="example"><a class="header" href="#example">Example:</a></h3>
<pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
</code></pre>
<p>In this example, the <code>main</code> function and the <code>fmt.Println</code> function are part of the code segment.</p>
<h2 id="data-segment"><a class="header" href="#data-segment">Data Segment</a></h2>
<p>The data segment contains all the global and static variables. These variables are initialized before the program starts executing and remain in memory throughout the program's lifecycle.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example:</a></h3>
<pre><code class="language-go">package main

import "fmt"

var globalVar = "I am a global variable"

func main() {
    fmt.Println(globalVar)
}
</code></pre>
<p>Here, <code>globalVar</code> resides in the data segment.</p>
<h2 id="stack-segment"><a class="header" href="#stack-segment">Stack Segment</a></h2>
<p>The stack segment is used for function calls, local variables, and control flow. When a function is called, a stack frame is created in the stack segment. This stack frame contains the function's local variables and return address. The stack is managed in a Last In, First Out (LIFO) manner.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example:</a></h3>
<pre><code class="language-go">package main

import "fmt"

func add(a int, b int) int {
    return a + b
}

func main() {
    result := add(5, 3)
    fmt.Println("Result:", result)
}
</code></pre>
<p>In this example, when <code>add</code> is called, a stack frame is created for its local variables <code>a</code> and <code>b</code>.</p>
<h2 id="heap-segment"><a class="header" href="#heap-segment">Heap Segment</a></h2>
<p>The heap segment is used for dynamic memory allocation. Memory allocated on the heap is managed by the garbage collector in Go. Variables in the heap have a longer lifetime compared to stack variables.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example:</a></h3>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ptr := new(int) // Allocates memory on the heap
    *ptr = 42
    fmt.Println("Value:", *ptr)
}
</code></pre>
<p>Here, <code>ptr</code> points to a memory location on the heap where the value <code>42</code> is stored.</p>
<h2 id="initialization-and-execution"><a class="header" href="#initialization-and-execution">Initialization and Execution</a></h2>
<p>When a Go program starts, it first looks for <code>init</code> functions. If any <code>init</code> functions are present, they are executed before the <code>main</code> function. The <code>init</code> functions are used for initializing global variables or performing setup tasks.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example:</a></h3>
<pre><code class="language-go">package main

import "fmt"

var globalVar string

func init() {
    globalVar = "Initialized in init function"
    fmt.Println("Init function executed")
}

func main() {
    fmt.Println(globalVar)
}
</code></pre>
<p>In this example, the <code>init</code> function initializes the <code>globalVar</code> before the <code>main</code> function is executed.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li><strong>Code Segment</strong>: Contains all the functions and executable instructions.</li>
<li><strong>Data Segment</strong>: Contains global and static variables.</li>
<li><strong>Stack Segment</strong>: Used for function calls and local variables.</li>
<li><strong>Heap Segment</strong>: Used for dynamic memory allocation.</li>
<li><strong>Init Function</strong>: Executed before the <code>main</code> function for initialization tasks.</li>
</ul>
<h2 id="code-execution-phases"><a class="header" href="#code-execution-phases">Code Execution Phases</a></h2>
<h3 id="phases-of-code-execution"><a class="header" href="#phases-of-code-execution">Phases of Code Execution</a></h3>
<ol>
<li><strong>Compile the code and generate the binary file</strong>:
<pre><code class="language-bash">go build main.go
</code></pre>
</li>
<li><strong>Run the binary file</strong>:
<pre><code class="language-bash">./main
</code></pre>
</li>
</ol>
<h2 id="internal-memory-execution"><a class="header" href="#internal-memory-execution">Internal Memory Execution</a></h2>
<h3 id="code-segment-1"><a class="header" href="#code-segment-1">Code Segment</a></h3>
<ul>
<li>Holds the compiled code of the program.</li>
<li>The code segment is read-only and cannot be modified at runtime.</li>
<li>The code segment is loaded into memory when the program is executed.</li>
<li>The code segment is divided into two parts:
<ol>
<li>Text segment: Holds the compiled code of the program.</li>
<li>Data segment: Holds the initialized and uninitialized data of the program.</li>
</ol>
</li>
<li>The code segment is a static memory allocation.</li>
<li>The code segment is allocated at compile time and is fixed in size.</li>
<li>The code segment is used for the program code and constants.</li>
<li>The code segment is shared among all processes.</li>
<li>The code segment is not writable and cannot be modified at runtime.</li>
</ul>
<h3 id="data-segment-1"><a class="header" href="#data-segment-1">Data Segment</a></h3>
<ul>
<li>Holds the global variables and constants.</li>
<li>The data segment is divided into two parts:
<ol>
<li>Initialized data segment: Holds the initialized global variables and constants.</li>
<li>Uninitialized data segment: Holds the uninitialized global variables and constants.</li>
</ol>
</li>
<li>The data segment is a static memory allocation.</li>
<li>The data segment is allocated at compile time and is fixed in size.</li>
<li>The data segment is used for global variables and constants.</li>
</ul>
<h3 id="stack-segment-1"><a class="header" href="#stack-segment-1">Stack Segment</a></h3>
<ul>
<li>Holds the local variables and function calls.</li>
<li>Each function call creates a new stack frame.</li>
<li>When a function call is completed, its stack frame is removed from the stack.</li>
<li>The stack grows and shrinks as functions are called and return.</li>
<li>The stack is a LIFO (Last In First Out) data structure.</li>
<li>The stack is used for function calls, local variables, and control flow.</li>
<li>The stack is a dynamic memory allocation.</li>
<li>The stack is allocated at runtime and can grow and shrink as needed.</li>
<li>The stack is not shared among processes.</li>
<li>The stack is writable and can be modified at runtime.</li>
<li>The stack is used for local variables and function calls.</li>
</ul>
<h3 id="heap-segment-1"><a class="header" href="#heap-segment-1">Heap Segment</a></h3>
<ul>
<li>Holds the dynamically allocated memory.</li>
<li>The heap is a dynamic memory allocation.</li>
<li>The heap is allocated at runtime and can grow and shrink as needed.</li>
<li>The heap is shared among processes.</li>
<li>The heap is writable and can be modified at runtime.</li>
<li>The heap is used for dynamically allocated memory.</li>
</ul>
<h3 id="escape-analysis"><a class="header" href="#escape-analysis">Escape Analysis</a></h3>
<ol>
<li>If the variable is declared inside a function, it will be stored in the stack segment.</li>
<li>If the variable is declared outside a function, it will be stored in the data segment.</li>
<li>If the variable is declared inside a function and it is returned from the function, it will be stored in the heap segment.</li>
<li>If the variable is declared inside a function and it is not returned from the function, it will be stored in the stack segment.</li>
</ol>
<h2 id="common-interview-questions-on-internal-memory-in-go"><a class="header" href="#common-interview-questions-on-internal-memory-in-go">Common Interview Questions on Internal Memory in Go</a></h2>
<h3 id="1-what-is-the-difference-between-stack-and-heap-memory"><a class="header" href="#1-what-is-the-difference-between-stack-and-heap-memory">1. What is the difference between stack and heap memory?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li><strong>Stack</strong>: Used for function calls and local variables. It is faster but has limited size.</li>
<li><strong>Heap</strong>: Used for dynamic memory allocation. It is slower but has a larger size.</li>
</ul>
<h3 id="2-how-does-go-manage-memory-allocation"><a class="header" href="#2-how-does-go-manage-memory-allocation">2. How does Go manage memory allocation?</a></h3>
<p><strong>Answer:</strong>
Go uses garbage collection to manage memory allocation. The garbage collector automatically frees memory that is no longer in use.</p>
<h3 id="3-what-is-escape-analysis-in-go"><a class="header" href="#3-what-is-escape-analysis-in-go">3. What is escape analysis in Go?</a></h3>
<p><strong>Answer:</strong>
Escape analysis determines whether a variable should be allocated on the stack or the heap. If a variable "escapes" the function, it is allocated on the heap.</p>
<h3 id="4-what-is-the-purpose-of-the-init-function-in-go"><a class="header" href="#4-what-is-the-purpose-of-the-init-function-in-go">4. What is the purpose of the <code>init</code> function in Go?</a></h3>
<p><strong>Answer:</strong>
The <code>init</code> function is used for initializing global variables or performing setup tasks before the <code>main</code> function is executed.</p>
<h3 id="5-can-the-code-segment-be-modified-at-runtime"><a class="header" href="#5-can-the-code-segment-be-modified-at-runtime">5. Can the code segment be modified at runtime?</a></h3>
<p><strong>Answer:</strong>
No, the code segment is read-only and cannot be modified at runtime.</p>
<h3 id="6-what-happens-if-the-stack-memory-is-exceeded"><a class="header" href="#6-what-happens-if-the-stack-memory-is-exceeded">6. What happens if the stack memory is exceeded?</a></h3>
<p><strong>Answer:</strong>
If the stack memory is exceeded, a stack overflow error occurs.</p>
<h3 id="7-how-does-go-handle-dynamic-memory-allocation"><a class="header" href="#7-how-does-go-handle-dynamic-memory-allocation">7. How does Go handle dynamic memory allocation?</a></h3>
<p><strong>Answer:</strong>
Go uses the <code>new</code> and <code>make</code> functions for dynamic memory allocation. The garbage collector manages the memory.</p>
<h3 id="8-what-is-the-difference-between-new-and-make-in-go"><a class="header" href="#8-what-is-the-difference-between-new-and-make-in-go">8. What is the difference between <code>new</code> and <code>make</code> in Go?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li><code>new</code>: Allocates memory and returns a pointer.</li>
<li><code>make</code>: Initializes slices, maps, and channels.</li>
</ul>
<h3 id="9-how-are-global-variables-stored-in-memory"><a class="header" href="#9-how-are-global-variables-stored-in-memory">9. How are global variables stored in memory?</a></h3>
<p><strong>Answer:</strong>
Global variables are stored in the data segment of memory.</p>
<h3 id="10-what-is-the-role-of-the-garbage-collector-in-go"><a class="header" href="#10-what-is-the-role-of-the-garbage-collector-in-go">10. What is the role of the garbage collector in Go?</a></h3>
<p><strong>Answer:</strong>
The garbage collector automatically frees memory that is no longer in use, preventing memory leaks.</p>
<h3 id="example-code-for-escape-analysis"><a class="header" href="#example-code-for-escape-analysis">Example Code for Escape Analysis</a></h3>
<pre><code class="language-go">package main

import "fmt"

func createPointer() *int {
    num := 42
    return &amp;num // Escapes to heap
}

func main() {
    ptr := createPointer()
    fmt.Println(*ptr)
}
</code></pre>
<p>In this example, the variable <code>num</code> escapes to the heap because it is returned from the function <code>createPointer</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/logical_operators
<strong>Tags:</strong> [go, logical_operators]
]</p>
<h1 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h1>
<h2 id="logical-operators-are-used-to-determine-the-logic-between-variables-or-values"><a class="header" href="#logical-operators-are-used-to-determine-the-logic-between-variables-or-values">Logical operators are used to determine the logic between variables or values.</a></h2>
<h2 id="1-logical-and-"><a class="header" href="#1-logical-and-">1. Logical and (&amp;&amp;)</a></h2>
<h3 id="returns-true-if-both-statements-are-true"><a class="header" href="#returns-true-if-both-statements-are-true">Returns true if both statements are true</a></h3>
<h2 id="2-logical-or-"><a class="header" href="#2-logical-or-">2. Logical or (||)</a></h2>
<h3 id="returns-true-if-one-statements-is-true"><a class="header" href="#returns-true-if-one-statements-is-true">Returns true if one statements is true</a></h3>
<h2 id="3-logical-not-"><a class="header" href="#3-logical-not-">3. Logical not (!)</a></h2>
<h3 id="reverse-the-result-returns-false-if-the-result-is-true"><a class="header" href="#reverse-the-result-returns-false-if-the-result-is-true">Reverse the result, returns false if the result is true</a></h3>
<pre><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println(true &amp;&amp; true) // true
	fmt.Println(true &amp;&amp; false) // false

	fmt.Println(true || true) // true
	fmt.Println(false || false) // false

	fmt.Println(!true) // false
	fmt.Println(!false) // true
}
</code></pre>
<h2 id="frequently-asked-questions-4"><a class="header" href="#frequently-asked-questions-4">Frequently Asked Questions</a></h2>
<h3 id="1-what-is-the-difference-between--and--in-go"><a class="header" href="#1-what-is-the-difference-between--and--in-go">1. What is the difference between <code>&amp;&amp;</code> and <code>||</code> in Go?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li><code>&amp;&amp;</code> (Logical AND) returns true only if both conditions are true.</li>
<li><code>||</code> (Logical OR) returns true if at least one condition is true.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println(true &amp;&amp; false) // false
	fmt.Println(true || false) // true
}
</code></pre>
<h3 id="2-how-does-the--operator-work-in-go"><a class="header" href="#2-how-does-the--operator-work-in-go">2. How does the <code>!</code> operator work in Go?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>The <code>!</code> (Logical NOT) operator reverses the boolean value.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println(!true)  // false
	fmt.Println(!false) // true
}
</code></pre>
<h3 id="3-can-logical-operators-be-used-with-non-boolean-values"><a class="header" href="#3-can-logical-operators-be-used-with-non-boolean-values">3. Can logical operators be used with non-boolean values?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>No, logical operators in Go work only with boolean values.</li>
</ul>
<h3 id="4-how-can-i-combine-multiple-logical-operators-in-a-single-expression"><a class="header" href="#4-how-can-i-combine-multiple-logical-operators-in-a-single-expression">4. How can I combine multiple logical operators in a single expression?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>You can combine them using parentheses to control precedence.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println((true &amp;&amp; false) || true) // true
}
</code></pre>
<h3 id="5-what-is-the-precedence-of-logical-operators-in-go"><a class="header" href="#5-what-is-the-precedence-of-logical-operators-in-go">5. What is the precedence of logical operators in Go?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li><code>!</code> has the highest precedence, followed by <code>&amp;&amp;</code>, and then <code>||</code>.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println(!true || false &amp;&amp; true) // false
}
</code></pre>
<h3 id="6-how-can-i-use-logical-operators-in-conditional-statements"><a class="header" href="#6-how-can-i-use-logical-operators-in-conditional-statements">6. How can I use logical operators in conditional statements?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>Logical operators are often used in <code>if</code> statements to combine conditions.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	if true &amp;&amp; !false {
		fmt.Println("Condition met")
	}
}
</code></pre>
<h3 id="7-can-logical-operators-short-circuit-in-go"><a class="header" href="#7-can-logical-operators-short-circuit-in-go">7. Can logical operators short-circuit in Go?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>Yes, <code>&amp;&amp;</code> and <code>||</code> short-circuit. For example, <code>&amp;&amp;</code> stops evaluating if the first condition is false.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println(false &amp;&amp; (5 &gt; 3)) // false (5 &gt; 3 is not evaluated)
}
</code></pre>
<h3 id="8-how-can-i-debug-logical-expressions-in-go"><a class="header" href="#8-how-can-i-debug-logical-expressions-in-go">8. How can I debug logical expressions in Go?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>Use <code>fmt.Println</code> to print intermediate results.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	condition1 := true
	condition2 := false
	fmt.Println(condition1 &amp;&amp; condition2) // false
}
</code></pre>
<h3 id="9-can-logical-operators-be-used-in-loops"><a class="header" href="#9-can-logical-operators-be-used-in-loops">9. Can logical operators be used in loops?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>Yes, they can be used in loop conditions.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	for i := 0; i &lt; 10 &amp;&amp; i%2 == 0; i++ {
		fmt.Println(i)
	}
}
</code></pre>
<h3 id="10-what-happens-if-i-use-logical-operators-with-nil-values"><a class="header" href="#10-what-happens-if-i-use-logical-operators-with-nil-values">10. What happens if I use logical operators with nil values?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>Logical operators cannot be directly used with <code>nil</code>. You need to compare <code>nil</code> explicitly.</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
	var ptr *int = nil
	fmt.Println(ptr == nil || true) // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> e.g., interview-qa/topic_name
<strong>Tags:</strong> [go, concurrency, channels]
]</p>
<h1 id="while-loop"><a class="header" href="#while-loop">While Loop</a></h1>
<h2 id="unlike-other-programming-languages-go-doesnt-have-a-dedicated-keyword-for-a-while-loop-however-we-can-use-the-for-loop-to-perform-the-functionality-of-a-while-loop"><a class="header" href="#unlike-other-programming-languages-go-doesnt-have-a-dedicated-keyword-for-a-while-loop-however-we-can-use-the-for-loop-to-perform-the-functionality-of-a-while-loop">Unlike other programming languages, Go doesn't have a dedicated keyword for a while loop. However, we can use the for loop to perform the functionality of a while loop.</a></h2>
<pre><code class="language-go">// Program to print numbers between 0 and 10
package main
import ("fmt")

func main() {
  number := 0

  for number &lt;= 10 {
    fmt.Println(number)
    number++
  }
}
</code></pre>
<h2 id="frequently-asked-questions-5"><a class="header" href="#frequently-asked-questions-5">Frequently Asked Questions</a></h2>
<h3 id="1-how-can-we-implement-an-infinite-loop-in-go"><a class="header" href="#1-how-can-we-implement-an-infinite-loop-in-go">1. How can we implement an infinite loop in Go?</a></h3>
<p><strong>Answer:</strong> In Go, an infinite loop can be implemented using the <code>for</code> loop without any condition.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  for {
    fmt.Println("This is an infinite loop")
  }
}
</code></pre>
<h3 id="2-how-do-you-break-out-of-a-loop-in-go"><a class="header" href="#2-how-do-you-break-out-of-a-loop-in-go">2. How do you break out of a loop in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>break</code> statement to exit a loop prematurely.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  for i := 0; i &lt; 10; i++ {
    if i == 5 {
      break
    }
    fmt.Println(i)
  }
}
</code></pre>
<h3 id="3-how-do-you-skip-an-iteration-in-a-loop-in-go"><a class="header" href="#3-how-do-you-skip-an-iteration-in-a-loop-in-go">3. How do you skip an iteration in a loop in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>continue</code> statement to skip the current iteration and move to the next one.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  for i := 0; i &lt; 10; i++ {
    if i%2 == 0 {
      continue
    }
    fmt.Println(i)
  }
}
</code></pre>
<h3 id="4-can-we-use-labels-with-loops-in-go"><a class="header" href="#4-can-we-use-labels-with-loops-in-go">4. Can we use labels with loops in Go?</a></h3>
<p><strong>Answer:</strong> Yes, labels can be used to control nested loops.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
OuterLoop:
  for i := 0; i &lt; 3; i++ {
    for j := 0; j &lt; 3; j++ {
      if i == 1 &amp;&amp; j == 1 {
        break OuterLoop
      }
      fmt.Println(i, j)
    }
  }
}
</code></pre>
<h3 id="5-how-do-you-implement-a-do-while-loop-in-go"><a class="header" href="#5-how-do-you-implement-a-do-while-loop-in-go">5. How do you implement a do-while loop in Go?</a></h3>
<p><strong>Answer:</strong> Go does not have a <code>do-while</code> loop, but it can be simulated using a <code>for</code> loop.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  number := 0
  for {
    fmt.Println(number)
    number++
    if number &gt; 5 {
      break
    }
  }
}
</code></pre>
<h3 id="6-how-can-you-iterate-over-a-slice-in-go"><a class="header" href="#6-how-can-you-iterate-over-a-slice-in-go">6. How can you iterate over a slice in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>range</code> keyword to iterate over a slice.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  numbers := []int{1, 2, 3, 4, 5}
  for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
  }
}
</code></pre>
<h3 id="7-how-do-you-iterate-over-a-map-in-go"><a class="header" href="#7-how-do-you-iterate-over-a-map-in-go">7. How do you iterate over a map in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>range</code> keyword to iterate over a map.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  myMap := map[string]int{"a": 1, "b": 2, "c": 3}
  for key, value := range myMap {
    fmt.Printf("Key: %s, Value: %d\n", key, value)
  }
}
</code></pre>
<h3 id="8-how-do-you-iterate-over-a-string-in-go"><a class="header" href="#8-how-do-you-iterate-over-a-string-in-go">8. How do you iterate over a string in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>range</code> keyword to iterate over a string.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  str := "hello"
  for index, char := range str {
    fmt.Printf("Index: %d, Character: %c\n", index, char)
  }
}
</code></pre>
<h3 id="9-how-do-you-use-a-loop-to-calculate-the-factorial-of-a-number-in-go"><a class="header" href="#9-how-do-you-use-a-loop-to-calculate-the-factorial-of-a-number-in-go">9. How do you use a loop to calculate the factorial of a number in Go?</a></h3>
<p><strong>Answer:</strong> Use a <code>for</code> loop to calculate the factorial.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  number := 5
  factorial := 1
  for i := 1; i &lt;= number; i++ {
    factorial *= i
  }
  fmt.Println("Factorial:", factorial)
}
</code></pre>
<h3 id="10-how-do-you-use-a-loop-to-reverse-a-slice-in-go"><a class="header" href="#10-how-do-you-use-a-loop-to-reverse-a-slice-in-go">10. How do you use a loop to reverse a slice in Go?</a></h3>
<p><strong>Answer:</strong> Use a <code>for</code> loop to swap elements in the slice.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  numbers := []int{1, 2, 3, 4, 5}
  for i, j := 0, len(numbers)-1; i &lt; j; i, j = i+1, j-1 {
    numbers[i], numbers[j] = numbers[j], numbers[i]
  }
  fmt.Println("Reversed Slice:", numbers)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/maps
<strong>Tags:</strong> [go, maps, data-structure]
]</p>
<h1 id="maps"><a class="header" href="#maps">Maps</a></h1>
<p>Maps are a data structure which allow us to store data values in key:value pairs.
A map is an unordered and changeable collection that does not allow duplicates.
The default value of a map is <code>nil</code>.</p>
<pre><code class="language-go">userInfo := map[string]int{
    "huxn": 17,
    "alex": 18,
    "john": 27,
}

fmt.Println(userInfo)
userInfo["jordan"] = 15
fmt.Println(userInfo["huxn"])
fmt.Println(userInfo["alex"])
fmt.Println(userInfo["john"])
</code></pre>
<h2 id="frequently-asked-questions-6"><a class="header" href="#frequently-asked-questions-6">Frequently Asked Questions</a></h2>
<h3 id="1-how-do-you-create-a-map-in-go"><a class="header" href="#1-how-do-you-create-a-map-in-go">1. How do you create a map in Go?</a></h3>
<p><strong>Answer:</strong>
You can create a map using the <code>make</code> function or by using a map literal.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">// Using make function
userInfo := make(map[string]int)
userInfo["huxn"] = 17
userInfo["alex"] = 18
fmt.Println(userInfo)

// Using map literal
userInfo := map[string]int{
    "huxn": 17,
    "alex": 18,
}
fmt.Println(userInfo)
</code></pre>
<h3 id="2-how-do-you-check-if-a-key-exists-in-a-map"><a class="header" href="#2-how-do-you-check-if-a-key-exists-in-a-map">2. How do you check if a key exists in a map?</a></h3>
<p><strong>Answer:</strong>
You can use the second return value of a map lookup to check if a key exists.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">userInfo := map[string]int{
    "huxn": 17,
    "alex": 18,
}

value, exists := userInfo["huxn"]
if exists {
    fmt.Println("Key exists with value:", value)
} else {
    fmt.Println("Key does not exist")
}
</code></pre>
<h3 id="3-how-do-you-delete-a-key-from-a-map"><a class="header" href="#3-how-do-you-delete-a-key-from-a-map">3. How do you delete a key from a map?</a></h3>
<p><strong>Answer:</strong>
You can use the <code>delete</code> function to remove a key from a map.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">userInfo := map[string]int{
    "huxn": 17,
    "alex": 18,
}
delete(userInfo, "huxn")
fmt.Println(userInfo)
</code></pre>
<h3 id="4-can-a-map-key-be-of-any-type"><a class="header" href="#4-can-a-map-key-be-of-any-type">4. Can a map key be of any type?</a></h3>
<p><strong>Answer:</strong>
No, map keys must be of a type that is comparable (e.g., strings, integers, etc.).</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">// Valid keys
userInfo := map[string]int{
    "huxn": 17,
    "alex": 18,
}

// Invalid keys (e.g., slices)
// userInfo := map[[]int]int{} // This will throw an error
</code></pre>
<h3 id="5-how-do-you-iterate-over-a-map"><a class="header" href="#5-how-do-you-iterate-over-a-map">5. How do you iterate over a map?</a></h3>
<p><strong>Answer:</strong>
You can use a <code>for</code> loop with the <code>range</code> keyword to iterate over a map.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">userInfo := map[string]int{
    "huxn": 17,
    "alex": 18,
}

for key, value := range userInfo {
    fmt.Printf("Key: %s, Value: %d\n", key, value)
}
</code></pre>
<h3 id="6-what-is-the-zero-value-of-a-map"><a class="header" href="#6-what-is-the-zero-value-of-a-map">6. What is the zero value of a map?</a></h3>
<p><strong>Answer:</strong>
The zero value of a map is <code>nil</code>.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">var userInfo map[string]int
fmt.Println(userInfo == nil) // true
</code></pre>
<h3 id="7-can-you-compare-two-maps-in-go"><a class="header" href="#7-can-you-compare-two-maps-in-go">7. Can you compare two maps in Go?</a></h3>
<p><strong>Answer:</strong>
No, maps cannot be compared directly. You need to compare them manually by iterating over their keys and values.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">map1 := map[string]int{"huxn": 17, "alex": 18}
map2 := map[string]int{"huxn": 17, "alex": 18}

// Direct comparison is not allowed
// fmt.Println(map1 == map2) // This will throw an error

// Manual comparison
areEqual := true
for key, value := range map1 {
    if map2[key] != value {
        areEqual = false
        break
    }
}
fmt.Println("Maps are equal:", areEqual)
</code></pre>
<h3 id="8-how-do-you-find-the-length-of-a-map"><a class="header" href="#8-how-do-you-find-the-length-of-a-map">8. How do you find the length of a map?</a></h3>
<p><strong>Answer:</strong>
You can use the <code>len</code> function to find the number of key-value pairs in a map.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">userInfo := map[string]int{
    "huxn": 17,
    "alex": 18,
}
fmt.Println("Length of map:", len(userInfo))
</code></pre>
<h3 id="9-can-you-nest-maps-in-go"><a class="header" href="#9-can-you-nest-maps-in-go">9. Can you nest maps in Go?</a></h3>
<p><strong>Answer:</strong>
Yes, you can create a map where the value is another map.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">nestedMap := map[string]map[string]int{
    "group1": {
        "huxn": 17,
        "alex": 18,
    },
    "group2": {
        "john": 27,
    },
}
fmt.Println(nestedMap)
</code></pre>
<h3 id="10-how-do-you-copy-a-map-in-go"><a class="header" href="#10-how-do-you-copy-a-map-in-go">10. How do you copy a map in Go?</a></h3>
<p><strong>Answer:</strong>
You need to manually copy the key-value pairs from one map to another.</p>
<p><strong>Code Example:</strong></p>
<pre><code class="language-go">originalMap := map[string]int{
    "huxn": 17,
    "alex": 18,
}
copiedMap := make(map[string]int)

for key, value := range originalMap {
    copiedMap[key] = value
}
fmt.Println("Original Map:", originalMap)
fmt.Println("Copied Map:", copiedMap)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/operators
<strong>Tags:</strong> [go, operators, arithmetic, assignment]
]</p>
<h1 id="operators-are-used-to-perform-operations-on-variables-and-values"><a class="header" href="#operators-are-used-to-perform-operations-on-variables-and-values">Operators are used to perform operations on variables and values</a></h1>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<h3 id="1-addition-the--operator-adds-two-operands-for-example-xy"><a class="header" href="#1-addition-the--operator-adds-two-operands-for-example-xy">1. Addition: The + operator adds two operands. For example, x+y.</a></h3>
<h3 id="2-subtraction-the---operator-subtracts-two-operands-for-example-x-y"><a class="header" href="#2-subtraction-the---operator-subtracts-two-operands-for-example-x-y">2. Subtraction: The - operator subtracts two operands. For example, x-y.</a></h3>
<h3 id="3-multiplication-the--operator-multiplies-two-operands-for-example-xy"><a class="header" href="#3-multiplication-the--operator-multiplies-two-operands-for-example-xy">3. Multiplication: The * operator multiplies two operands. For example, x*y.</a></h3>
<h3 id="4-division-the--operator-divides-the-first-operand-by-the-second-for-example-xy"><a class="header" href="#4-division-the--operator-divides-the-first-operand-by-the-second-for-example-xy">4. Division: The / operator divides the first operand by the second. For example, x/y.</a></h3>
<h3 id="5-modulus-returns-the-division-remainder"><a class="header" href="#5-modulus-returns-the-division-remainder">5. Modulus: Returns the division remainder</a></h3>
<h3 id="6-increment-the--increases-the-value-of-a-variable-by-1"><a class="header" href="#6-increment-the--increases-the-value-of-a-variable-by-1">6. Increment: The ++ Increases the value of a variable by 1</a></h3>
<h3 id="7-decrement-the----decreases-the-value-of-a-variable-by-1"><a class="header" href="#7-decrement-the----decreases-the-value-of-a-variable-by-1">7. Decrement: The -- Decreases the value of a variable by 1</a></h3>
<pre><code class="language-go">package main
import "fmt"

func main() {
	fmt.Println(2 + 2) // 4
	fmt.Println(2 - 2) // 0
	fmt.Println(2 * 2) // 4
	fmt.Println(2 / 2) // 1
	fmt.Println(2 % 2) // 0
}
</code></pre>
<h3 id="increment"><a class="header" href="#increment">Increment</a></h3>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  x:= 10
  x++ // Add one new value (increment)
  fmt.Println(x)
}
</code></pre>
<h3 id="decrement"><a class="header" href="#decrement">Decrement</a></h3>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  x:= 10
  x-- // Remove one new value (decrement)
  fmt.Println(x)
}
</code></pre>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment Operators</a></h2>
<h3 id="assignment-operators-are-used-to-assign-values-to-variables"><a class="header" href="#assignment-operators-are-used-to-assign-values-to-variables">Assignment operators are used to assign values to variables.</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Example</th><th>Same As</th></tr></thead><tbody>
<tr><td>=</td><td>x = 5</td><td>x = 5</td></tr>
<tr><td>+=</td><td>x += 3</td><td>x = x + 3</td></tr>
<tr><td>-=</td><td>x -= 3</td><td>x = x - 3</td></tr>
<tr><td>*=</td><td>x *= 3</td><td>x = x * 3</td></tr>
<tr><td>/=</td><td>x /= 3</td><td>x = x / 3</td></tr>
<tr><td>%=</td><td>x %= 3</td><td>x = x % 3</td></tr>
</tbody></table>
</div>
<h2 id="questions-and-examples"><a class="header" href="#questions-and-examples">Questions and Examples</a></h2>
<h3 id="1-create-a-variable-named-lgnumber-store-1000-as-a-value-and-perform-various-operations"><a class="header" href="#1-create-a-variable-named-lgnumber-store-1000-as-a-value-and-perform-various-operations">1. Create a variable named <code>lgNumber</code>, store 1000 as a value, and perform various operations.</a></h3>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  lgNumber := 1000

  // Add that variable with itself
  sum := lgNumber + lgNumber
  fmt.Println("Addition:", sum) // 2000

  // Subtract that variable by itself
  difference := lgNumber - lgNumber
  fmt.Println("Subtraction:", difference) // 0

  // Multiply that variable with itself
  product := lgNumber * lgNumber
  fmt.Println("Multiplication:", product) // 1000000

  // Divide that variable with itself
  quotient := lgNumber / lgNumber
  fmt.Println("Division:", quotient) // 1
}
</code></pre>
<h2 id="frequently-asked-questions-7"><a class="header" href="#frequently-asked-questions-7">Frequently Asked Questions</a></h2>
<h3 id="1-how-do-you-perform-addition-and-subtraction-in-go"><a class="header" href="#1-how-do-you-perform-addition-and-subtraction-in-go">1. How do you perform addition and subtraction in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>+</code> operator for addition and <code>-</code> for subtraction.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    a, b := 10, 5
    fmt.Println("Addition:", a+b) // 15
    fmt.Println("Subtraction:", a-b) // 5
}
</code></pre>
<h3 id="2-how-do-you-calculate-the-remainder-of-a-division-in-go"><a class="header" href="#2-how-do-you-calculate-the-remainder-of-a-division-in-go">2. How do you calculate the remainder of a division in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>%</code> operator for modulus.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    fmt.Println("Remainder:", 10%3) // 1
}
</code></pre>
<h3 id="3-can-you-increment-a-variable-in-go"><a class="header" href="#3-can-you-increment-a-variable-in-go">3. Can you increment a variable in Go?</a></h3>
<p><strong>Answer:</strong> Yes, use <code>++</code> to increment a variable by 1.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    x := 5
    x++
    fmt.Println("Incremented Value:", x) // 6
}
</code></pre>
<h3 id="4-how-do-you-assign-and-add-a-value-to-a-variable-in-go"><a class="header" href="#4-how-do-you-assign-and-add-a-value-to-a-variable-in-go">4. How do you assign and add a value to a variable in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>+=</code> operator.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    x := 10
    x += 5
    fmt.Println("Updated Value:", x) // 15
}
</code></pre>
<h3 id="5-how-do-you-multiply-and-assign-a-value-to-a-variable-in-go"><a class="header" href="#5-how-do-you-multiply-and-assign-a-value-to-a-variable-in-go">5. How do you multiply and assign a value to a variable in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>*=</code> operator.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    x := 10
    x *= 2
    fmt.Println("Updated Value:", x) // 20
}
</code></pre>
<h3 id="6-how-do-you-divide-and-assign-a-value-to-a-variable-in-go"><a class="header" href="#6-how-do-you-divide-and-assign-a-value-to-a-variable-in-go">6. How do you divide and assign a value to a variable in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>/=</code> operator.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    x := 10
    x /= 2
    fmt.Println("Updated Value:", x) // 5
}
</code></pre>
<h3 id="7-how-do-you-decrement-a-variable-in-go"><a class="header" href="#7-how-do-you-decrement-a-variable-in-go">7. How do you decrement a variable in Go?</a></h3>
<p><strong>Answer:</strong> Use <code>--</code> to decrement a variable by 1.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    x := 5
    x--
    fmt.Println("Decremented Value:", x) // 4
}
</code></pre>
<h3 id="8-how-do-you-perform-multiple-arithmetic-operations-in-one-line"><a class="header" href="#8-how-do-you-perform-multiple-arithmetic-operations-in-one-line">8. How do you perform multiple arithmetic operations in one line?</a></h3>
<p><strong>Answer:</strong> Combine operators in a single expression.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    result := (10 + 5) * 2 - 3
    fmt.Println("Result:", result) // 27
}
</code></pre>
<h3 id="9-how-do-you-check-if-a-number-is-even-or-odd-in-go"><a class="header" href="#9-how-do-you-check-if-a-number-is-even-or-odd-in-go">9. How do you check if a number is even or odd in Go?</a></h3>
<p><strong>Answer:</strong> Use the modulus operator <code>%</code>.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    num := 7
    if num%2 == 0 {
        fmt.Println("Even")
    } else {
        fmt.Println("Odd")
    }
}
</code></pre>
<h3 id="10-how-do-you-swap-two-numbers-without-using-a-third-variable-in-go"><a class="header" href="#10-how-do-you-swap-two-numbers-without-using-a-third-variable-in-go">10. How do you swap two numbers without using a third variable in Go?</a></h3>
<p><strong>Answer:</strong> Use arithmetic operations.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    a, b := 5, 10
    a = a + b
    b = a - b
    a = a - b
    fmt.Println("Swapped Values:", a, b) // 10, 5
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-22
<strong>Category:</strong> interview-qa/Argument vs Parameter
<strong>Tags:</strong> [go, Parameter, Argument]
]</p>
<h2 id="difference-between-parameter-and-argument"><a class="header" href="#difference-between-parameter-and-argument">Difference between Parameter and Argument</a></h2>
<h3 id="parameter"><a class="header" href="#parameter">Parameter</a></h3>
<p>A <strong>parameter</strong> is a variable in the declaration of a function. It defines what kind of input a function will accept when it is called. It acts as a placeholder for the values that will be passed into the function.</p>
<h3 id="argument"><a class="header" href="#argument">Argument</a></h3>
<p>An <strong>argument</strong> is the actual value that is passed into the function when it is called. Arguments correspond to the parameters defined in the function signature. These are the real values provided to the function when executing the code.</p>
<h3 id="example-code-1"><a class="header" href="#example-code-1">Example Code</a></h3>
<pre><code class="language-go">package main

import "fmt"

// Function with parameters 'a' and 'b'
func add(a int, b int) int {
    return a + b
}

func main() {
    // Calling the function with arguments 5 and 3
    result := add(5, 3)
    fmt.Println("Result:", result) // Output: Result: 8
}
</code></pre>
<p>In the above example:</p>
<ul>
<li><code>a</code> and <code>b</code> are <strong>parameters</strong> of the <code>add</code> function.</li>
<li><code>5</code> and <code>3</code> are <strong>arguments</strong> passed to the <code>add</code> function when it is called in the <code>main</code> function.</li>
</ul>
<hr />
<h3 id="further-explanation"><a class="header" href="#further-explanation">Further Explanation</a></h3>
<p><strong>Parameters</strong> are declared within the function's signature. They provide the function with input values that can be used within the function's body.</p>
<p><strong>Arguments</strong> are provided when the function is called. The values of these arguments are assigned to the corresponding parameters, allowing the function to perform its operation based on those values.</p>
<h3 id="types-of-parameters"><a class="header" href="#types-of-parameters">Types of Parameters</a></h3>
<ul>
<li><strong>Formal Parameters</strong>: These are parameters that appear in the function definition. They are used to represent the expected values inside the function.</li>
<li><strong>Actual Parameters</strong>: These are arguments that are passed during the function call.</li>
</ul>
<hr />
<h3 id="interview-questions-and-answers-1"><a class="header" href="#interview-questions-and-answers-1">Interview Questions and Answers</a></h3>
<h4 id="1-what-is-the-difference-between-pass-by-value-and-pass-by-reference-in-function-arguments"><a class="header" href="#1-what-is-the-difference-between-pass-by-value-and-pass-by-reference-in-function-arguments">1. What is the difference between pass-by-value and pass-by-reference in function arguments?</a></h4>
<p><strong>Answer:</strong></p>
<ul>
<li><strong>Pass-by-value</strong>: The function gets a copy of the argument's value. Changes made to the parameter do not affect the original argument.</li>
<li><strong>Pass-by-reference</strong>: The function gets a reference (memory address) to the argument, so any changes made to the parameter directly affect the original argument.</li>
</ul>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

import "fmt"

// Pass-by-value
func modifyValue(x int) {
    x = 20
}

// Pass-by-reference
func modifyReference(x *int) {
    *x = 20
}

func main() {
    a := 10
    modifyValue(a)
    fmt.Println("After modifyValue:", a) // Output: 10 (no change)

    modifyReference(&amp;a)
    fmt.Println("After modifyReference:", a) // Output: 20 (value changed)
}
</code></pre>
<h4 id="2-how-do-you-handle-default-arguments-in-go"><a class="header" href="#2-how-do-you-handle-default-arguments-in-go">2. How do you handle default arguments in Go?</a></h4>
<p><strong>Answer:</strong>
Go does not support default arguments directly. Instead, you can achieve default values using variadic functions or by explicitly checking if a value is provided.</p>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

import "fmt"

func greet(name string, message string) {
    if message == "" {
        message = "Hello" // default message
    }
    fmt.Println(message, name)
}

func main() {
    greet("John", "")  // Output: Hello John
    greet("Jane", "Hi") // Output: Hi Jane
}
</code></pre>
<h4 id="3-what-is-a-variadic-function-and-how-is-it-used"><a class="header" href="#3-what-is-a-variadic-function-and-how-is-it-used">3. What is a variadic function, and how is it used?</a></h4>
<p><strong>Answer:</strong>
A <strong>variadic function</strong> is a function that takes a variable number of arguments. It is defined using <code>...</code> in the parameter list. This allows you to pass any number of arguments.</p>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

import "fmt"

func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2, 3)) // Output: 6
    fmt.Println(sum(10, 20, 30, 40)) // Output: 100
}
</code></pre>
<h4 id="4-what-will-happen-if-a-function-is-called-with-more-arguments-than-its-parameters"><a class="header" href="#4-what-will-happen-if-a-function-is-called-with-more-arguments-than-its-parameters">4. What will happen if a function is called with more arguments than its parameters?</a></h4>
<p><strong>Answer:</strong>
In Go, if the number of arguments passed to a function exceeds the number of parameters declared, the code will result in a compile-time error. Go checks the number of arguments and parameters at compile-time, and any mismatch in the number of arguments will cause an error.</p>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

import "fmt"

func greet(name string) {
    fmt.Println("Hello, ", name)
}

func main() {
    greet("John", "Doe") // Compile-time error: too many arguments
}
</code></pre>
<h4 id="5-can-you-return-multiple-values-from-a-function-in-go"><a class="header" href="#5-can-you-return-multiple-values-from-a-function-in-go">5. Can you return multiple values from a function in Go?</a></h4>
<p><strong>Answer:</strong>
Yes, Go allows a function to return multiple values. You can return multiple values of different types from a function.</p>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

import "fmt"

// Function returning two values
func divide(a, b int) (int, int) {
    return a / b, a % b
}

func main() {
    quotient, remainder := divide(10, 3)
    fmt.Println("Quotient:", quotient)   // Output: Quotient: 3
    fmt.Println("Remainder:", remainder) // Output: Remainder: 1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @jahidprog<br />
<strong>Date:</strong> 2025-04-26<br />
<strong>Category:</strong> interview-qa/pointers<br />
<strong>Tags:</strong> [go, pointers, memory-management, performance]</p>
<h1 id="pointers-in-golang"><a class="header" href="#pointers-in-golang">Pointers in Golang</a></h1>
<p>A pointer is a variable that stores the <strong>memory address</strong> of another variable. Pointers are used to:</p>
<ul>
<li>Avoid copying large amounts of data</li>
<li>Allow functions to modify the actual value of variables</li>
<li>Improve program performance</li>
</ul>
<p>We use pointers when we want to work with the <strong>actual data</strong> instead of working on copies.</p>
<h2 id="pointer-basics"><a class="header" href="#pointer-basics">Pointer Basics</a></h2>
<h3 id="1-how-to-declare-a-pointer"><a class="header" href="#1-how-to-declare-a-pointer">1. How to Declare a Pointer</a></h3>
<p>Use <code>*</code> before the type to declare a pointer.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    var num int = 42
    var ptr *int = &amp;num  // ptr holds the memory address of num
    fmt.Println("Address:", ptr)  // e.g., 0xc000018030
    fmt.Println("Value:", *ptr)   // 42 (dereferencing)
}
</code></pre>
<h3 id="2-zero-value-of-a-pointer"><a class="header" href="#2-zero-value-of-a-pointer">2. Zero Value of a Pointer</a></h3>
<p>Uninitialized pointers have a <code>nil</code> value.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    var ptr *int
    fmt.Println(ptr) // &lt;nil&gt;
}
</code></pre>
<h3 id="3-pointer-vs-normal-variable"><a class="header" href="#3-pointer-vs-normal-variable">3. Pointer vs Normal Variable</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Normal Variable</th><th>Pointer</th></tr></thead><tbody>
<tr><td>Storage</td><td>Holds value</td><td>Holds memory address</td></tr>
<tr><td>Modification</td><td>Works on copy</td><td>Modifies original data</td></tr>
</tbody></table>
</div>
<h2 id="frequently-asked-questions-8"><a class="header" href="#frequently-asked-questions-8">Frequently Asked Questions</a></h2>
<h3 id="1-what-is-a-pointer-in-go"><a class="header" href="#1-what-is-a-pointer-in-go">1. What is a pointer in Go?</a></h3>
<p><strong>Answer:</strong> A variable that stores the memory address of another variable.</p>
<pre><code class="language-go">var x int = 10
var ptr *int = &amp;x  // ptr points to x
</code></pre>
<h3 id="2-how-do-you-declare-a-pointer"><a class="header" href="#2-how-do-you-declare-a-pointer">2. How do you declare a pointer?</a></h3>
<p><strong>Answer:</strong> Use <code>*datatype</code>.</p>
<pre><code class="language-go">var ptr *string
</code></pre>
<h3 id="3-what-is-the-zero-value-of-a-pointer"><a class="header" href="#3-what-is-the-zero-value-of-a-pointer">3. What is the zero value of a pointer?</a></h3>
<p><strong>Answer:</strong> <code>nil</code>.</p>
<h3 id="4-how-is-a-pointer-different-from-a-normal-variable"><a class="header" href="#4-how-is-a-pointer-different-from-a-normal-variable">4. How is a pointer different from a normal variable?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>Normal variable: Stores value directly</li>
<li>Pointer: Stores memory address of another variable</li>
</ul>
<h3 id="5-does-go-support-pointer-arithmetic-like-c"><a class="header" href="#5-does-go-support-pointer-arithmetic-like-c">5. Does Go support pointer arithmetic like C?</a></h3>
<p><strong>Answer:</strong> No, Go deliberately omits pointer arithmetic for safety.</p>
<h3 id="6-how-to-pass-a-pointer-to-a-function"><a class="header" href="#6-how-to-pass-a-pointer-to-a-function">6. How to pass a pointer to a function?</a></h3>
<p><strong>Answer:</strong> Use <code>*type</code> parameter.</p>
<pre><code class="language-go">package main
import "fmt"

func modify(ptr *int) {
    *ptr = 100
}

func main() {
    x := 50
    modify(&amp;x)
    fmt.Println(x) // 100
}
</code></pre>
<h3 id="7-why-use-pointers-for-large-structs"><a class="header" href="#7-why-use-pointers-for-large-structs">7. Why use pointers for large structs?</a></h3>
<p><strong>Answer:</strong> Avoids expensive data copying.</p>
<pre><code class="language-go">type BigStruct struct { /* many fields */ }

func process(b *BigStruct) {
    // Operates on original struct
}
</code></pre>
<h3 id="8-how-to-create-a-pointer-to-a-struct"><a class="header" href="#8-how-to-create-a-pointer-to-a-struct">8. How to create a pointer to a struct?</a></h3>
<p><strong>Answer:</strong> Use <code>&amp;</code> operator.</p>
<pre><code class="language-go">user := User{Name: "Alice"}
userPtr := &amp;user
</code></pre>
<h3 id="9-can-you-have-a-pointer-to-a-pointer"><a class="header" href="#9-can-you-have-a-pointer-to-a-pointer">9. Can you have a pointer to a pointer?</a></h3>
<p><strong>Answer:</strong> Yes (double indirection).</p>
<pre><code class="language-go">a := 10
p1 := &amp;a
p2 := &amp;p1
fmt.Println(**p2) // 10
</code></pre>
<h3 id="10-how-to-check-if-a-pointer-is-nil"><a class="header" href="#10-how-to-check-if-a-pointer-is-nil">10. How to check if a pointer is nil?</a></h3>
<p><strong>Answer:</strong> Compare with <code>nil</code>.</p>
<pre><code class="language-go">if ptr == nil {
    fmt.Println("Pointer is nil")
}
</code></pre>
<h3 id="11-how-do-pointers-help-with-memory-efficiency"><a class="header" href="#11-how-do-pointers-help-with-memory-efficiency">11. How do pointers help with memory efficiency?</a></h3>
<p><strong>Answer:</strong> They allow sharing data without duplication.</p>
<pre><code class="language-go">largeData := make([]byte, 1e6) // 1MB data
processData(&amp;largeData)        // Pass address (8 bytes) instead of copying 1MB
</code></pre>
<h3 id="12-whats-the-difference-between--and-"><a class="header" href="#12-whats-the-difference-between--and-">12. What's the difference between <code>*</code> and <code>&amp;</code>?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li><code>&amp;</code> gets the address of a variable</li>
<li><code>*</code> dereferences a pointer to access the value</li>
</ul>
<pre><code class="language-go">x := 5
ptr := &amp;x  // ptr holds address of x
val := *ptr // val gets 5
</code></pre>
<h3 id="13-when-should-you-avoid-pointers"><a class="header" href="#13-when-should-you-avoid-pointers">13. When should you avoid pointers?</a></h3>
<p><strong>Answer:</strong></p>
<ul>
<li>With small data types (int, bool etc.) where copying is cheap</li>
<li>When immutability is desired</li>
<li>In concurrency scenarios where shared access could cause races</li>
</ul>
<h3 id="14-how-do-pointers-relate-to-gos-garbage-collection"><a class="header" href="#14-how-do-pointers-relate-to-gos-garbage-collection">14. How do pointers relate to Go's garbage collection?</a></h3>
<p><strong>Answer:</strong> The GC tracks pointers to determine object reachability. Unreachable objects (no pointers to them) get collected.</p>
<h3 id="15-can-you-use-pointers-with-interfaces"><a class="header" href="#15-can-you-use-pointers-with-interfaces">15. Can you use pointers with interfaces?</a></h3>
<p><strong>Answer:</strong> Yes, but the rules differ:</p>
<pre><code class="language-go">var w io.Writer
buf := new(bytes.Buffer)
w = buf  // No explicit pointer needed
</code></pre>
<hr />
<p><strong>Key Takeaways:</strong></p>
<ol>
<li>Pointers provide direct memory access</li>
<li>Use <code>&amp;</code> to get addresses, <code>*</code> to dereference</li>
<li>Essential for efficient large data handling</li>
<li>Go pointers are safer than C (no arithmetic)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-22
<strong>Category:</strong> interview-qa/Receiver Function
<strong>Tags:</strong> [go, Receiver Function]
]</p>
<h1 id="-receiver-function-in-go"><a class="header" href="#-receiver-function-in-go">üì¶ Receiver Function in Go</a></h1>
<p>A receiver function in Go is a method bound to a specific type‚Äîtypically a struct. It enables you to implement object-oriented behavior by defining methods on user-defined types.</p>
<hr />
<h2 id="-struct-and-receiver-basics"><a class="header" href="#-struct-and-receiver-basics">üß± Struct and Receiver Basics</a></h2>
<h3 id="struct-definition"><a class="header" href="#struct-definition">Struct Definition</a></h3>
<pre><code class="language-go">// User struct with basic fields
type User struct {
	Name string
	Age  int
}
</code></pre>
<hr />
<h2 id="-regular-function-vs-receiver-function"><a class="header" href="#-regular-function-vs-receiver-function">üìû Regular Function vs Receiver Function</a></h2>
<h3 id="regular-function"><a class="header" href="#regular-function">Regular Function</a></h3>
<pre><code class="language-go">func printUser(user User) {
	fmt.Println("User Name:", user.Name)
	fmt.Println("User Age:", user.Age)
}
</code></pre>
<p>This is a standalone function that takes <code>User</code> as a parameter.</p>
<h3 id="value-receiver-method"><a class="header" href="#value-receiver-method">Value Receiver Method</a></h3>
<pre><code class="language-go">func (u User) printDetails() {
	fmt.Println("Name:", u.Name)
	fmt.Println("Age:", u.Age)
}
</code></pre>
<p>Here, <code>printDetails()</code> is associated with <code>User</code> type using a value receiver. It works on a copy, so original data won‚Äôt change.</p>
<h3 id="pointer-receiver-method"><a class="header" href="#pointer-receiver-method">Pointer Receiver Method</a></h3>
<pre><code class="language-go">func (u *User) updateAge(newAge int) {
	u.Age = newAge
}
</code></pre>
<p>This method modifies the original <code>User</code> struct because it uses a pointer receiver.</p>
<hr />
<h2 id="-main-function-with-usage"><a class="header" href="#-main-function-with-usage">‚úÖ Main Function with Usage</a></h2>
<pre><code class="language-go">func main() {
	user1 := User{Name: "John", Age: 30}
	user2 := User{Name: "Jane", Age: 25}

	// Regular function call
	printUser(user1)

	// Receiver function calls
	user1.printDetails()
	user2.printDetails()

	// Update age using pointer receiver
	user1.updateAge(35)
	fmt.Println("Updated Age of user1:", user1.Age)

	// Demonstrate value receiver (no change to original)
	user2.call(100)
	fmt.Println("User2's age after call():", user2.Age)
}
</code></pre>
<hr />
<h2 id="-additional-receiver-method"><a class="header" href="#-additional-receiver-method">üîç Additional Receiver Method</a></h2>
<pre><code class="language-go">// Value receiver that does not affect original struct
func (u User) call(age int) {
	u.Age = age
	fmt.Println("Inside call() - temporary age:", u.Age)
}
</code></pre>
<p>This will not change the actual <code>User.Age</code> outside the function.</p>
<hr />
<h2 id="-example-output"><a class="header" href="#-example-output">üß™ Example Output</a></h2>
<pre><code>User Name: John
User Age: 30
Name: John
Age: 30
Name: Jane
Age: 25
Updated Age of user1: 35
Inside call() - temporary age: 100
User2's age after call(): 25
</code></pre>
<hr />
<h2 id="-key-takeaways"><a class="header" href="#-key-takeaways">üí° Key Takeaways</a></h2>
<ul>
<li>‚úÖ Value receivers are good for read-only operations.</li>
<li>‚úÖ Pointer receivers are used when you want to modify the actual data.</li>
<li>‚úÖ Go supports object-like behavior through receiver functions.</li>
<li>‚úÖ Methods with pointer receivers can be called on both values and pointers.</li>
</ul>
<h2 id="10-interview-questions-and-answers"><a class="header" href="#10-interview-questions-and-answers">10 Interview Questions and Answers</a></h2>
<ol>
<li>
<p><strong>What is a receiver function in Go?</strong></p>
<ul>
<li>A receiver function is a method associated with a specific type, allowing you to define methods on structs or other types.</li>
</ul>
</li>
<li>
<p><strong>What is the difference between a value receiver and a pointer receiver?</strong></p>
<ul>
<li>A value receiver operates on a copy of the object, while a pointer receiver operates on the actual object, allowing modifications.</li>
</ul>
</li>
<li>
<p><strong>Can you define multiple receiver functions for the same type?</strong></p>
<ul>
<li>Yes, you can define multiple receiver functions for the same type.</li>
</ul>
</li>
<li>
<p><strong>What is the syntax for defining a receiver function?</strong></p>
<ul>
<li><code>func (receiverType TypeName) methodName(parameters) {}</code></li>
</ul>
</li>
<li>
<p><strong>Can receiver functions be used with built-in types?</strong></p>
<ul>
<li>No, receiver functions can only be defined for user-defined types.</li>
</ul>
</li>
<li>
<p><strong>What happens if you call a value receiver function on a pointer?</strong></p>
<ul>
<li>Go automatically dereferences the pointer, so the function works as expected.</li>
</ul>
</li>
<li>
<p><strong>What is the purpose of receiver functions?</strong></p>
<ul>
<li>They enable object-oriented programming by associating methods with types.</li>
</ul>
</li>
<li>
<p><strong>Can a receiver function modify the original object?</strong></p>
<ul>
<li>Only if it uses a pointer receiver.</li>
</ul>
</li>
<li>
<p><strong>What is the difference between a regular function and a receiver function?</strong></p>
<ul>
<li>A regular function is not associated with any type, while a receiver function is tied to a specific type.</li>
</ul>
</li>
<li>
<p><strong>Can you use receiver functions with interfaces?</strong></p>
<ul>
<li>Yes, receiver functions are often used to implement interface methods.</li>
</ul>
</li>
</ol>
<h2 id="example-output"><a class="header" href="#example-output">Example Output</a></h2>
<pre><code>User Name: John
User Age: 30
User Name: Jane
User Age: 25
User Age: 10
User Age: 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-22
<strong>Category:</strong> interview-qa/Scope
<strong>Tags:</strong> [go, Scope]
]</p>
<h1 id="go-language-understanding-scope"><a class="header" href="#go-language-understanding-scope">Go Language: Understanding Scope</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In Go (Golang), <strong>scope</strong> refers to the region in the code where a variable, function, or constant is accessible. The scope determines the visibility and lifetime of variables and functions, which is essential for understanding how the Go compiler handles symbol resolution.</p>
<p>There are several types of scopes in Go:</p>
<ol>
<li><strong>Package Scope</strong>: Variables or functions defined at the package level.</li>
<li><strong>Function Scope</strong>: Variables defined within a function.</li>
<li><strong>Block Scope</strong>: Variables defined inside a block of code, such as within loops, if-statements, etc.</li>
<li><strong>Global Scope</strong>: Variables or functions accessible throughout the entire program.</li>
</ol>
<p>This document will explore these different types of scope with code examples and will also cover common pitfalls and best practices related to variable scope in Go.</p>
<h2 id="types-of-scope-in-go"><a class="header" href="#types-of-scope-in-go">Types of Scope in Go</a></h2>
<h3 id="1-package-scope"><a class="header" href="#1-package-scope">1. Package Scope</a></h3>
<p>In Go, the package scope refers to variables or functions that are accessible throughout the package in which they are declared. They can be accessed from any function within the package.</p>
<h4 id="example-package-scope"><a class="header" href="#example-package-scope">Example: Package Scope</a></h4>
<pre><code class="language-go">package main

import "fmt"

// Global variable (Package Scope)
var globalVar = 10

func printGlobalVar() {
    // Accessing package-scoped variable
    fmt.Println("Global Variable:", globalVar)
}

func main() {
    printGlobalVar() // Output: Global Variable: 10
}
</code></pre>
<p>In the above example, <code>globalVar</code> is accessible within the <code>main</code> and <code>printGlobalVar</code> functions because it is defined at the package level.</p>
<h3 id="2-function-scope"><a class="header" href="#2-function-scope">2. Function Scope</a></h3>
<p>Variables declared inside a function are local to that function and cannot be accessed outside of it. This is called <strong>function scope</strong>.</p>
<h4 id="example-function-scope"><a class="header" href="#example-function-scope">Example: Function Scope</a></h4>
<pre><code class="language-go">package main

import "fmt"

func myFunction() {
    // Variable inside the function
    var functionVar = "I am local to the function"
    fmt.Println(functionVar) // Output: I am local to the function
}

func main() {
    // Un-commenting the next line would cause an error
    // fmt.Println(functionVar) // Error: undefined functionVar
    myFunction()
}
</code></pre>
<p>In the example above, the variable <code>functionVar</code> is only available inside the <code>myFunction()</code> and cannot be accessed from <code>main()</code>.</p>
<h3 id="3-block-scope"><a class="header" href="#3-block-scope">3. Block Scope</a></h3>
<p>Block scope refers to variables declared inside a block of code, such as within <code>if</code> statements, loops, or other code blocks.</p>
<h4 id="example-block-scope"><a class="header" href="#example-block-scope">Example: Block Scope</a></h4>
<pre><code class="language-go">package main

import "fmt"

func main() {
    if true {
        // Variable inside the block
        var blockVar = "I exist only within this block"
        fmt.Println(blockVar) // Output: I exist only within this block
    }
    // Un-commenting the next line would cause an error
    // fmt.Println(blockVar) // Error: undefined blockVar
}
</code></pre>
<p>The variable <code>blockVar</code> is only accessible within the <code>if</code> block where it is declared. Attempting to use it outside the block will result in a compile-time error.</p>
<h3 id="4-global-scope-cross-package-scope"><a class="header" href="#4-global-scope-cross-package-scope">4. Global Scope (Cross-package Scope)</a></h3>
<p>In Go, global variables (package-level variables) can be shared across multiple files within the same package, but they cannot be accessed by other packages unless explicitly exported.</p>
<h4 id="example-cross-file-scope"><a class="header" href="#example-cross-file-scope">Example: Cross-file Scope</a></h4>
<pre><code class="language-go">// file1.go
package main

import "fmt"

var sharedVar = "This is a shared variable"

func displaySharedVar() {
    fmt.Println(sharedVar)
}

// file2.go
package main

func main() {
    displaySharedVar() // Output: This is a shared variable
}
</code></pre>
<p>In this case, the variable <code>sharedVar</code> is accessible across multiple files because it is within the same package.</p>
<h2 id="rules-of-scope-in-go"><a class="header" href="#rules-of-scope-in-go">Rules of Scope in Go</a></h2>
<ol>
<li><strong>Variable Shadowing</strong>: When a local variable has the same name as a variable in an outer scope, the local variable "shadows" the outer variable.</li>
<li><strong>Exported Variables</strong>: Variables that start with an uppercase letter are exported and accessible from other packages. Lowercase variables are private to the package.</li>
<li><strong>Short Declaration</strong>: The <code>:=</code> operator can be used for declaring and initializing variables in a more concise manner within functions or blocks.</li>
</ol>
<h2 id="common-pitfalls-in-scope"><a class="header" href="#common-pitfalls-in-scope">Common Pitfalls in Scope</a></h2>
<ol>
<li>
<p><strong>Variable Shadowing</strong>: When a variable in an inner scope has the same name as a variable in an outer scope, the inner variable shadows the outer one. This can lead to unintended behavior.</p>
<pre><code class="language-go">package main

import "fmt"

var x = 10

func main() {
    var x = 20 // Shadows outer x
    fmt.Println(x) // Output: 20
}

fmt.Println(x) // Output: 10
</code></pre>
</li>
<li>
<p><strong>Accessing Unexported Variables</strong>: If a variable is declared with a lowercase first letter, it is not accessible from other packages.</p>
<pre><code class="language-go">package main

import "fmt"

var unexportedVar = "I am private"

func main() {
    fmt.Println(unexportedVar) // Accessible within the same package
}
</code></pre>
</li>
</ol>
<h2 id="5-interview-questions-with-code"><a class="header" href="#5-interview-questions-with-code">5 Interview Questions with Code</a></h2>
<h3 id="q1-what-is-the-scope-of-a-variable-declared-inside-a-for-loop"><a class="header" href="#q1-what-is-the-scope-of-a-variable-declared-inside-a-for-loop">Q1: What is the scope of a variable declared inside a for loop?</a></h3>
<h4 id="code"><a class="header" href="#code">Code:</a></h4>
<pre><code class="language-go">package main

import "fmt"

func main() {
    for i := 0; i &lt; 3; i++ {
        var loopVar = "Loop variable"
        fmt.Println(loopVar)
    }
    // Uncommenting the line below will cause an error because loopVar is out of scope
    // fmt.Println(loopVar) // Error: undefined loopVar
}
</code></pre>
<p><strong>Answer</strong>: The variable <code>loopVar</code> is scoped to the <code>for</code> loop and cannot be accessed outside of it.</p>
<h3 id="q2-what-happens-if-you-declare-a-variable-with-the-same-name-in-different-scopes"><a class="header" href="#q2-what-happens-if-you-declare-a-variable-with-the-same-name-in-different-scopes">Q2: What happens if you declare a variable with the same name in different scopes?</a></h3>
<h4 id="code-1"><a class="header" href="#code-1">Code:</a></h4>
<pre><code class="language-go">package main

import "fmt"

var x = 10

func main() {
    fmt.Println(x) // Output: 10
    var x = 20 // Shadows the outer x
    fmt.Println(x) // Output: 20
}
</code></pre>
<p><strong>Answer</strong>: The inner variable <code>x</code> shadows the outer one within the scope of the <code>main()</code> function.</p>
<h3 id="q3-how-does-the--operator-work-in-go-with-variable-scope"><a class="header" href="#q3-how-does-the--operator-work-in-go-with-variable-scope">Q3: How does the <code>:=</code> operator work in Go with variable scope?</a></h3>
<h4 id="code-2"><a class="header" href="#code-2">Code:</a></h4>
<pre><code class="language-go">package main

import "fmt"

func main() {
    var a = 5
    fmt.Println(a) // Output: 5
    a := 10 // Short declaration: Creates a new a variable within main's scope
    fmt.Println(a) // Output: 10
}
</code></pre>
<p><strong>Answer</strong>: The <code>:=</code> operator creates a new variable in the local scope, shadowing the outer variable <code>a</code>.</p>
<h3 id="q4-how-does-go-handle-global-scope-variables-across-multiple-files"><a class="header" href="#q4-how-does-go-handle-global-scope-variables-across-multiple-files">Q4: How does Go handle global scope variables across multiple files?</a></h3>
<h4 id="code-3"><a class="header" href="#code-3">Code:</a></h4>
<pre><code class="language-go">// file1.go
package main

import "fmt"

var globalVar = "Global variable"

func displayGlobalVar() {
    fmt.Println(globalVar)
}

// file2.go
package main

func main() {
    displayGlobalVar() // Output: Global variable
}
</code></pre>
<p><strong>Answer</strong>: The variable <code>globalVar</code> is accessible across multiple files within the same package.</p>
<h3 id="q5-what-is-the-significance-of-variable-naming-conventions-in-go"><a class="header" href="#q5-what-is-the-significance-of-variable-naming-conventions-in-go">Q5: What is the significance of variable naming conventions in Go?</a></h3>
<h4 id="code-4"><a class="header" href="#code-4">Code:</a></h4>
<pre><code class="language-go">package main

import "fmt"

// Exported variable (visible outside the package)
var ExportedVar = "I am exported"

// Unexported variable (private to the package)
var unexportedVar = "I am unexported"

func main() {
    fmt.Println(ExportedVar) // Accessible
    fmt.Println(unexportedVar) // Accessible within the same package
}
</code></pre>
<p><strong>Answer</strong>: In Go, variables that start with an uppercase letter are exported and can be accessed outside the package, while variables that start with a lowercase letter are unexported and private to the package.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/slices
<strong>Tags:</strong> [go, slices, arrays, make]</p>
<h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<p>Slices are also used to store multiple values of the same type in a single variable, however unlike arrays, the length of a slice can grow and shrink as you see fit.</p>
<p>There are several ways to create a slice üëá</p>
<ol>
<li>Using the <code>[]datatype{values}</code> format</li>
<li>Create a slice from an array</li>
<li>Using the <code>make()</code> function</li>
</ol>
<pre><code class="language-go">// name := []datatype{values}
// name := []int{}
package main
import ("fmt")

func main() {
  myslice1 := []int{}
  fmt.Println(len(myslice1))
  fmt.Println(cap(myslice1))
  fmt.Println(myslice1)

  myslice2 := []string{"Go", "Slices", "Are", "Powerful"}
  fmt.Println(len(myslice2))
  fmt.Println(cap(myslice2))
  fmt.Println(myslice2)
}
</code></pre>
<h2 id="make-method"><a class="header" href="#make-method">Make() Method</a></h2>
<p>The <code>make</code> function will create a zeroed array and return a slice referencing an array. This is a great way to create a dynamically sized array. To create a slice using the <code>make</code> function, we need to specify three arguments: type, length, and capacity.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    slice := make([]string, 3, 5)
    fmt.Println("Length", len(slice))
    fmt.Println("Capacity", cap(slice))
    fmt.Println(slice)
}
</code></pre>
<h2 id="frequently-asked-questions-9"><a class="header" href="#frequently-asked-questions-9">Frequently Asked Questions</a></h2>
<h3 id="1-how-do-you-create-an-empty-slice-in-go"><a class="header" href="#1-how-do-you-create-an-empty-slice-in-go">1. How do you create an empty slice in Go?</a></h3>
<p><strong>Answer:</strong> Use <code>[]datatype{}</code> to create an empty slice.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    myslice := []int{}
    fmt.Println("Empty Slice:", myslice) // []
}
</code></pre>
<h3 id="2-how-do-you-create-a-slice-with-initial-values"><a class="header" href="#2-how-do-you-create-a-slice-with-initial-values">2. How do you create a slice with initial values?</a></h3>
<p><strong>Answer:</strong> Use <code>[]datatype{values}</code>.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    myslice := []int{1, 2, 3}
    fmt.Println("Slice with Values:", myslice) // [1 2 3]
}
</code></pre>
<h3 id="3-how-do-you-create-a-slice-from-an-array"><a class="header" href="#3-how-do-you-create-a-slice-from-an-array">3. How do you create a slice from an array?</a></h3>
<p><strong>Answer:</strong> Use slicing syntax <code>array[start:end]</code>.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    myslice := arr[1:4]
    fmt.Println("Slice from Array:", myslice) // [2 3 4]
}
</code></pre>
<h3 id="4-how-do-you-use-the-make-function-to-create-a-slice"><a class="header" href="#4-how-do-you-use-the-make-function-to-create-a-slice">4. How do you use the <code>make</code> function to create a slice?</a></h3>
<p><strong>Answer:</strong> Use <code>make(type, length, capacity)</code>.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    myslice := make([]int, 3, 5)
    fmt.Println("Slice with Make:", myslice) // [0 0 0]
}
</code></pre>
<h3 id="5-how-do-you-append-elements-to-a-slice"><a class="header" href="#5-how-do-you-append-elements-to-a-slice">5. How do you append elements to a slice?</a></h3>
<p><strong>Answer:</strong> Use the <code>append</code> function.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    myslice := []int{1, 2, 3}
    myslice = append(myslice, 4, 5)
    fmt.Println("Appended Slice:", myslice) // [1 2 3 4 5]
}
</code></pre>
<h3 id="6-how-do-you-copy-one-slice-to-another"><a class="header" href="#6-how-do-you-copy-one-slice-to-another">6. How do you copy one slice to another?</a></h3>
<p><strong>Answer:</strong> Use the <code>copy</code> function.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    src := []int{1, 2, 3}
    dest := make([]int, len(src))
    copy(dest, src)
    fmt.Println("Copied Slice:", dest) // [1 2 3]
}
</code></pre>
<h3 id="7-how-do-you-find-the-length-and-capacity-of-a-slice"><a class="header" href="#7-how-do-you-find-the-length-and-capacity-of-a-slice">7. How do you find the length and capacity of a slice?</a></h3>
<p><strong>Answer:</strong> Use <code>len(slice)</code> and <code>cap(slice)</code>.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    myslice := []int{1, 2, 3}
    fmt.Println("Length:", len(myslice)) // 3
    fmt.Println("Capacity:", cap(myslice)) // 3
}
</code></pre>
<h3 id="8-how-do-you-create-a-multidimensional-slice"><a class="header" href="#8-how-do-you-create-a-multidimensional-slice">8. How do you create a multidimensional slice?</a></h3>
<p><strong>Answer:</strong> Use slices of slices.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    fmt.Println("Multidimensional Slice:", matrix)
}
</code></pre>
<h3 id="9-how-do-you-remove-an-element-from-a-slice"><a class="header" href="#9-how-do-you-remove-an-element-from-a-slice">9. How do you remove an element from a slice?</a></h3>
<p><strong>Answer:</strong> Use slicing to exclude the element.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    myslice := []int{1, 2, 3, 4, 5}
    myslice = append(myslice[:2], myslice[3:]...)
    fmt.Println("Slice after Removal:", myslice) // [1 2 4 5]
}
</code></pre>
<h3 id="10-how-do-you-iterate-over-a-slice-in-go"><a class="header" href="#10-how-do-you-iterate-over-a-slice-in-go">10. How do you iterate over a slice in Go?</a></h3>
<p><strong>Answer:</strong> Use a <code>for</code> loop or <code>range</code>.</p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    myslice := []int{1, 2, 3}
    for i, v := range myslice {
        fmt.Printf("Index: %d, Value: %d\n", i, v)
    }
}
</code></pre>
<h2 id="-array-vs-slice"><a class="header" href="#-array-vs-slice">‚ö° Array vs Slice</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Array</th><th>Slice</th></tr></thead><tbody>
<tr><td>Size</td><td>Fixed</td><td>Dynamic (can grow/shrink)</td></tr>
<tr><td>Type</td><td>Value type</td><td>Reference type</td></tr>
<tr><td>Memory</td><td>All data copied on assignment</td><td>Just the slice descriptor copied (shallow copy)</td></tr>
<tr><td>Creation</td><td><code>var a [5]int</code></td><td><code>var s []int</code> or slicing an array</td></tr>
<tr><td>Common Usage</td><td>Rare (low-level memory control)</td><td>Very common</td></tr>
<tr><td>Performance</td><td>No hidden cost</td><td>Some overhead with dynamic growth</td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> interview-qa/strings
<strong>Tags:</strong> [go, strings, operations]]</p>
<h1 id="golang-strings"><a class="header" href="#golang-strings">GoLang Strings</a></h1>
<p>This document provides an overview of string operations in GoLang with examples.</p>
<h2 id="frequently-asked-questions-10"><a class="header" href="#frequently-asked-questions-10">Frequently Asked Questions</a></h2>
<h3 id="1-how-do-you-concatenate-strings-in-go"><a class="header" href="#1-how-do-you-concatenate-strings-in-go">1. How do you concatenate strings in Go?</a></h3>
<p>You can concatenate strings using the <code>+</code> operator.</p>
<pre><code class="language-go">fmt.Println("Hello, " + "World!")
</code></pre>
<h3 id="2-how-do-you-find-the-length-of-a-string-in-go"><a class="header" href="#2-how-do-you-find-the-length-of-a-string-in-go">2. How do you find the length of a string in Go?</a></h3>
<p>Use the <code>len</code> function to get the length of a string.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Println("Length:", len(message))
</code></pre>
<h3 id="3-how-do-you-extract-a-substring-in-go"><a class="header" href="#3-how-do-you-extract-a-substring-in-go">3. How do you extract a substring in Go?</a></h3>
<p>Use slice notation to extract substrings.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Println("Substring:", message[0:5]) // "Hello"
</code></pre>
<h3 id="4-how-do-you-compare-two-strings-in-go"><a class="header" href="#4-how-do-you-compare-two-strings-in-go">4. How do you compare two strings in Go?</a></h3>
<p>You can use <code>==</code> and <code>!=</code> operators or the <code>strings.Compare</code> function.</p>
<pre><code class="language-go">msg1 := "one"
msg2 := "two"
fmt.Println("Equal?", msg1 == msg2)
fmt.Println("Not Equal?", msg1 != msg2)
fmt.Println(strings.Compare(msg1, msg2))
</code></pre>
<h3 id="5-how-do-you-check-if-a-string-contains-a-substring"><a class="header" href="#5-how-do-you-check-if-a-string-contains-a-substring">5. How do you check if a string contains a substring?</a></h3>
<p>Use the <code>strings.Contains</code> function.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Println(strings.Contains(message, "World")) // true
</code></pre>
<h3 id="6-how-do-you-convert-a-string-to-uppercase-or-lowercase"><a class="header" href="#6-how-do-you-convert-a-string-to-uppercase-or-lowercase">6. How do you convert a string to uppercase or lowercase?</a></h3>
<p>Use <code>strings.ToUpper</code> and <code>strings.ToLower</code> functions.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Println(strings.ToUpper(message)) // "HELLO WORLD!"
fmt.Println(strings.ToLower(message)) // "hello world!"
</code></pre>
<h3 id="7-how-do-you-split-a-string-into-substrings"><a class="header" href="#7-how-do-you-split-a-string-into-substrings">7. How do you split a string into substrings?</a></h3>
<p>Use the <code>strings.Split</code> function.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Println(strings.Split(message, " ")) // ["Hello", "World!"]
</code></pre>
<h3 id="8-how-do-you-replace-a-substring-in-a-string"><a class="header" href="#8-how-do-you-replace-a-substring-in-a-string">8. How do you replace a substring in a string?</a></h3>
<p>Use the <code>strings.Replace</code> function.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Println(strings.Replace(message, "World", "Go", 1)) // "Hello Go!"
</code></pre>
<h3 id="9-how-do-you-trim-spaces-from-a-string"><a class="header" href="#9-how-do-you-trim-spaces-from-a-string">9. How do you trim spaces from a string?</a></h3>
<p>Use the <code>strings.TrimSpace</code> function.</p>
<pre><code class="language-go">message := "  Hello World!  "
fmt.Println(strings.TrimSpace(message)) // "Hello World!"
</code></pre>
<h3 id="10-how-do-you-get-the-first-character-of-a-string"><a class="header" href="#10-how-do-you-get-the-first-character-of-a-string">10. How do you get the first character of a string?</a></h3>
<p>Use indexing to access the first character.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Printf("First character: %c\n", message[0])
</code></pre>
<h2 id="basic-string-operations"><a class="header" href="#basic-string-operations">Basic String Operations</a></h2>
<h3 id="concatenation"><a class="header" href="#concatenation">Concatenation</a></h3>
<p>You can concatenate strings using the <code>+</code> operator.</p>
<pre><code class="language-go">fmt.Println("Hello, " + "World!")
</code></pre>
<h3 id="formatting-strings"><a class="header" href="#formatting-strings">Formatting Strings</a></h3>
<p>Go provides several ways to format strings using <code>fmt.Printf</code>.</p>
<pre><code class="language-go">message := "Hello World!"
fmt.Printf("Data: %v\n", message)
fmt.Printf("Data: %+v\n", message)
fmt.Printf("Data: %#v\n", message)
fmt.Printf("Data: %T\n", message)
fmt.Printf("Data: %q\n", message)
fmt.Printf("First character: %c\n", message[0])
</code></pre>
<h3 id="string-length"><a class="header" href="#string-length">String Length</a></h3>
<p>You can get the length of a string using the <code>len</code> function.</p>
<pre><code class="language-go">fmt.Println("Length:", len(message))
</code></pre>
<h3 id="substrings"><a class="header" href="#substrings">Substrings</a></h3>
<p>You can extract substrings using slice notation.</p>
<pre><code class="language-go">fmt.Println("Substring:", message[0:5]) // this will print "Hello"
</code></pre>
<h3 id="string-comparison"><a class="header" href="#string-comparison">String Comparison</a></h3>
<p>You can compare strings using <code>==</code> and <code>!=</code> operators or the <code>strings.Compare</code> function.</p>
<pre><code class="language-go">msg1 := "one"
msg2 := "two"

fmt.Println("Equal?", msg1 == msg2)
fmt.Println("Not Equal?", msg1 != msg2)
fmt.Println(strings.Compare(msg1, msg2))
</code></pre>
<h2 id="additional-string-functions"><a class="header" href="#additional-string-functions">Additional String Functions</a></h2>
<h3 id="contains"><a class="header" href="#contains">Contains</a></h3>
<p>Check if a string contains a substring.</p>
<pre><code class="language-go">fmt.Println(strings.Contains(message, "World")) // true
</code></pre>
<h3 id="toupper-and-tolower"><a class="header" href="#toupper-and-tolower">ToUpper and ToLower</a></h3>
<p>Convert strings to upper or lower case.</p>
<pre><code class="language-go">fmt.Println(strings.ToUpper(message)) // "HELLO WORLD!"
fmt.Println(strings.ToLower(message)) // "hello world!"
</code></pre>
<h3 id="split"><a class="header" href="#split">Split</a></h3>
<p>Split a string into a slice of substrings.</p>
<pre><code class="language-go">fmt.Println(strings.Split(message, " ")) // ["Hello", "World!"]
</code></pre>
<h3 id="replace"><a class="header" href="#replace">Replace</a></h3>
<p>Replace occurrences of a substring.</p>
<pre><code class="language-go">fmt.Println(strings.Replace(message, "World", "Go", 1)) // "Hello Go!"
</code></pre>
<h3 id="trim"><a class="header" href="#trim">Trim</a></h3>
<p>Trim leading and trailing spaces.</p>
<pre><code class="language-go">fmt.Println(strings.TrimSpace("  Hello World!  ")) // "Hello World!"
</code></pre>
<p>Refer to the <a href="https://golang.org/pkg/strings/">Go documentation</a> for more string functions and detailed usage.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> e.g., interview-qa/topic_name
<strong>Tags:</strong> [go, concurrency, channels]
]</p>
<h1 id="structs-structures"><a class="header" href="#structs-structures">Structs (Structures)</a></h1>
<p>A struct is used to create a collection of members of different data types, into a single variable.</p>
<pre><code class="language-go">package main
import ("fmt")

type Person struct {
  name string
  age int
  job string
  salary int
}

func main() {
  var userOne Person

  userOne.name = "HuXn"
  userOne.age = 18
  userOne.job = "Programmer"
  userOne.salary = 40000

  fmt.Println(userOne)
  fmt.Println("My name is", userOne.name, "I'm", userOne.age, "Years old", "My Profession is", userOne.job, "My salary is", userOne.salary)
}
</code></pre>
<h2 id="frequently-asked-questions-faq"><a class="header" href="#frequently-asked-questions-faq">Frequently Asked Questions (FAQ)</a></h2>
<h3 id="1-what-is-a-struct-in-go"><a class="header" href="#1-what-is-a-struct-in-go">1. What is a struct in Go?</a></h3>
<p><strong>Answer:</strong> A struct is a composite data type in Go that groups together variables under a single name. These variables can be of different types.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Person struct {
  name string
  age int
}

func main() {
  p := Person{name: "Alice", age: 30}
  fmt.Println(p)
}
</code></pre>
<h3 id="2-how-do-you-define-and-initialize-a-struct-in-go"><a class="header" href="#2-how-do-you-define-and-initialize-a-struct-in-go">2. How do you define and initialize a struct in Go?</a></h3>
<p><strong>Answer:</strong> You can define a struct using the <code>type</code> keyword and initialize it using a struct literal.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Car struct {
  brand string
  year  int
}

func main() {
  c := Car{brand: "Toyota", year: 2020}
  fmt.Println(c)
}
</code></pre>
<h3 id="3-can-you-create-an-anonymous-struct-in-go"><a class="header" href="#3-can-you-create-an-anonymous-struct-in-go">3. Can you create an anonymous struct in Go?</a></h3>
<p><strong>Answer:</strong> Yes, you can create an anonymous struct without defining a named type.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">func main() {
  person := struct {
    name string
    age  int
  }{
    name: "John",
    age: 25,
  }
  fmt.Println(person)
}
</code></pre>
<h3 id="4-how-do-you-access-and-modify-struct-fields-in-go"><a class="header" href="#4-how-do-you-access-and-modify-struct-fields-in-go">4. How do you access and modify struct fields in Go?</a></h3>
<p><strong>Answer:</strong> You can access and modify struct fields using the dot <code>.</code> operator.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Book struct {
  title  string
  author string
}

func main() {
  b := Book{title: "Go Programming", author: "John Doe"}
  b.title = "Advanced Go Programming"
  fmt.Println(b)
}
</code></pre>
<h3 id="5-can-structs-have-methods-in-go"><a class="header" href="#5-can-structs-have-methods-in-go">5. Can structs have methods in Go?</a></h3>
<p><strong>Answer:</strong> Yes, you can define methods for structs.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Rectangle struct {
  width, height float64
}

func (r Rectangle) Area() float64 {
  return r.width * r.height
}

func main() {
  rect := Rectangle{width: 10, height: 5}
  fmt.Println("Area:", rect.Area())
}
</code></pre>
<h3 id="6-what-is-the-difference-between-value-and-pointer-receivers-in-struct-methods"><a class="header" href="#6-what-is-the-difference-between-value-and-pointer-receivers-in-struct-methods">6. What is the difference between value and pointer receivers in struct methods?</a></h3>
<p><strong>Answer:</strong> Value receivers operate on a copy of the struct, while pointer receivers operate on the original struct.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Counter struct {
  count int
}

func (c *Counter) Increment() {
  c.count++
}

func main() {
  c := Counter{}
  c.Increment()
  fmt.Println(c.count)
}
</code></pre>
<h3 id="7-can-structs-embed-other-structs-in-go"><a class="header" href="#7-can-structs-embed-other-structs-in-go">7. Can structs embed other structs in Go?</a></h3>
<p><strong>Answer:</strong> Yes, Go supports struct embedding for composition.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Address struct {
  city, state string
}

type Person struct {
  name    string
  address Address
}

func main() {
  p := Person{name: "Alice", address: Address{city: "New York", state: "NY"}}
  fmt.Println(p)
}
</code></pre>
<h3 id="8-how-do-you-compare-two-structs-in-go"><a class="header" href="#8-how-do-you-compare-two-structs-in-go">8. How do you compare two structs in Go?</a></h3>
<p><strong>Answer:</strong> You can compare structs using the <code>==</code> operator if all fields are comparable.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Point struct {
  x, y int
}

func main() {
  p1 := Point{x: 1, y: 2}
  p2 := Point{x: 1, y: 2}
  fmt.Println(p1 == p2) // true
}
</code></pre>
<h3 id="9-can-you-use-structs-as-map-keys-in-go"><a class="header" href="#9-can-you-use-structs-as-map-keys-in-go">9. Can you use structs as map keys in Go?</a></h3>
<p><strong>Answer:</strong> Yes, structs can be used as map keys if all their fields are comparable.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">type Point struct {
  x, y int
}

func main() {
  m := make(map[Point]string)
  m[Point{x: 1, y: 2}] = "A Point"
  fmt.Println(m)
}
</code></pre>
<h3 id="10-how-do-you-iterate-over-struct-fields-in-go"><a class="header" href="#10-how-do-you-iterate-over-struct-fields-in-go">10. How do you iterate over struct fields in Go?</a></h3>
<p><strong>Answer:</strong> You can use the <code>reflect</code> package to iterate over struct fields.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">import (
  "fmt"
  "reflect"
)

type Person struct {
  Name string
  Age  int
}

func main() {
  p := Person{Name: "Alice", Age: 30}
  v := reflect.ValueOf(p)
  for i := 0; i &lt; v.NumField(); i++ {
    fmt.Println(v.Type().Field(i).Name, v.Field(i))
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> e.g., interview-qa/topic_name
<strong>Tags:</strong> [go, concurrency, channels]
]</p>
<h1 id="the-switch-statement"><a class="header" href="#the-switch-statement">The switch Statement</a></h1>
<h2 id="the-switch-statement-allows-us-to-execute-one-code-block-among-many-alternatives"><a class="header" href="#the-switch-statement-allows-us-to-execute-one-code-block-among-many-alternatives">The switch statement allows us to execute one code block among many alternatives.</a></h2>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  day := 8

  switch day {
  case 1:
    fmt.Println("Monday")
  case 2:
    fmt.Println("Tuesday")
  case 3:
    fmt.Println("Wednesday")
  case 4:
    fmt.Println("Thursday")
  case 5:
    fmt.Println("Friday")
  case 6:
    fmt.Println("Saturday")
  case 7:
    fmt.Println("Sunday")
  default:
    fmt.Println("Not a weekday")
  }
}
</code></pre>
<h2 id="frequently-asked-questions-11"><a class="header" href="#frequently-asked-questions-11">Frequently Asked Questions</a></h2>
<h3 id="1-what-is-a-switch-statement-in-go"><a class="header" href="#1-what-is-a-switch-statement-in-go">1. What is a <code>switch</code> statement in Go?</a></h3>
<p><strong>Answer:</strong> A <code>switch</code> statement is used to select one of many code blocks to execute. It is an alternative to using multiple <code>if-else</code> statements.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    num := 2
    switch num {
    case 1:
        fmt.Println("One")
    case 2:
        fmt.Println("Two")
    case 3:
        fmt.Println("Three")
    default:
        fmt.Println("Other number")
    }
}
</code></pre>
<h3 id="2-can-we-use-multiple-values-in-a-single-case"><a class="header" href="#2-can-we-use-multiple-values-in-a-single-case">2. Can we use multiple values in a single <code>case</code>?</a></h3>
<p><strong>Answer:</strong> Yes, multiple values can be grouped in a single <code>case</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    char := 'a'
    switch char {
    case 'a', 'e', 'i', 'o', 'u':
        fmt.Println("Vowel")
    default:
        fmt.Println("Consonant")
    }
}
</code></pre>
<h3 id="3-is-break-required-in-gos-switch-statement"><a class="header" href="#3-is-break-required-in-gos-switch-statement">3. Is <code>break</code> required in Go's <code>switch</code> statement?</a></h3>
<p><strong>Answer:</strong> No, <code>break</code> is not required as Go automatically breaks out of the <code>switch</code> after executing a <code>case</code>.</p>
<h3 id="4-how-to-use-fallthrough-in-a-switch-statement"><a class="header" href="#4-how-to-use-fallthrough-in-a-switch-statement">4. How to use <code>fallthrough</code> in a <code>switch</code> statement?</a></h3>
<p><strong>Answer:</strong> The <code>fallthrough</code> keyword forces the execution of the next <code>case</code> even if the condition does not match.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    num := 1
    switch num {
    case 1:
        fmt.Println("One")
        fallthrough
    case 2:
        fmt.Println("Two")
    default:
        fmt.Println("Default")
    }
}
</code></pre>
<h3 id="5-can-switch-work-without-an-expression"><a class="header" href="#5-can-switch-work-without-an-expression">5. Can <code>switch</code> work without an expression?</a></h3>
<p><strong>Answer:</strong> Yes, a <code>switch</code> can work without an expression, making it similar to a series of <code>if-else</code> statements.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    num := 10
    switch {
    case num &lt; 0:
        fmt.Println("Negative")
    case num == 0:
        fmt.Println("Zero")
    case num &gt; 0:
        fmt.Println("Positive")
    }
}
</code></pre>
<h3 id="6-can-we-use-a-switch-statement-with-strings"><a class="header" href="#6-can-we-use-a-switch-statement-with-strings">6. Can we use a <code>switch</code> statement with strings?</a></h3>
<p><strong>Answer:</strong> Yes, <code>switch</code> can be used with strings.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    color := "red"
    switch color {
    case "red":
        fmt.Println("Stop")
    case "yellow":
        fmt.Println("Caution")
    case "green":
        fmt.Println("Go")
    default:
        fmt.Println("Unknown color")
    }
}
</code></pre>
<h3 id="7-can-switch-handle-type-assertions"><a class="header" href="#7-can-switch-handle-type-assertions">7. Can <code>switch</code> handle type assertions?</a></h3>
<p><strong>Answer:</strong> Yes, <code>switch</code> can be used to handle type assertions.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    var x interface{} = 42
    switch v := x.(type) {
    case int:
        fmt.Printf("%d is an int\n", v)
    case string:
        fmt.Printf("%s is a string\n", v)
    default:
        fmt.Println("Unknown type")
    }
}
</code></pre>
<h3 id="8-can-switch-be-used-with-functions"><a class="header" href="#8-can-switch-be-used-with-functions">8. Can <code>switch</code> be used with functions?</a></h3>
<p><strong>Answer:</strong> Yes, you can use a function's return value in a <code>switch</code> statement.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func getNumber() int {
    return 3
}

func main() {
    switch getNumber() {
    case 1:
        fmt.Println("One")
    case 2:
        fmt.Println("Two")
    case 3:
        fmt.Println("Three")
    default:
        fmt.Println("Other number")
    }
}
</code></pre>
<h3 id="9-can-switch-be-nested"><a class="header" href="#9-can-switch-be-nested">9. Can <code>switch</code> be nested?</a></h3>
<p><strong>Answer:</strong> Yes, <code>switch</code> statements can be nested.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    num := 2
    switch num {
    case 1:
        fmt.Println("One")
    case 2:
        fmt.Println("Two")
        switch num {
        case 2:
            fmt.Println("Nested switch")
        }
    default:
        fmt.Println("Other number")
    }
}
</code></pre>
<h3 id="10-what-happens-if-no-case-matches-and-there-is-no-default"><a class="header" href="#10-what-happens-if-no-case-matches-and-there-is-no-default">10. What happens if no <code>case</code> matches and there is no <code>default</code>?</a></h3>
<p><strong>Answer:</strong> If no <code>case</code> matches and there is no <code>default</code>, the <code>switch</code> statement does nothing.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go">package main
import "fmt"

func main() {
    num := 5
    switch num {
    case 1:
        fmt.Println("One")
    case 2:
        fmt.Println("Two")
    }
    // No output
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-19
<strong>Category:</strong> e.g., interview-qa/topic_name
<strong>Tags:</strong> [go, concurrency, channels]
]</p>
<h1 id="variables-are-containers-for-storing-data-values"><a class="header" href="#variables-are-containers-for-storing-data-values">Variables are containers for storing data values</a></h1>
<h2 id="in-go-there-are-two-ways-to-declare-a-variable"><a class="header" href="#in-go-there-are-two-ways-to-declare-a-variable">In Go, there are two ways to declare a variable</a></h2>
<h3 id="1-use-the-var-keyword-followed-by-variable-name-and-type"><a class="header" href="#1-use-the-var-keyword-followed-by-variable-name-and-type">1. Use the var keyword, followed by variable name and type</a></h3>
<pre><code class="language-go">package main
import ("fmt")

var name = "John Doe" // Variable One

func main() {
  var fruit = "Apple" // Variable Two
  fmt.Println(name)
  fmt.Println(fruit)
}
</code></pre>
<h3 id="2-use-the--sign-followed-by-the-variable-value"><a class="header" href="#2-use-the--sign-followed-by-the-variable-value">2. Use the := sign, followed by the variable value</a></h3>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  varOne := 100
  varTwo := 2
  fmt.Println(varOne)
  fmt.Println(varTwo)
}
</code></pre>
<h2 id="frequently-asked-questions-faqs-1"><a class="header" href="#frequently-asked-questions-faqs-1">Frequently Asked Questions (FAQs)</a></h2>
<h3 id="1-how-do-you-declare-a-constant-variable-in-go"><a class="header" href="#1-how-do-you-declare-a-constant-variable-in-go">1. How do you declare a constant variable in Go?</a></h3>
<p><strong>Answer:</strong> Use the <code>const</code> keyword to declare a constant variable. Constants cannot be changed after they are declared.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  const pi = 3.14
  fmt.Println(pi)
}
</code></pre>
<h3 id="2-can-you-declare-multiple-variables-in-a-single-line"><a class="header" href="#2-can-you-declare-multiple-variables-in-a-single-line">2. Can you declare multiple variables in a single line?</a></h3>
<p><strong>Answer:</strong> Yes, you can declare multiple variables in a single line using the <code>var</code> keyword or <code>:=</code> syntax.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  var x, y, z int = 1, 2, 3
  fmt.Println(x, y, z)
}
</code></pre>
<h3 id="3-what-is-the-zero-value-of-a-variable-in-go"><a class="header" href="#3-what-is-the-zero-value-of-a-variable-in-go">3. What is the zero value of a variable in Go?</a></h3>
<p><strong>Answer:</strong> Variables in Go are automatically assigned a zero value if not explicitly initialized.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  var number int
  fmt.Println(number) // Output: 0
}
</code></pre>
<h3 id="4-how-do-you-declare-a-global-variable-in-go"><a class="header" href="#4-how-do-you-declare-a-global-variable-in-go">4. How do you declare a global variable in Go?</a></h3>
<p><strong>Answer:</strong> Declare the variable outside of any function.</p>
<pre><code class="language-go">package main
import ("fmt")

var globalVar = "I am global"

func main() {
  fmt.Println(globalVar)
}
</code></pre>
<h3 id="5-can-you-reassign-a-value-to-a-variable-declared-with-var"><a class="header" href="#5-can-you-reassign-a-value-to-a-variable-declared-with-var">5. Can you reassign a value to a variable declared with <code>var</code>?</a></h3>
<p><strong>Answer:</strong> Yes, variables declared with <code>var</code> can be reassigned.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  var name = "John"
  name = "Doe"
  fmt.Println(name)
}
</code></pre>
<h3 id="6-what-happens-if-you-declare-a-variable-but-do-not-use-it"><a class="header" href="#6-what-happens-if-you-declare-a-variable-but-do-not-use-it">6. What happens if you declare a variable but do not use it?</a></h3>
<p><strong>Answer:</strong> Go does not allow unused variables and will throw a compile-time error.</p>
<pre><code class="language-go">package main
func main() {
  var unusedVar = 10 // This will cause an error
}
</code></pre>
<h3 id="7-how-do-you-declare-a-variable-with-a-specific-type"><a class="header" href="#7-how-do-you-declare-a-variable-with-a-specific-type">7. How do you declare a variable with a specific type?</a></h3>
<p><strong>Answer:</strong> Use the <code>var</code> keyword followed by the type.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  var age int = 25
  fmt.Println(age)
}
</code></pre>
<h3 id="8-can-you-declare-a-variable-without-initializing-it"><a class="header" href="#8-can-you-declare-a-variable-without-initializing-it">8. Can you declare a variable without initializing it?</a></h3>
<p><strong>Answer:</strong> Yes, but it will have a zero value.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  var name string
  fmt.Println(name) // Output: ""
}
</code></pre>
<h3 id="9-how-do-you-declare-a-variable-in-a-block"><a class="header" href="#9-how-do-you-declare-a-variable-in-a-block">9. How do you declare a variable in a block?</a></h3>
<p><strong>Answer:</strong> Use the <code>var</code> keyword inside a block.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  var (
    x int = 10
    y string = "Hello"
  )
  fmt.Println(x, y)
}
</code></pre>
<h3 id="10-what-is-the-difference-between-var-and-"><a class="header" href="#10-what-is-the-difference-between-var-and-">10. What is the difference between <code>var</code> and <code>:=</code>?</a></h3>
<p><strong>Answer:</strong> <code>var</code> can be used globally and allows explicit type declaration, while <code>:=</code> is shorthand for local variable declaration and type inference.</p>
<pre><code class="language-go">package main
import ("fmt")

func main() {
  var name string = "John" // Explicit type
  age := 30 // Type inferred
  fmt.Println(name, age)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-22
<strong>Category:</strong> interview-qa/Variadic
<strong>Tags:</strong> [go, Variadic Function]
]</p>
<h3 id="variadic-functions-in-go"><a class="header" href="#variadic-functions-in-go">Variadic Functions in Go</a></h3>
<p>A <strong>variadic function</strong> in Go is a function that can accept a variable number of arguments. You define a variadic function by placing <code>...</code> before the type in the function signature, which allows the function to accept multiple arguments of that type.</p>
<h3 id="example-code-variadic-function"><a class="header" href="#example-code-variadic-function">Example Code: Variadic Function</a></h3>
<pre><code class="language-go">package main

func print(number ...int) { // Variadic function to print numbers
	for _, n := range number {
		println(n) // Printing each number
	}
}

func main() {
	print(1, 2, 3, 4, 5) // Calling the variadic function with multiple arguments
	print(1, 2)           // Calling the variadic function with fewer arguments
	print(1)              // Calling the variadic function with a single argument
	print()               // Calling the variadic function with no arguments
}
</code></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation:</a></h3>
<ul>
<li><code>print(number ...int)</code> is a variadic function, meaning it can accept any number of <code>int</code> values.</li>
<li>In the <code>main()</code> function, different sets of arguments are passed to <code>print()</code>:
<ul>
<li>A set of 5 integers</li>
<li>A set of 2 integers</li>
<li>A single integer</li>
<li>No arguments at all</li>
</ul>
</li>
</ul>
<h3 id="more-explanation-on-variadic-functions"><a class="header" href="#more-explanation-on-variadic-functions">More Explanation on Variadic Functions:</a></h3>
<ul>
<li>A variadic function works by collecting all the arguments passed into a slice.</li>
<li>You can pass a slice directly to a variadic function using <code>...</code>, which unpacks the slice into individual arguments.</li>
</ul>
<h3 id="example-passing-a-slice-to-a-variadic-function"><a class="header" href="#example-passing-a-slice-to-a-variadic-function">Example: Passing a Slice to a Variadic Function</a></h3>
<pre><code class="language-go">package main

func print(numbers ...int) {
	for _, n := range numbers {
		println(n)
	}
}

func main() {
	nums := []int{10, 20, 30}
	print(nums...) // Unpacking a slice and passing to the variadic function
}
</code></pre>
<h3 id="interview-questions-and-answers-2"><a class="header" href="#interview-questions-and-answers-2">Interview Questions and Answers</a></h3>
<h4 id="1-what-is-the-advantage-of-using-variadic-functions-in-go"><a class="header" href="#1-what-is-the-advantage-of-using-variadic-functions-in-go">1. What is the advantage of using variadic functions in Go?</a></h4>
<p><strong>Answer:</strong>
Variadic functions allow for flexibility in function calls, enabling you to pass a varying number of arguments without needing to overload the function. This helps avoid writing multiple versions of the same function that differ only by the number of arguments they take.</p>
<h4 id="2-can-a-variadic-function-accept-multiple-types-of-arguments"><a class="header" href="#2-can-a-variadic-function-accept-multiple-types-of-arguments">2. Can a variadic function accept multiple types of arguments?</a></h4>
<p><strong>Answer:</strong>
No, a variadic function in Go accepts only one type of argument. However, you can work around this limitation by using an <code>interface{}</code> type, which allows for any type, but you will lose type safety.</p>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

import "fmt"

func printAnything(values ...interface{}) {
	for _, v := range values {
		fmt.Println(v)
	}
}

func main() {
	printAnything(1, "Hello", 3.14, true) // Accepting multiple types
}
</code></pre>
<h4 id="3-can-you-have-multiple-variadic-parameters-in-a-function"><a class="header" href="#3-can-you-have-multiple-variadic-parameters-in-a-function">3. Can you have multiple variadic parameters in a function?</a></h4>
<p><strong>Answer:</strong>
No, Go only allows one variadic parameter in a function. You cannot have more than one variadic parameter in the function signature.</p>
<h4 id="4-how-do-you-handle-a-variadic-function-when-no-arguments-are-passed"><a class="header" href="#4-how-do-you-handle-a-variadic-function-when-no-arguments-are-passed">4. How do you handle a variadic function when no arguments are passed?</a></h4>
<p><strong>Answer:</strong>
If no arguments are passed to a variadic function, the parameter inside the function will be an empty slice. This allows the function to still handle the case where no arguments are provided gracefully.</p>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

func print(numbers ...int) {
	if len(numbers) == 0 {
		println("No numbers provided")
		return
	}
	for _, n := range numbers {
		println(n)
	}
}

func main() {
	print() // No arguments provided
}
</code></pre>
<h4 id="5-can-you-pass-a-slice-to-a-variadic-function"><a class="header" href="#5-can-you-pass-a-slice-to-a-variadic-function">5. Can you pass a slice to a variadic function?</a></h4>
<p><strong>Answer:</strong>
Yes, you can pass a slice to a variadic function by using the <code>...</code> syntax to unpack the slice.</p>
<p><strong>Code Example</strong>:</p>
<pre><code class="language-go">package main

func print(numbers ...int) {
	for _, n := range numbers {
		println(n)
	}
}

func main() {
	nums := []int{10, 20, 30}
	print(nums...) // Passing a slice to a variadic function
}
</code></pre>
<p>This method unpacks the slice <code>nums</code> and passes its elements individually to the <code>print</code> function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="landing-project"><a class="header" href="#landing-project">Landing Project</a></h1>
<p>This project is a web application built with Next.js. Below are the steps to install and run the project.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Ensure you have the following installed on your system:</p>
<ul>
<li>Node.js (v16 or later)</li>
<li>npm or yarn (Node package managers)</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<ol>
<li>
<p>Clone the repository:</p>
<pre><code class="language-bash">git clone &lt;repository-url&gt;
</code></pre>
</li>
<li>
<p>Navigate to the <code>landing</code> directory:</p>
<pre><code class="language-bash">cd landing
</code></pre>
</li>
<li>
<p>Install dependencies:</p>
<pre><code class="language-bash">npm install
# or
yarn install
</code></pre>
</li>
</ol>
<h2 id="running-the-project"><a class="header" href="#running-the-project">Running the Project</a></h2>
<ol>
<li>
<p>Start the development server:</p>
<pre><code class="language-bash">npm run dev
# or
yarn dev
</code></pre>
</li>
<li>
<p>Open your browser and navigate to <code>http://localhost:3000</code> to view the application.</p>
</li>
</ol>
<h2 id="building-for-production"><a class="header" href="#building-for-production">Building for Production</a></h2>
<p>To build the project for production, run:</p>
<pre><code class="language-bash">npm run build
# or
yarn build
</code></pre>
<p>After building, you can start the production server with:</p>
<pre><code class="language-bash">npm start
# or
yarn start
</code></pre>
<h2 id="additional-scripts"><a class="header" href="#additional-scripts">Additional Scripts</a></h2>
<ul>
<li>
<p><strong>Linting:</strong></p>
<pre><code class="language-bash">npm run lint
# or
yarn lint
</code></pre>
</li>
<li>
<p><strong>Formatting:</strong></p>
<pre><code class="language-bash">npm run format
# or
yarn format
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-resources-1"><a class="header" href="#-resources-1">üìö Resources</a></h1>
<p>This chapter contains curated coding problems and learning materials collected from various competitive programming and interview preparation platforms.</p>
<h2 id="-contents"><a class="header" href="#-contents">üìå Contents</a></h2>
<ul>
<li>
<p><strong><a href="link-resources//link-resources/Problems/CF/index.html">Codeforces (CF)</a></strong><br />
A collection of selected problems categorized by difficulty and topic.</p>
</li>
<li>
<p><strong><a href="link-resources//link-resources/Problems/LeetCode/index.html">LeetCode</a></strong><br />
Popular coding interview questions organized by data structures and algorithms.</p>
</li>
<li>
<p><strong>Other Platforms</strong><br />
(Optional: Add links or folders for HackerRank, AtCoder, etc., if available.)</p>
</li>
</ul>
<h2 id="-platforms-included"><a class="header" href="#-platforms-included">‚ú® Platforms Included</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Platform</th><th style="text-align: left">Link to Website</th></tr></thead><tbody>
<tr><td style="text-align: left">Codeforces</td><td style="text-align: left"><a href="https://codeforces.com">https://codeforces.com/</a></td></tr>
<tr><td style="text-align: left">LeetCode</td><td style="text-align: left"><a href="https://leetcode.com">https://leetcode.com/</a></td></tr>
</tbody></table>
</div>
<h2 id="-goal"><a class="header" href="#-goal">üìà Goal</a></h2>
<ul>
<li>Improve problem-solving skills</li>
<li>Prepare for coding interviews</li>
<li>Strengthen algorithmic thinking</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-20
<strong>Category:</strong> e.g., link-resouces/problems
<strong>Tags:</strong> [go, problem solving, cf]
]</p>
<h1 id="problem-313---a"><a class="header" href="#problem-313---a">Problem 313 - A</a></h1>
<h2 id="problem-link"><a class="header" href="#problem-link">Problem Link</a></h2>
<p><a href="https://codeforces.com/problemset/problem/313/A">CodeForces Problem 313 - A</a></p>
<h1 id="problem-1676---b"><a class="header" href="#problem-1676---b">Problem 1676 - B</a></h1>
<h2 id="problem-link-1"><a class="header" href="#problem-link-1">Problem Link</a></h2>
<p><a href="https://codeforces.com/problemset/problem/1676/B">CodeForces Problem 1676 - B</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-23
<strong>Category:</strong> e.g., link-resouces/problems
<strong>Tags:</strong> [go, problem solving, leetcode]
]</p>
<h2 id="problem-link-2"><a class="header" href="#problem-link-2">Problem Link:</a></h2>
<p><a href="https://leetcode.com/problems/find-numbers-with-even-number-of-digits/description/">LeetCode 1295</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="students-will-keep"><a class="header" href="#students-will-keep">Students will keep</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-for-the-mini-cards-project"><a class="header" href="#documentation-for-the-mini-cards-project">Documentation for the mini cards project</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>[<strong>Author:</strong> @mdimamhosen
<strong>Date:</strong> 2025-04-23
<strong>Category:</strong> e.g., mini-projects/Quantique
<strong>Tags:</strong> [go, Quantique, mini-projects]
]</p>
<h1 id="-quantique---unit-converter-cli"><a class="header" href="#-quantique---unit-converter-cli">üîÅ Quantique - Unit Converter CLI</a></h1>
<p><strong>Quantique</strong> is a beautiful CLI-based Unit Converter written in Go.<br />
Easily convert between popular units with a modern, stylish terminal interface using <code>box-cli-maker</code> and <code>fatih/color</code>.</p>
<hr />
<h2 id="-features"><a class="header" href="#-features">üöÄ Features</a></h2>
<ul>
<li>‚úÖ Convert:
<ol>
<li>Meters ‚áå Feet</li>
<li>Feet ‚áå Meters</li>
<li>Celsius ‚áå Fahrenheit</li>
<li>Fahrenheit ‚áå Celsius</li>
<li>Kilograms ‚áå Pounds</li>
<li>Pounds ‚áå Kilograms</li>
</ol>
</li>
<li>üé® Elegant terminal UI with colors and box layout</li>
<li>üîÅ Seamless interactive loop with graceful exit</li>
</ul>
<hr />
<h2 id="-dependencies"><a class="header" href="#-dependencies">üì¶ Dependencies</a></h2>
<p>Make sure you have <a href="https://golang.org/dl/">Go</a> installed.</p>
<p>Initialize a Go module and install the required libraries:</p>
<pre><code class="language-bash">go mod init quantique
go get github.com/fatih/color
go get github.com/Delta456/box-cli-maker/v2
</code></pre>
<hr />
<h2 id="-how-to-run"><a class="header" href="#-how-to-run">üõ†Ô∏è How to Run</a></h2>
<pre><code class="language-bash">go build quantique.go
</code></pre>
<pre><code class="language-bash">./quantique.exe
</code></pre>
<hr />
<h2 id="-cli-preview"><a class="header" href="#-cli-preview">üì∏ CLI Preview</a></h2>
<pre><code>‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                     UNIT CONVERTER                ‚ïë
‚ïë  Convert Meters ‚áå Feet | Celsius ‚áå Fahrenheit     ‚ïë
‚ïë          | Kilograms ‚áå Pounds                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
</code></pre>
<hr />
<h2 id="-file-structure"><a class="header" href="#-file-structure">üìÅ File Structure</a></h2>
<pre><code>Quantique/
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îî‚îÄ‚îÄ main.go
</code></pre>
<hr />
<h2 id="-a-note-from-the-author"><a class="header" href="#-a-note-from-the-author">ü§ù A Note from the Author</a></h2>
<p>A small contribution to the incredible Best GoLang Community Ever</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ccwc-custom-word-count"><a class="header" href="#ccwc-custom-word-count">CCWC (Custom Word Count)</a></h1>
<p>A Go implementation of the Unix/Linux <code>wc</code> command that counts bytes, lines, words, and characters in text files.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Count bytes in a file (<code>-c</code>)</li>
<li>Count lines in a file (<code>-l</code>)</li>
<li>Count words in a file (<code>-w</code>)</li>
<li>Count characters in a file (<code>-m</code>)</li>
<li>Support for reading from both files and standard input (stdin)</li>
<li>Default mode that displays line, word, and byte counts together</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<ol>
<li>Ensure you have Go installed on your system</li>
<li>Navigate to the project directory:</li>
</ol>
<pre><code class="language-bash">cd /Users/rokib/Developer/go_projects/bgce-archive/mini-projects/ccwc
</code></pre>
<ol start="3">
<li>Build the project:</li>
</ol>
<pre><code class="language-bash">go build -o ccwc ./cmd/ccwc
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-bash">./ccwc [options] [filename]
</code></pre>
<p>If no filename is provided, ccwc reads from standard input.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<ul>
<li><code>-c</code>: Print the byte count</li>
<li><code>-l</code>: Print the line count</li>
<li><code>-w</code>: Print the word count</li>
<li><code>-m</code>: Print the character count (locale-dependent)</li>
</ul>
<p>If no options are provided, ccwc displays line count, word count, and byte count.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<ol>
<li>Count bytes in a file:</li>
</ol>
<pre><code class="language-bash">./ccwc -c testdata/test.txt
</code></pre>
<ol start="2">
<li>Count lines in a file:</li>
</ol>
<pre><code class="language-bash">./ccwc -l testdata/test.txt
</code></pre>
<ol start="3">
<li>Count words in a file:</li>
</ol>
<pre><code class="language-bash">./ccwc -w testdata/test.txt
</code></pre>
<ol start="4">
<li>Count characters in a file:</li>
</ol>
<pre><code class="language-bash">./ccwc -m testdata/test.txt
</code></pre>
<ol start="5">
<li>Default output (lines, words, and bytes):</li>
</ol>
<pre><code class="language-bash">./ccwc testdata/test.txt
</code></pre>
<ol start="6">
<li>Read from standard input:</li>
</ol>
<pre><code class="language-bash">cat testdata/test.txt | ./ccwc -m
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>mini-projects/ccwc/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ ccwc/
‚îÇ       ‚îî‚îÄ‚îÄ main.go       # Main application entry point
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îî‚îÄ‚îÄ processor/
‚îÇ       ‚îî‚îÄ‚îÄ processor.go  # Core processing functions
‚îú‚îÄ‚îÄ testdata/            # Test files directory
‚îÇ   ‚îî‚îÄ‚îÄ test.txt
‚îú‚îÄ‚îÄ go.mod               # Go module file
‚îî‚îÄ‚îÄ README.md           # This file
</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<p>The project is organized into two main components:</p>
<ol>
<li>
<p><strong>Processor Package</strong> (<code>internal/processor/processor.go</code>):</p>
<ul>
<li>Contains core counting functions</li>
<li>Implements byte, line, word, and character counting logic</li>
<li>Uses efficient buffered I/O operations</li>
</ul>
</li>
<li>
<p><strong>Main Package</strong> (<code>cmd/ccwc/main.go</code>):</p>
<ul>
<li>Handles command-line argument parsing</li>
<li>Manages file operations</li>
<li>Coordinates counting operations</li>
<li>Formats and displays output</li>
</ul>
</li>
</ol>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-cli"><a class="header" href="#todo-cli">Todo CLI</a></h1>
<p>A simple command-line interface (CLI) application for managing your to-do tasks, built with Go.</p>
<h2 id="features-1"><a class="header" href="#features-1">Features</a></h2>
<ul>
<li>Add new tasks</li>
<li>List all tasks (with --all flag for completed tasks)</li>
<li>Mark tasks as completed</li>
<li>Delete tasks</li>
</ul>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<pre><code>todo-cli/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ tasks/
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îî‚îÄ‚îÄ internal/
    ‚îî‚îÄ‚îÄ task/
        ‚îú‚îÄ‚îÄ task.go
        ‚îî‚îÄ‚îÄ storage.go
</code></pre>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<ol>
<li>Clone the repository:
<pre><code class="language-bash">git clone https://github.com/OxRokib/bgce-archive.git
</code></pre>
</li>
<li>Navigate to the project directory:
<pre><code class="language-bash">cd bgce-archive/mini-projects/todo-cli
</code></pre>
</li>
<li>Build the application:
<pre><code class="language-bash">go build -o todo cmd/tasks/main.go
</code></pre>
</li>
</ol>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="add-a-task"><a class="header" href="#add-a-task">Add a Task</a></h3>
<pre><code class="language-bash">./todo add "Your task description"
</code></pre>
<h3 id="list-tasks"><a class="header" href="#list-tasks">List Tasks</a></h3>
<p>List incomplete tasks:</p>
<pre><code class="language-bash">./todo list
</code></pre>
<p>List all tasks (including completed):</p>
<pre><code class="language-bash">./todo list --all
</code></pre>
<h3 id="mark-a-task-as-completed"><a class="header" href="#mark-a-task-as-completed">Mark a Task as Completed</a></h3>
<pre><code class="language-bash">./todo complete &lt;task-id&gt;
</code></pre>
<h3 id="delete-a-task"><a class="header" href="#delete-a-task">Delete a Task</a></h3>
<pre><code class="language-bash">./todo delete &lt;task-id&gt;
</code></pre>
<h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>comprehensive and detailed RBAC permission list</strong> Golang Community Vault platform. This will allow <strong>fine-grained control</strong> for various roles across all the directories and content types outlined in README.</p>
<hr />
<h2 id="-universal-permission-categories-applicable-to-all-modules"><a class="header" href="#-universal-permission-categories-applicable-to-all-modules">üîí Universal Permission Categories (Applicable to all modules)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Description</th></tr></thead><tbody>
<tr><td><code>view:&lt;resource&gt;</code></td><td>Can view/read the resource (public or restricted)</td></tr>
<tr><td><code>create:&lt;resource&gt;</code></td><td>Can create/upload new items</td></tr>
<tr><td><code>edit:&lt;resource&gt;</code></td><td>Can update or modify existing items</td></tr>
<tr><td><code>delete:&lt;resource&gt;</code></td><td>Can remove an item</td></tr>
<tr><td><code>publish:&lt;resource&gt;</code></td><td>Can mark content as published (if there‚Äôs a review process)</td></tr>
<tr><td><code>archive:&lt;resource&gt;</code></td><td>Can archive or unpublish without deletion</td></tr>
<tr><td><code>feature:&lt;resource&gt;</code></td><td>Can mark content as featured</td></tr>
<tr><td><code>comment:&lt;resource&gt;</code></td><td>Can comment on resource</td></tr>
<tr><td><code>moderate:&lt;resource&gt;</code></td><td>Can manage others' comments and discussions</td></tr>
<tr><td><code>rate:&lt;resource&gt;</code></td><td>Can give rating (if rating system exists)</td></tr>
<tr><td><code>tag:&lt;resource&gt;</code></td><td>Can add/edit tags or metadata</td></tr>
<tr><td><code>assign:&lt;resource&gt;</code></td><td>Can assign reviewers or contributors to a resource</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="-resource-specific-permissions"><a class="header" href="#-resource-specific-permissions">üîñ Resource-Specific Permissions</a></h2>
<p>Here's a breakdown by directory and subtype:</p>
<hr />
<h3 id="1-interview-qa"><a class="header" href="#1-interview-qa">1. <code>interview-qa/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>curate:interview_qa</code></td><td>Can organize, categorize, and reorder Q&amp;A content</td></tr>
<tr><td><code>bulk_upload:interview_qa</code></td><td>Upload multiple Q&amp;As via CSV or UI</td></tr>
<tr><td><code>label:difficulty_level</code></td><td>Can assign difficulty labels (easy/med/hard)</td></tr>
<tr><td><code>verify:interview_qa</code></td><td>Trusted users can verify accuracy of Q&amp;A</td></tr>
<tr><td><code>suggest_edit:interview_qa</code></td><td>Submit Q&amp;A revisions for approval</td></tr>
<tr><td><code>link:qa_to_topic</code></td><td>Link questions across topic-wise and company-wise sections</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="2-class-notes"><a class="header" href="#2-class-notes">2. <code>class-notes/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>format:class_note</code></td><td>Format content (LaTeX, markdown support)</td></tr>
<tr><td><code>translate:class_note</code></td><td>Upload alternate language versions</td></tr>
<tr><td><code>rate:note_quality</code></td><td>Rate based on helpfulness/accuracy</td></tr>
<tr><td><code>submit_note_review</code></td><td>Peer review notes</td></tr>
<tr><td><code>merge_notes</code></td><td>Combine similar notes into one resource</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="3-project-archive"><a class="header" href="#3-project-archive">3. <code>project-archive/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>link:project_github</code></td><td>Attach GitHub repo link</td></tr>
<tr><td><code>mark:project_stable</code></td><td>Certify project as stable/maintained</td></tr>
<tr><td><code>fork:community_project</code></td><td>Duplicate project into sandbox for experimentation</td></tr>
<tr><td><code>assign:maintainer</code></td><td>Assign project maintainers</td></tr>
<tr><td><code>create:project_tags</code></td><td>Define tags like "CLI", "REST", "gRPC" etc.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="4-image-infographic-archive"><a class="header" href="#4-image-infographic-archive">4. <code>image-infographic-archive/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>upload:image_infographic</code></td><td>Upload PNG/SVG/PDF</td></tr>
<tr><td><code>optimize:image</code></td><td>Resize/compress for performance</td></tr>
<tr><td><code>annotate:image</code></td><td>Add notes or highlight sections</td></tr>
<tr><td><code>group:infographics</code></td><td>Create themes/sets (e.g., Goroutine Internals Set)</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="5-community-stories"><a class="header" href="#5-community-stories">5. <code>community-stories/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>submit:story</code></td><td>Submit a personal or experience story</td></tr>
<tr><td><code>moderate:story</code></td><td>Approve or reject stories</td></tr>
<tr><td><code>tag:story_category</code></td><td>Label stories (job hunt, rejections, etc.)</td></tr>
<tr><td><code>feature:story</code></td><td>Highlight on community page</td></tr>
<tr><td><code>approve:anonymous_story</code></td><td>Allow anonymous publishing</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="6-package-archive"><a class="header" href="#6-package-archive">6. <code>package-archive/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>upload:package_source</code></td><td>Upload zip/tarball or Git link</td></tr>
<tr><td><code>verify:package_integrity</code></td><td>Ensure no malicious code</td></tr>
<tr><td><code>test:package</code></td><td>Run CI on submitted code</td></tr>
<tr><td><code>mark:package_deprecated</code></td><td>Deprecate old packages</td></tr>
<tr><td><code>create:package_doc</code></td><td>Write documentation for package</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="7-community-blogs"><a class="header" href="#7-community-blogs">7. <code>community-blogs/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>submit:blog_post</code></td><td>Write and submit a blog</td></tr>
<tr><td><code>edit:others_blog</code></td><td>Allow editing of other authors' blogs (moderator only)</td></tr>
<tr><td><code>review:blog_post</code></td><td>Can review before publishing</td></tr>
<tr><td><code>pin:blog_post</code></td><td>Pin post to top of page</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="8-news-events"><a class="header" href="#8-news-events">8. <code>news-events/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>submit:event</code></td><td>Submit conference or event</td></tr>
<tr><td><code>create:event_recap</code></td><td>Summarize events</td></tr>
<tr><td><code>organize:event_listing</code></td><td>Curate future/past events</td></tr>
<tr><td><code>assign:event_host</code></td><td>Add moderators for meetups/hackathons</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="9-video-archive"><a class="header" href="#9-video-archive">9. <code>video-archive/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>embed:video_link</code></td><td>Attach YouTube or local hosted video</td></tr>
<tr><td><code>transcribe:video</code></td><td>Add subtitle or transcript</td></tr>
<tr><td><code>review:video_content</code></td><td>Moderate for quality or relevance</td></tr>
<tr><td><code>feature:video</code></td><td>Spotlight video on homepage</td></tr>
<tr><td><code>clip:video_segment</code></td><td>Create mini-clips or highlights</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="10-course-content"><a class="header" href="#10-course-content">10. <code>course-content/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>submit:course_module</code></td><td>Create lessons or sections</td></tr>
<tr><td><code>assign:course_owner</code></td><td>Appoint course maintainer(s)</td></tr>
<tr><td><code>review:course_content</code></td><td>Approve/reject modules</td></tr>
<tr><td><code>track:course_progress</code></td><td>See student analytics (admin only)</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="11-link-resource-archive"><a class="header" href="#11-link-resource-archive">11. <code>link-resource-archive/</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>submit:link</code></td><td>Add blog/tool/documentation link</td></tr>
<tr><td><code>validate:link</code></td><td>Check for broken/dead links</td></tr>
<tr><td><code>approve:external_resource</code></td><td>Manual approval for outbound links</td></tr>
<tr><td><code>organize:bookmark_list</code></td><td>Allow curating themed collections</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="-bonus-system-permissions"><a class="header" href="#-bonus-system-permissions">‚úÖ Bonus System Permissions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>Applies to</th></tr></thead><tbody>
<tr><td><code>manage:users</code></td><td>Admin only ‚Äî manage roles, bans, profile data</td></tr>
<tr><td><code>manage:roles</code></td><td>Create/update roles and their permission sets</td></tr>
<tr><td><code>audit:logs</code></td><td>View user activity logs</td></tr>
<tr><td><code>backup:data</code></td><td>Export platform content</td></tr>
<tr><td><code>toggle:maintenance_mode</code></td><td>Take platform down for maintenance</td></tr>
<tr><td><code>view:analytics</code></td><td>See usage and traffic reports</td></tr>
<tr><td><code>send:notifications</code></td><td>System-wide announcement access</td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="-tech-stack--tools"><a class="header" href="#-tech-stack--tools">üß© <strong>Tech Stack &amp; Tools</strong></a></h2>
<p>This vault is powered by several modern tools and practices for collaboration, code sharing, and documentation. Feel free to explore more about our tech stack.</p>
<hr />
<h2 id="-inspiration--vision"><a class="header" href="#-inspiration--vision">üåü <strong>Inspiration &amp; Vision</strong></a></h2>
<p>‚Äú<strong>Code fades. Community lasts.</strong>‚Äù</p>
<p>This archive is designed to support, uplift, and celebrate the <strong>Golang Community</strong>. It‚Äôs not just about sharing code ‚Äî it‚Äôs about collecting <strong>collective knowledge</strong>, <strong>hard-won experiences</strong>, and <strong>stories that shape our journey</strong>. Whether you're new to Go or a veteran, this vault is your home.</p>
<hr />
<h2 id="-tech-stack-future-web-app-vision"><a class="header" href="#-tech-stack-future-web-app-vision">üß© <strong>Tech Stack (Future Web App Vision)</strong></a></h2>
<p>This vault is powered by several modern tools and practices for collaboration, code sharing, and documentation. Feel free to explore more about our tech stack:</p>
<p>If this turns into a community-driven web interface:</p>
<pre><code class="language-bash">‚Ä¢ Frontend: React / Svelte / Next.js / Vue
‚Ä¢ Backend: Go
‚Ä¢ Storage: GitHub + SQLite/Postgres
‚Ä¢ Auth: GitHub OAuth (optional)
‚Ä¢ Deployment: AWS
</code></pre>
<p>UI/UX ideas for the future web App</p>
<pre><code class="language-bash">Most preferable one for now:
1. Modern Library-Style UI
   - Homepage: A clean, minimalist grid of featured archives with a search bar in the center.
   - Filters &amp; Categories: Sidebar with quick access to categories (by year, author, tags, etc.).
   - Reading Mode: Dark/light mode toggle, distraction-free fullscreen mode.
   - Bookmarking &amp; Notes: Users can highlight text and add personal notes to archives.
</code></pre>
<p>Other types of UI</p>
<pre><code class="language-bash">2. Timeline-Based UI
3. Grid &amp; Gallery UI
4. Terminal-Inspired UI
5. Tag-Based UI
6. Map-Based UI
7. AI-Assisted UI
8. Infinite Scroll vs. Pagination Debate
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
